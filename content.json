{"posts":[{"title":"网站迁移说明","text":"网站迁移说明博客站 blog.rustfisher.com 和教程站 an.rustfisher.com 的网站资源已经上传到github。 rustfisher.github.io - github AnRFDev.github.io - github 并托管在cloudflare anrfdev-github-io.pages.dev -&gt; an.rustfisher.com rustfisher-github-io.pages.dev -&gt; blog.rustfisher.com 若访问速度过慢，可考虑使用🪜","link":"/2023/01/18/unclassified/web-res-move-2023/"},{"title":"2021年11月总结","text":"Android文章 Jetpack Compose引入示例工程 | AnRFDev 现有工程使用Compose | AnRFDev Android SeekBar 自定义thumb，thumb旋转动画效果 | AnRFDev 视频 【Android开发基础】03-改造初始工程 - bilibili 知乎视频 WebRTC WebRTC概念简介 | AnRFDev WebRTC打开本地摄像头 | AnRFDev WebRTC从摄像头获取图片传入canvas | AnRFDev WebRTC与CSS滤镜（filter） | AnRFDev 社区华为云社区 如何快速得到一个在线问卷应用？｜【玩转应用魔方】 华为云语音交互实战｜【我们都是华为云专家】 【云驻共创】区块链技术是如何影响各个产业的？","link":"/2021/11/30/Summary/2021-11/"},{"title":"WebRTC概念介绍","text":"WebRTCWebRTC（Web Real-Time Communication）。Real-Time Communication，实时通讯。 WebRTC能让web应用和站点之间选择性地分享音视频流。在不安装其它应用和插件的情况下，完成点对点通信。WebRTC背后的技术被实现为一个开放的Web标准，并在所有主要浏览器中均以常规JavaScript API的形式提供。对于客户端（例如Android和iOS），可以使用提供相同功能的库。 WebRTC是个开源项目，得到Google，Apple，Microsoft和Mozilla等等公司的支持。2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。 WebRTC包括一系列API和相互关联的协议来实现通信。 相关技术VoIPVoice over Internet Protocol，在网络上传输声音消息的技术。例如网络音频通话。或者叫做IP电话，宽带电话。使用VoIP技术的一大原因是费用低。 相关协议NATNetwork address translation，网络地址转换。NAT能给你的设备一个公共IP地址。一个路由器（router）有一个公共IP地址，每个连接到路由的设备有一个私有的IP地址。设备发送请求时，会从一个特定端口，通过私有IP发送到路由的公共IP。这样每个设备在网上不需要都有一个公共IP地址，但也能被其它设备发现。 参考 IP Network Address Translator (NAT) Terminology and Considerations ICEInteractive Connectivity Establishment，互动式连接建立（交互式连通性建立）。ICE是一套能让web浏览器之间互相连接的框架。通常来说，节点A到B是很难直接相连的。防火墙会阻止连接，设备没有公共IP地址，路由不允许直接连接其他节点。ICE使用STUN或者TURN服务（或者同时使用两者）来建立连接。 参考 ICE | rfc8445 STUNSession Traversal Utilities for NAT (STUN) ，NAT会话传输工具。STUN协议能发现客户端（节点）的公共地址。客户端发送一个请求给网上的STUN服务器，服务器返回客户端的公共地址。不管客户端在路由器的NAT后能否可达。STUN为请求者提供了可公开访问的IP地址，它就不再参与对话了。 有些路由器会限制设备与外面其它设备的连接。这意味着即使STUN服务器知道了路由的公共IP地址，也没法建立连接。这种情况下我们需要使用TURN。 TURNTraversal Using Relays around NAT，使用中继绕过NAT传输。一些路由器使用一种叫“Symmetric NAT”（对称型NAT）的限制。这意味着路由器仅允许之前连接过的节点（peer）来建立连接。 STUN提供了一个能让应用（终端，节点）穿过NAT的方法。STUN允许客户端获得一个传输地址（一个IP和端口）来获取其它节点的数据。然而STUN获取到的地址不一定能被所有节点使用。这些地址是否可用取决于网络拓扑的情况。所以，单独STUN无法提供完整的穿越NAT的方案。 TURN协议允许两个处于NAT环境的主机利用中继进行通讯。客户端能够在TURN服务器上分配资源，与其它客户端（peer）进行通讯。客户端关联一个TURN服务器的地址（relayed server address）来作为中继。客户端发送报文给TURN服务，TURN服务使用relayed server address作为源地址向其他客户端中继转发报文。穿越NAT，这个过程就像是“打洞”。也有人称TURN服务器为“打洞服务器”。 这么看，TURN服务器需要有大的带宽。因此，ICE会优先考虑直接通讯，无法直接通讯情况下会使用TURN。 参考 TURN rfc8656 SDPSession Description Protocol，会话描述协议。 描述多媒体连接内容的协议。例如分辨率，格式，编码，加密算法等等。 实际上，SDP不是个真正的协议。它也是用来描述设备之间连接与传输多媒体的数据格式。 参考 SDP: Session Description Protocol | rfc8866 参考 媒体设备入门 ｜ webrtc.org 2个节点建立连接时的沟通过程 ｜ MDN WebRTC 协议介绍 ｜ developer.mozilla.org 信令与视频通话 ｜ developer.mozilla.org","link":"/2021/11/09/WebRTC/webRTC-concept-intro/"},{"title":"Python抓取博客记录，获取标题与url","text":"在博客网站发布了一些博客。总共有四十多篇。现在查看这些博客需要翻页，不是很方便。想要弄出一个列表，把标题和链接展示出来。如果手动去复制粘贴，耗时耗力，也不够自动化。有没有什么自动化的方法呢？想到以前用python做过抓取的功能。 开发环境： Python3.7 PyCharm 2018.3.7 (Community Edition) macOS 11.4 安装scrapy我们主要使用的框架是scrapy，官网 https://scrapy.org/ 如果需要换用清华的pip源，执行下面的命令12pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 根据官网文档进行安装1pip3 install Scrapy 分析目标网页目标网页的部分html如下12345&lt;div class=&quot;blog-menu blog-menu-noImg&quot;&gt; &lt;div class=&quot;blog-menu-header blog_no_attachment&quot;&gt; &lt;a id=&quot;portal_usercenter_2_usernew_blog_title_cus_i_0&quot; href=&quot;/blogs/301790&quot; class=&quot;common-blog-title&quot; title=&quot;Kotlin协程取消与超时&quot; target=&quot;_blank&quot; style=&quot;margin-left: 0px; color: rgb(51, 51, 51);&quot;&gt;&lt;span class=&quot;blog-title-wrap&quot; style=&quot;overflow-wrap: break-word;&quot;&gt; Kotlin协程取消与超时 &lt;/span&gt;&lt;/a&gt;&lt;/div&gt;需要提取的是标题（title）和网址（url）。 shell工具使用scrapy shell工具来分析一下目标网页1scrapy shell 'https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_1'windows下的url需要用双引号 可以看到如下的运行结果1234567891011121314152021-10-13 09:46:47 [asyncio] DEBUG: Using selector: KqueueSelector[s] Available Scrapy objects:[s] scrapy scrapy module (contains scrapy.Request, scrapy.Selector, etc)[s] crawler &lt;scrapy.crawler.Crawler object at 0x7fd889766990&gt;[s] item {}[s] request &lt;GET https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_1&gt;[s] response &lt;200 https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_1&gt;[s] settings &lt;scrapy.settings.Settings object at 0x7fd88987bb50&gt;[s] spider &lt;DefaultSpider 'default' at 0x7fd889c7b710&gt;[s] Useful shortcuts:[s] fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)[s] fetch(req) Fetch a scrapy.Request and update local objects [s] shelp() Shell help (print this help)[s] view(response) View response in a browser2021-10-13 09:46:48 [asyncio] DEBUG: Using selector: KqueueSelector 尝试用scrapy的css()方法来提取元素，操作它的response变量 例如提取div.blog-menu1234In [2]: response.css('div.blog-menu')Out[2]: [&lt;Selector xpath=&quot;descendant-or-self::div[@class and contains(concat(' ', normalize-space(@class), ' '), ' blog-menu ')]&quot; data='&lt;div class=&quot;blog-menu blog-menu-noImg&quot;&gt;&lt;'&gt;,...可以得到页面上所有满足要求的元素。拿到的元素是Selector，可以再进行下一步的操作。 用for循环读取提取到的元素，在此基础上，去抓取中文标题12345678910111213In [6]: for item in response.css('div.blog-menu'): ...: print(item.css('a.common-blog-title::attr(title)').extract()[0]) ...: Kotlin协程取消与超时Android Kotlin协程入门Kotlin协程基础Kotlin协程入门Android View post 方法Android Activity 传递Parcelable对象Android Handler，Looper与MessageQueue使用与分析Android线程池使用介绍Java线程介绍使用ECharts绘制网址径向树状图 a.common-blog-title::attr(title)表示的是我们要查找&lt;a&gt;里面的内容，指定class为common-blog-title，并且查找title属性。css().extract()将结果列表提取出来。最后得到我们关心的信息。 获取url同理，把提取部分修改为::attr(href) 代码前面用shell工具进行分析，我们了解提取目标信息的方法。接下来写Python代码。 在合适的地方新建一个scrapy工程1scrapy startproject blog可以得到一系列文件123456789blog spiders .gitignore __init__.py __init__.py items.py middlewares.py pipelines.py settings.py 在spiders目录里新建一个文件Hw.py，它就是我们的“蜘蛛”。完整代码如下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import jsonimport scrapydef cmp(item): return item['page']class HwBlog(scrapy.Spider): &quot;&quot;&quot; 在最外层的blog目录进行操作 scrapy crawl hw &quot;&quot;&quot; name = &quot;hw&quot; # scrapy crawl hw res_list = [] req_count = 0 total_url = 5 def start_requests(self): self.res_list = [] urls = [] base_url = 'https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_' for i in range(1, self.total_url + 1): urls.append(base_url + str(i)) for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): self.req_count = self.req_count + 1 page = response.url.split(&quot;_&quot;)[-1] for item in response.css('div.blog-menu'): title_se = item.css(&quot;a.common-blog-title&quot;) blog_url = 'https://bbs.huaweicloud.com' + (title_se.css(&quot;::attr(href)&quot;).extract()[0]) blog_title = title_se.css(&quot;::attr(title)&quot;).extract()[0] self.res_list.append({&quot;title&quot;: blog_title, &quot;url&quot;: blog_url, &quot;page&quot;: page}) json_res = json.dumps(self.res_list, ensure_ascii=False) print(json_res) res_file_path = 'raw/hw.json' with open(res_file_path, 'w+') as f: f.write(json_res) if self.req_count &lt; self.total_url: return res_md = 'raw/hw.md' self.res_list.sort(key=cmp) # 用页码来排序 with open(res_md, 'w+') as f: f.writelines('## 华为云社区') f.write('\\n博客数量:' + str(len(self.res_list)) + '\\n') for d in self.res_list: f.write('\\n') f.write('- [' + d['title'] + '](' + d['url'] + ')') 要启动的话，输入以下命令1scrapy crawl hw 接下来简单看一下代码 变量name是蜘蛛的名字。我们启动的时候会用到它。这个名字由我们自己定义。 res_list是暂存结果的列表。把获取到的结果暂时存放在里面。 total_url表示一共要爬几个页面 req_count表示请求次数 start_requests(self)在这个方法里进行一些配置工作。比如配置目标url。我们是预先知道有5个页面，所以配置了5个url。 用scrapy.Request(url=url, callback=self.parse)构建请求 parse是回调函数，请求成功后走这个方法。 parse(self, response)请求成功后，结果保存在response中。前面用shell进行的操作，可以直接写成python代码。 当请求次数达到目标后，开始写文件。 小结这是Python scrapy的一次简单应用。 安装scrapy，分析目标网页。把获取到的数据整理后写成markdown文件。 视频在这里","link":"/2021/10/13/Python/scrapy-hw-blog-record/"},{"title":"2021年9月总结","text":"Android给Android站添加更多色彩。使用Mkdocs的功能，增加折叠功能和按钮。 增加了一个「最近更新」的界面。在md里写html。手动汇总一下最近的更新信息。 做了一个导航页面 https://an.rustfisher.com/an-tree.html。开发记录在这里 -&gt; 使用ECharts绘制网址径向树状图。 Kotlin入门了协程。了解了协程的基本概念。 网站修改利用mkdocs的插件，增加一些功能。 增加引用一个markdown文件，可以引用其它文件的内容。用的框架是mkdocs，需要加入插件。在mkdocs.yml文件里加入plugins声明 12345plugins: - search - macroscopyright: Copyright &amp;copy; 2020 - 2021 RustFisher 注意它与copyright同级。 但是还需要在电脑本地安装一下这个macros1pip3 install mkdocs-macros-plugin md引用其他文件的语法是1{% include 'snippet.md' %} 如果要指定被引用文件的路径12- macros: include_dir: include-md注意include_dir必须再缩进8个空格 参考: https://www.mkdocs.org/user-guide/configuration/#configuration-inheritance https://mkdocs-macros-plugin.readthedocs.io/en/latest/#installation https://mkdocs-macros-plugin.readthedocs.io/en/latest/advanced/#including-snippets-in-pages 总览同一篇文会先发在🔗 Android教程站，并同步发布到各个社区，更新内容汇总: Android协程基础 🔗 Android教程站 华为云社区 🔗 掘金社区 🔗 博客园 Kotlin协程取消与超时 🔗 Android教程站 华为云社区 Kotlin协程基础 🔗 Android教程站 华为云社区 🔗 掘金社区 🔗 博客园 Kotlin协程入门 🔗 Android教程站 华为云社区 🔗 掘金社区 🔗 博客园 🔗 链滴 Android View post 方法解析 🔗 Android教程站 华为云社区 🔗 掘金社区 🔗 链滴 🔗 博客园 Android Activity 传递Parcelable对象 🔗 Android教程站 华为云社区 🔗 segmentfault Handler，Looper与MessageQueue使用与分析 🔗 Android教程站 🔗 华为云社区 Android使用线程池介绍 🔗 Android教程站 华为云社区 🔗 掘金社区 🔗 博客园 🔗 链滴 Android多线程综述 🔗 Android教程站 Java多线程介绍 🔗 Android教程站 华为云社区 🔗 掘金社区 🔗 博客园 🔗 链滴 Android合集的最近更新 展望每个月多写一点。加强对网络通信的学习。","link":"/2021/09/30/Summary/2021-9/"},{"title":"使用ECharts绘制网址径向树状图","text":"an.rustfisher.com有很多内容，很多页面。如果用一个树状图把所有页面展示出来会是什么效果？第一时间想到了ECharts。 最后效果： https://an.rustfisher.com/an-tree.html 数据处理数据来源于配置文件。我们只需要把内容读出来，整理成ECharts需要的格式并保存为文件。 ymlAndroid站用的框架是Mkdocs，网址都设置在mkdocs.yml里。关键配置如下 1234567nav: - Android basic: - 开始: - 新建工程: android/startProject/start_new_project.md - 使用Kotlin: android/startProject/as-use-kotlin.md - Activity: - Activity综述: android/activity/overview.md 我们需要把这些数据读出来，弄成ECharts可以用的格式。 打开PyCharm，用python来处理数据。 python处理数据我们使用3.7版本python。要读取yml的内容，不想用读文本的方式一行行来读，还得自己解析。python中有个库PyYAML专门用于读取yml格式的数据。 在PyCharms里装上这个包。用它来读取yml里的数据。123456import yaml with open(md_file, encoding='utf8') as a_yaml_file: # 解析yaml yaml_data = yaml.load(a_yaml_file, Loader=yaml.FullLoader) nav = yaml_data['nav'] ECharts需要的格式是name和children。同时可以添加别的字段。12345678{ &quot;name&quot;: &quot;Android教程&quot;, &quot;children&quot;: [ { &quot;name&quot;: &quot;Android basic&quot;, &quot;children&quot;: [] }]} 读取到的数据层级比较多，用递归方法来处理它们。把所有的数据都遍历一遍，整理成需要的格式。 递归的时候，遇到数组，则继续递归；遇到字符串，则表示可以拼接网址了。 完整脚本如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import jsonimport osimport yamldef gen_url_map(main_site, md_file): with open(md_file, encoding='utf8') as a_yaml_file: # 解析yaml yaml_data = yaml.load(a_yaml_file, Loader=yaml.FullLoader) nav = yaml_data['nav'] sorted_data = {&quot;name&quot;: &quot;Android教程&quot;, &quot;children&quot;: [], &quot;collapsed&quot;: False} for big_dict in nav: load_url(main_site, big_dict, sorted_data) url_file = 'android-url-map.json' if os.path.exists(url_file): os.remove(url_file) with open(url_file, 'w') as s: s.write(str(json.dumps(sorted_data, ensure_ascii=False)))def load_url(main_site, input_dict, res_data): &quot;&quot;&quot; 递归处理数据 &quot;&quot;&quot; for k1 in input_dict: v1 = input_dict[k1] if isinstance(v1, list): item1 = {&quot;name&quot;: k1, &quot;children&quot;: []} res_data['children'].append(item1) for v1_child in v1: load_url(main_site, v1_child, item1) elif isinstance(v1, str): # 此时已经是url了 final_item = {&quot;name&quot;: k1, &quot;url&quot;: main_site + v1[0:-3]} res_data['children'].append(final_item) return final_itemif __name__ == '__main__': print(&quot;生成android站的sitemap&quot;) gen_url_map('https://www.an.rustfisher.com/', '/Users/rustfisher/mkdocs.yml') 最后写一个android-url-map.json文件。 制作网页经过观察，我们选用径向树状图（tree-radial）。查看ECharts的径向树状图使用示例，下载一个示例html，在它的基础上修改。 添加上jquery的引用。1&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt; 修改要读取的json文件名1$.getJSON('./android-url-map.json', function (data) { /* ... */ } 把前面得到的json文件和这个html文件放在同一层级，上传服务器。 打开： https://an.rustfisher.com/an-tree.html 可以看到效果。 扩大显示范围这个时候的网页体验不是很好，页面不够大，图表超出上下范围了。可以给它添个竖直的滚动条overflow-y: scroll。1&lt;html style=&quot;height: 100%; width: 100%; overflow-y: scroll;&quot;&gt; 修改一下网页的body。外层的container占100%宽高，里面的chartContainer给一个min-height: 1600px。1234&lt;body style=&quot;height: 100%; margin: 0; width: 100%;&quot;&gt; &lt;div id=&quot;container&quot; style=&quot;height: 100%; width: 100%;&quot;&gt; &lt;div id=&quot;chartContainer&quot; style=&quot;width: 100%; min-height: 1600px&quot;&gt;&lt;/div&gt; &lt;/div&gt; script里加上对resize的监听12345$(window).on('resize', function () { if (myChart != null &amp;&amp; myChart != undefined) { myChart.resize(); }}); 这时再看浏览器的效果，图表有了更多的空间显示。 参考 https://stackoverflow.com/questions/33454946/echarts-and-bootstrap-responsive-width https://stackoverflow.com/questions/12575251/why-is-my-page-not-scrollable 点击打开页面默认点击效果是折叠和展开。对于最末尾的叶子节点，加一个点击事件让它打开相应的界面。 12345myChart.on('click', function (params) { if (params.data &amp;&amp; params.data.url) { window.open(params.data.url); }}); 最后效果： https://an.rustfisher.com/an-tree.html","link":"/2021/09/02/Web/note-echarts-py-url/"},{"title":"2021年8月总结","text":"除了继续学习Android开发，也在其它方面做了一些拓展尝试。看了一些其它的技术。 技术文章这个月主要以Android为主。参加了华为云社区的云驻共创活动。 状态码造成微信公众号“该公众号提供的服务出现故障” 【云驻共创】Knative应用开发指南 【云驻共创】基于转移的语义Parser分享 Android继续完善Android站。这个月的Android方面博客/教程文章主要涉及动画、WorkManager和广播等基础知识。 WorkManager使用入门 WorkManager工作约束，延迟与查询工作 Android WorkManager定时任务 使用AnimationDrawable 补间动画 ObjectAnimator 更改视图位置 广播机制Broadcast介绍与使用 启动前台服务 View综述 展望继续完善Android内容。尝试更多的新技术。","link":"/2021/08/31/Summary/2021-8/"},{"title":"状态码造成微信公众号“该公众号提供的服务出现故障”","text":"bug描述我们使用NestJS写后台代码，给微信公众号提供服务。用户给公众号发消息时，公众号会显示“该公众号提供的服务出现故障”。虽然后台代码可以正常处理业务，但这个提示非常影响用户体验。 检查根据微信公众号文档给的提示，出现这个问题的原因是没有给微信服务器返回正确的信息。 微信服务器需要的是success或者空的字符串。不能是json格式的字符串。搜了一下其他文章，有的说xml里也不能带有空格；有的说公众号绑定了第三方平台，要去解绑。但这些和我们的情况不一致。 给公众号的接口是默认返回success的。 查看运行log，发现用户发送1条消息给公众号，我们的服务端会收到4条一模一样的消息。这4条消息的MsgId是一样的。网上也有人提供了防止重复消息的办法。 于是尝试以下方法 维护一个map，key是MsgId。 接收到消息后，如果发现是重复的MsgId，则立刻返回success（或者空字符串）。 但是问题依旧没有解决。 微信服务器认为它没有拿到正确的返回值，于是走了重试的流程。我们ubuntu服务器上使用了nginx，于是我们查看nginx的log123481.69.1.1 - - [03/Aug/2021:09:41:25 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 0 &quot;-&quot; &quot;Mozilla/4.0&quot;81.69.1.1 - - [03/Aug/2021:09:41:26 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 7 &quot;-&quot; &quot;Mozilla/4.0&quot;81.69.1.1 - - [03/Aug/2021:09:41:26 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 7 &quot;-&quot; &quot;Mozilla/4.0&quot;42.192.1.1 - - [03/Aug/2021:09:41:26 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 7 &quot;-&quot; &quot;Mozilla/4.0&quot;可以看到有2个ip地址，发来了3+1次请求。看到nginx返回的状态码都是201。(ip地址和信息模糊处理) 状态码201表示“已创建”。NestJS默认状态码是200，但是默认POST的状态码是201。 修复我们强制让nestjs返回状态码200123@HttpCode(200)@Post()async onWxEvent(@Body('xml') xmlData: IWxMessageXmlData): Promise&lt;string&gt; {} 再尝试一下，看到nginx的log，返回状态码是200了。公众号也正常了。181.69.1.1 - - [03/Aug/2021:09:53:27 +0800] &quot;POST /mywxserve/?signature=rustfisher&amp;timestamp=1627955607&amp;nonce=1829147547&amp;openid=xxx0 HTTP/1.1&quot; 200 0 &quot;-&quot; &quot;Mozilla/4.0&quot; 由此可见，接收微信公众号消息的时候，除了要返回空字符串或者success文本；返回状态码必须是200。用其他的后台框架可能不会遇到状态码问题。 参考 wx基础消息能力-被动回复用户消息 https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html NestJS controller https://docs.nestjs.com/controllers#status-code NestJS文章集合 https://rustfisher.com/categories/NestJS/ http状态码 https://rustfisher.com/2021/06/25/Network/http-code/","link":"/2021/08/03/NestJS/mp-wx-http-status-code/"},{"title":"NestJS WebSocket 开始使用","text":"使用NestJs提供WebSocket服务。本文会在新建项目的基础上增加2个类 Gateway 实现业务逻辑的地方 WebSocketAdapter WebSocket适配器 新建项目新建一个项目来演示，用npm来管理项目。1nest new websocket-start 得到一个有基础功能的工程。 进入项目目录，安装2个库1npm i --save @nestjs/websockets @nestjs/platform-socket.io 启动使用端口30011await app.listen(3001);npm run start启动我们的工程。用postman测一下，功能ok。 gateway介绍Nest里的gateway(网关)只是一个用 @WebSocketGateway() 装饰器注释的类。从技术上讲，网关与平台无关，在创建适配器后它们与任何 WebSockets 库都兼容。 新建Gateway新建ws.gateway.ts文件。在装饰器@WebSocketGateway()里端口指定为3002。123456789101112131415import { ConnectedSocket, MessageBody, SubscribeMessage, WebSocketGateway } from &quot;@nestjs/websockets&quot;;import * as WebSocket from 'ws';@WebSocketGateway(3002)export class WsStartGateway { @SubscribeMessage('hello') hello(@MessageBody() data: any): any { return { &quot;event&quot;: &quot;hello&quot;, &quot;data&quot;: data, &quot;msg&quot;: 'rustfisher.com' }; }}里面有一个hello方法，订阅的消息是'hello'。 把它放进AppModule的providers里。1providers: [WsStartGateway], 如果websockt和http用了同一个接口(本例是3001)，启动时会报错1Error: listen EADDRINUSE: address already in use :::3001因此我们这里给ws分配另一个端口号。 获取WebSocket对象在WsStartGateway里新增加一个消息订阅方法。方法里接受@ConnectedSocket() client: WebSocket，这个client就是与客户端的连接对象。我们可以用它来给客户端发送消息。123456@SubscribeMessage('hello2')hello2(@MessageBody() data: any, @ConnectedSocket() client: WebSocket): any { console.log('收到消息 client:', client); client.send(JSON.stringify({ event: 'tmp', data: '这里是个临时信息' })); return { event: 'hello2', data: data };} 自定义WebSocketAdapter前面我们建立好了Gateway，还需要一个适配器。新建文件ws.adapter.ts，继承WebSocketAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import * as WebSocket from 'ws';import { WebSocketAdapter, INestApplicationContext } from '@nestjs/common';import { MessageMappingProperties } from '@nestjs/websockets';import { Observable, fromEvent, EMPTY } from 'rxjs';import { mergeMap, filter } from 'rxjs/operators';export class WsAdapter implements WebSocketAdapter { constructor(private app: INestApplicationContext) { } create(port: number, options: any = {}): any { console.log('ws create') return new WebSocket.Server({ port, ...options }); } bindClientConnect(server, callback: Function) { console.log('ws bindClientConnect, server:\\n', server); server.on('connection', callback); } bindMessageHandlers( client: WebSocket, handlers: MessageMappingProperties[], process: (data: any) =&gt; Observable&lt;any&gt;, ) { console.log('[waAdapter]有新的连接进来') fromEvent(client, 'message') .pipe( mergeMap(data =&gt; this.bindMessageHandler(client, data, handlers, process)), filter(result =&gt; result), ) .subscribe(response =&gt; client.send(JSON.stringify(response))); } bindMessageHandler( client: WebSocket, buffer, handlers: MessageMappingProperties[], process: (data: any) =&gt; Observable&lt;any&gt;, ): Observable&lt;any&gt; { let message = null; try { message = JSON.parse(buffer.data); } catch (error) { console.log('ws解析json出错', error); return EMPTY; } const messageHandler = handlers.find( handler =&gt; handler.message === message.event, ); if (!messageHandler) { return EMPTY; } return process(messageHandler.callback(message.data)); } close(server) { console.log('ws server close'); server.close(); }}在bindMessageHandler方法中，会将传来的json消息解析，然后发送到对应的处理器中。这里就是发给gateway进行处理。判断依据是message.event，就是event字段。 在main.ts里使用这个适配器。12345678910import { NestFactory } from '@nestjs/core';import { AppModule } from './app.module';import { WsAdapter } from './ws/ws.adapter';async function bootstrap() { const app = await NestFactory.create(AppModule); app.useWebSocketAdapter(new WsAdapter(app)); // 使用我们的适配器 await app.listen(3001);}bootstrap(); npm run start运行项目，准备进一步测试。 用Postman来测试WebSocketPostman8.8.0提供了beta版的WebSocket测试功能。New -&gt; WebSocket Request beta新建一个WebSocket测试。当前版本还不支持保存ws的测试例子。输入目标url ws://localhost:3002，点击连接 Connect 按钮。 发送测试消息。在消息框里填入以下json数据。1234{ &quot;event&quot; : &quot;hello&quot;, &quot;data&quot; : &quot;测试数据&quot;} 发送的数据经过WsAdapter分发给WsStartGateway，处理后返回数据。 发送hello2测试数据1234{ &quot;event&quot; : &quot;hello2&quot;, &quot;data&quot; : &quot;测试数据&quot;} 可以看到服务返回了2条数据。 发送一个错误格式的数据12{ &quot;event&quot; : &quot;hello2 服务端接收到了数据，但是解析失败1ws解析json出错 SyntaxError: Unexpected end of JSON input 小结要使用WebSocket功能，需要增加 Gateway 实现业务逻辑的地方 WebSocketAdapter WebSocket适配器 ws的端口建议是和http的端口分开。 参考 NestJS WebSockets https://docs.nestjs.com/websockets/gateways NestJS 合集 https://rustfisher.com/categories/NestJS/ 示例工程 https://gitee.com/rustfisher/nest-sample","link":"/2021/07/22/NestJS/nestjs-websocket-start/"},{"title":"Python图表库Matplotlib 组成部分介绍","text":"图表有很多个组成部分，例如标题、x/y轴名称、大刻度小刻度、线条、数据点、注释说明等等。 我们来看官方给的图，图中标出了各个部分的英文名称 Matplotlib提供了很多api，开发者可根据需求定制图表的样式。前面我们设置了标题和x/y轴的名称，本文介绍更多设置其他部分的方法。 绘图先绘制一个事例图。然后以此为基础进行定制。123456789101112131415161718def demo2(): x_list = [] y_list = [] for i in range(0, 365): x_list.append(i) y_list.append(math.sin(i * 0.1)) ax = plt.gca() ax.set_title('rustfisher.com mapplotlib example') ax.set_xlabel('x') ax.set_ylabel('y = sin(x)') ax.grid() plt.plot(x_list, y_list) plt.show()if __name__ == '__main__': print('rustfisher 图表讲解') demo2()运行得到 红色框框里的是figure；绿色框框里的叫做ax。代码中ax = plt.gca()获取到的就是绿色框框里的部分（对象）。 Figure 大图Figure代表整张图，暂时称为“全图”或者“大图”。一张图里可以有多个子图表。最少必须要有一个图表。像上面那样。 Axes 数据图一张张的图，图里显示着数据，暂称为“数据图”。一个大图里可以有多个数据图。但单个数据图对象只能在1个大图里。 多张数据图 subplots例如同时存在2个数据图 123456789101112131415161718def demo_subplot(): x_list = [] y_list = [] y2_list = [] for i in range(0, 365): x_list.append(i) y_list.append(math.sin(i * 0.1)) y2_list.append(math.cos(i * 0.1)) fig, (ax1, ax2) = plt.subplots(2) ax1.set_title('rustfisher.com 1') ax2.set_title('rustfisher.com 2') ax1.set_xlabel('x') ax1.set_ylabel('y = sin(x)') ax2.set_xlabel('x') ax2.set_ylabel('y = cos(x)') ax1.plot(x_list, y_list) ax2.plot(x_list, y2_list) plt.show() 调用subplots()接口，传入数字指定要多少张数据图。返回的多张图要用括号括起来。每个数据图可以绘制(plot)不同的数据。标题用set_title()来设置。 可以看到上下两张图太挤了，有重叠部分。可以在plt.show()之前加一个fig.tight_layout()让它们拉开一点距离。 坐标轴对于2维数据图，它有2个坐标，横坐标和纵坐标。有一些接口可以设置参数。例如控制坐标轴的名字set_xlabel() set_ylabel； 显示数据范围set_xlim方法可以控制x轴数据显示范围。同理y轴用set_ylim来控制。对于显示范围，set_xlim方法主要参数为left和right；或者用xmin xmax。这两套不能同时使用。set_ylim主要参数是top bottom；或者ymin ymax。这两套不能同时使用。 增加显示范围控制的代码1234567891011121314151617181920212223242526def demo3(): x_list = [] y_list = [] y2_list = [] for i in range(0, 365): x_list.append(i) y_list.append(math.sin(i * 0.1)) y2_list.append(math.cos(i * 0.1)) fig, (ax1, ax2) = plt.subplots(2) ax1.set_title('rustfisher.com 1') ax1.set_xlabel('x') ax1.set_ylabel('y = sin(x)') ax2.set_title('rustfisher.com 2') ax2.set_xlabel('x') ax2.set_ylabel('y = cos(x)') ax1.set_xlim(left=50, right=200.6) # 控制x轴显示范围 ax1.set_ylim(top=1, bottom=0.3) # 控制y轴显示范围 ax2.set_xlim(xmin=1, xmax=156.6) # 控制x轴显示范围 ax2.set_ylim(ymin=-0.3, ymax=0.3) # 控制y轴显示范围 ax1.plot(x_list, y_list) ax2.plot(x_list, y2_list) fig.tight_layout() plt.show() 运行结果 刻度tick意思是标记。在坐标轴上的是刻度。Major tick暂称为大刻度，minor tick暂称为小刻度。使用set_xticks方法控制刻度显示。传入的列表是我们希望显示的刻度。minor参数默认为False，不显示小刻度。 关键代码如下1234567ax1.set_xticks([50, 60, 70, 150])ax1.set_yticks([0.1, 0.2, 0.3, 0.7, 0.9])ax1.grid() # 显示格子ax2.set_xticks([1, 60, 70, 150], minor=True)ax2.set_yticks([-0.1, 0, 0.1, 0.3], minor=True)ax2.grid() 可见当minor=True，传入的刻度列表有可能不显示。 也可以控制大刻度上的文字旋转12plt.setp(ax1.xaxis.get_majorticklabels(), rotation=-45)plt.setp(ax2.xaxis.get_majorticklabels(), rotation=-60) 边线 spinespine是脊柱的意思，这里我们先称为边线。有上下左右4条边线。名称是top bottom left right可以直接从图表对象获取它的边线，比如右边线ax1.spines.right。 一些简单的操作，例如 set_visible 显示和隐藏 set_ticks_position 刻度显示的位置 set_bounds 边线显示范围 set_linewidth 线的宽度 隐藏右边线和上边线12ax1.spines.right.set_visible(False)ax1.spines.top.set_visible(False) 让刻度显示在右边和上方12ax2.yaxis.set_ticks_position('right')ax2.xaxis.set_ticks_position('top') 设置边线显示范围12ax3.spines.left.set_bounds(-0.5, 0.5)ax3.spines.top.set_bounds(340, 400) 设置线的宽度1ax3.spines.bottom.set_linewidth(2) 完整代码如下123456789101112131415161718192021222324252627282930313233import mathimport matplotlib.pyplot as pltdef demo_spine(): x_list = [] y_list = [] for i in range(0, 365): x_list.append(i) y_list.append(math.sin(i * 0.1)) fig, (ax1, ax2, ax3) = plt.subplots(3) ax_list = [ax1, ax2, ax3] for i in range(0, 3): cur_ax = ax_list[i] cur_ax.set_title('rustfisher.com ' + str(i)) cur_ax.plot(x_list, y_list) cur_ax.set_xlabel('x') cur_ax.set_ylabel('y = sin(x)') ax1.spines.right.set_visible(False) ax1.spines.top.set_visible(False) ax2.spines.bottom.set_visible(False) ax2.spines.left.set_visible(False) ax2.yaxis.set_ticks_position('right') ax2.xaxis.set_ticks_position('top') ax3.spines.left.set_bounds(-0.5, 0.5) ax3.spines.top.set_bounds(340, 400) ax3.spines.bottom.set_linewidth(2) fig.tight_layout() plt.show() 运行截图 数据点控制数据点的样式。下面我们在一张图表里绘制多条数据线。 123456789101112131415def demo_line(): x_list = [] y_list = [] y2_list = [] y3_list = [] for i in range(0, 20): x_list.append(i) y_list.append(math.sin(i) * 2 - 4) y2_list.append(math.sin(i) * 2) y3_list.append(math.cos(i) * 1.3 + 3) plt.plot(x_list, y_list, color='blue', linestyle='-.', linewidth=2, markersize=4) plt.plot(x_list, y2_list, 'go', linewidth=1) plt.plot(x_list, y3_list, 'r+') plt.show() plot()方法中，支持多种选项。 linestyle支持的选项‘-‘, ‘–’, ‘-.’, ‘:’, ‘None’, ‘ ‘, ‘’, ‘solid’, ‘dashed’, ‘dashdot’, ‘dotted’ 注释 legend添加注释，调用lengend()方法。 在前面代码基础上添加1234plt.plot(x_list, y_list, color='blue', linestyle='-.', linewidth=2, markersize=4)plt.plot(x_list, y2_list, 'go', linewidth=1)plt.plot(x_list, y3_list, 'r+')plt.legend(['math.sin(i) * 2 - 4', 'math.sin(i) * 2', 'math.cos(i) * 1.3 + 3']) 控制注释显示的地方，添加bbox_to_anchor和bbox_transform属性12plt.legend(['math.sin(i) * 2 - 4', 'math.sin(i) * 2', 'math.cos(i) * 1.3 + 3'], bbox_to_anchor=(1, 1), bbox_transform=plt.gcf().transFigure) 中文乱码问题在设置标题用到中文的时候，可能会出现乱码。可以设置rcParams的字体，解决乱码问题。1plt.rcParams['font.sans-serif'] = ['Arial Unicode MS'] 至此，我们把图表中各个部分都简要介绍了一下。 参考本例环境 macOS PyCharm CE Python3 参考资料 【运营的Python指南】绘制图表Matplotlib快速入门 https://rustfisher.com/2021/07/16/Python/operation/matplotlib-intro1 Python笔记 https://rustfisher.com/categories/Python/ matplotlib https://matplotlib.org/","link":"/2021/07/20/Python/operation/matplotlib-intro-parts/"},{"title":"【运营的Python指南】绘制图表Matplotlib快速入门","text":"绘制图表是运营工作中常见的需求。前面我们试着用Python操作Excel来绘制图表，其实调用的是Excel里的图表功能。接下来我们利用Matplotlib来绘制图表。 Matplotlib 是一个综合性的库。它是 Python 的可视化工具，可创建静态、带动画和可交互的图表Matplotlib 官网 https://matplotlib.org/官方使用手册 https://matplotlib.org/stable/users/index.html 安装官方给出的安装方法是使用pip12python -m pip install -U pippython -m pip install -U matplotlib 我们使用PyCharm，也可以先打1import matplotlib.pyplot as plt其中matplotlib下面有红线，跟着PyCharm的提示，把缺失的包装上就好。 简单例子-绘制折线图接下来使用matplotlib绘制一个简单的折线图，先把这个库用起来。 准备数据我们用math.sin来模拟。x从0到100，y=sin(x)。一个简单的sin函数。 绘制准备数据，然后绘制出图表。完整代码如下12345678910111213141516import mathimport matplotlib.pyplot as pltdef demo1(): x_list = [] y_list = [] for i in range(0, 100): x_list.append(i) y_list.append(math.sin(i * 0.1)) plt.plot(x_list, y_list) plt.show()if __name__ == '__main__': print('rustfisher 绘制折线图事例1') demo1() Mac的PyCharm运行下能得到这样的图 代码中 plt.plot(x_list, y_list)指定x，y值，都是列表。这2个列表的长度要相等。 plt.show()是直接绘制图表。 可以看到图中缺少很多元素。图的标题没有指定，x轴和y轴都没有说明。 增加一些细节为操作图表，我们需拿到图表对象ax = plt.gca()12345ax = plt.gca()ax.set_title('rustfisher.com mapplotlib example')ax.set_xlabel('x')ax.set_ylabel('y = sin(x)')ax.grid() set_title 设置图表标题 set_xlabel 设置x轴名称 set_ylabel 设置y轴名称 grid() 显示格子 修改后的代码如下12345678910111213def demo1(): x_list = [] y_list = [] for i in range(0, 100): x_list.append(i) y_list.append(math.sin(i * 0.1)) ax = plt.gca() ax.set_title('rustfisher.com mapplotlib example') ax.set_xlabel('x') ax.set_ylabel('y = sin(x)') ax.grid() plt.plot(x_list, y_list) plt.show() 运行结果 操作说明从前面图中我们可以看到下面有一排按钮。这些按钮提供了一些操作图表的功能。从左到右我们排个序1，2，3，4.. 让图表恢复到初始状态 上一个图表状态 下一个图表状态 移动图表 缩放图表 调整图表显示的位置 点击缩放按钮后，鼠标按住左键去框选一个区域，松开左键后就是放大那个区域。 按住右键再框选，则是缩小显示区域。 保存图片 直接保存如果我们想直接保存得到的图片，可以不调用show方法。而是调用savefig()方法。 12# plt.show()plt.savefig('out.png') 参考 Python操作Excel来绘制图表 https://rustfisher.com/2019/11/19/Python/Python-op-excel_openpyxl_bar_column_chart/ Python绘制漏斗图 https://rustfisher.com/2021/06/28/Python/Python-op-draw-funnel-1/ Python合集 https://rustfisher.com/categories/Python/","link":"/2021/07/16/Python/operation/matplotlib-intro1/"},{"title":"NestJS 静态文件","text":"为了提供静态资源，我们可以用@nestjs/serve-static包里的ServeStaticModule。服务器上的静态资源，一般指的是文件，比如图片、音频、视频、文本文件或者二进制文件等等。 或者是一些单页面应用程序(Single Page Application, SPA)。从服务器上请求得到网页，然后网页再执行自己的业务。 安装首先我们需要安装@nestjs/serve-static包。在工程路径下1$ npm install --save @nestjs/serve-static 安装完成后，工程的package.json里会多出123&quot;dependencies&quot;: { &quot;@nestjs/serve-static&quot;: &quot;^2.1.4&quot;,} 使用在root AppModule中，引入ServeStaticModule模块。 12345678910import { ServeStaticModule } from '@nestjs/serve-static';@Module({ imports: [ ServeStaticModule.forRoot({ rootPath: join(__dirname, '..', 'rustfisherData'), exclude: ['/api*'], }),],})export class AppModule { } imports里添加了ServeStaticModule模块。需要用到ServeStaticModule.forRoot方法。 rootPath 指定了静态文件的根目录 exclude 表明排除在外的文件和目录 路径说明我们关心的是，服务器上哪个目录可以让客户端访问，哪个目录是不开放的。 __dirname 获取到的是当前目录的路径。使用join()方法，拼接出一个新的路径。 工程编译出来的文件放在dist目录中。app.module.js文件也在里面。此时__dirname表示的是dist目录的路径。那么join(__dirname, '..', 'rustfisherData')得到的路径就是与dist目录同级的rustfisherData。 假设我们服务器上运行目录是/home/rustfisher/server/rf-server-nest/dist那么静态文件存放的目录就是/home/rustfisher/server/rf-server-nest/rustfisherData 配置ServeStaticModule提供了丰富的自定义控制。开发者可以自定义它的行为。比如像前面那样设置静态文件根目录rootPath；设置排除的路径exclude。 GitHub上有详细配置 注意访问目录时，默认会找index.html文件发送回去。后文会有更多说明。 客户端访问假设服务部署好了（并不是真实项目），网址是 https://rustfisher.com 。部署好服务后，我们测试一下。 打开浏览器，访问url： https://rustfisher.com/some/path/to/img/11.jpg可以在网页上看到图片（并不是真实项目）。 如果访问一个不存在的路径（文件），它会返回一个默认的index.html。如果没有这个文件，则会报一个ENOENT错误信息12[Nest] 32378 - 07/10/2021, 8:15:00 PM [ExceptionsHandler] ENOENT: no such file or directory, stat '/home/rustfisher/server/rf-server-nest/rustfisherData/index.html' +234539ms 不想让它报这个错，我们可以自己弄一个index.html文件放到对应路径上。这样做的话，访问目录或者不存在的文件会默认返回index.html文件。 小结提供访问静态文件的功能比较常见。客户端使用一个url，就能访问服务器上的文件。现在很常见的做法是把文件放在CDN上，减轻服务器的io压力和网络压力。在Linux服务器上，nginx和同类的服务也能轻松实现类似的提供静态文件的功能。","link":"/2021/07/10/NestJS/nestjs-static-file/"},{"title":"MongoDB安装和部署","text":"MongoDB的版本可以在官网 https://docs.mongodb.com/manual/installation/ 上查询。 我们使用的是社区版。 mac目前用mac来开发，需要在本地安装运行一个mongdb，便于测试调试。 安装mac上安装mongodb。在终端中用brew来安装速度有点太慢了。 我们去 https://www.mongodb.com/try/download/enterprise 下载一个mac使用的版本。在网页右侧选择mongodb版本（这里选的是4.4.4），Platform选择macOS，压缩格式选tgz即可。点击Download需要填一些资料。填好后确认Submit即可。下载后解压文件，得到一个文件夹。 1234567891011121314151617181920mongodb-macos-x86_64-enterprise-4.4.6├── LICENSE-Enterprise.txt├── MPL-2├── README├── THIRD-PARTY-NOTICES├── bin│ ├── install_compass│ ├── mongo│ ├── mongocryptd│ ├── mongod│ ├── mongodecrypt│ ├── mongokerberos│ ├── mongoldap│ └── mongos└── snmp ├── MONGOD-MIB.txt ├── MONGODBINC-MIB.txt ├── README-snmp.txt ├── mongod.conf.master └── mongod.conf.subagent 我们将这个目录复制到/usr/local/mongo中，需要用到管理员权限。 修改~/.bash_profile，添加如下命令。即mongo的目录添加到环境变量中12# mongo dbexport PATH=$PATH:/usr/local/mongo/bin 此时可以重启命令行（终端）。 检查版本mongod --version123456789101112~ $ mongod --versiondb version v4.4.4Build Info: { &quot;version&quot;: &quot;4.4.4&quot;, &quot;gitVersion&quot;: &quot;8db30a63db1a9d84bdcad0c83369623f708e0397&quot;, &quot;modules&quot;: [], &quot;allocator&quot;: &quot;system&quot;, &quot;environment&quot;: { &quot;distarch&quot;: &quot;x86_64&quot;, &quot;target_arch&quot;: &quot;x86_64&quot; }}能看到版本说明mongodb安装完成。 启动Mac上启动。我们可以指定数据库路径--dbpath和log位置--logpath1sudo mongod --dbpath /Users/rustfisher/.mongodb/data --logpath /Users/rustfisher/.mongodb/log/mongodb1.log 如果不用sudo，可能会报错1ERROR: child process failed, exited with 14 后台启动，需要加上--fork1234$ sudo mongod --dbpath /Users/rustfisher/.mongodb/data --logpath /Users/rustfisher/.mongodb/log/mongodb1.log --port 1993 --forkabout to fork child process, waiting until server is ready for connections.forked process: 7580child process started successfully, parent exiting 查询mongo进程123$ ps aux | grep mongrustfisher 7608 0.0 0.0 4268424 732 s003 S+ 7:45下午 0:00.00 grep mongroot 7580 0.0 0.2 5548488 27868 ?? S 7:44下午 0:01.02 mongod --dbpath /Users/rustfisher/.mongodb/data --logpath /Users/rustfisher/.mongodb/log/mongodb1.log --fork Ubuntu我们的服务器一般是Linux。接下来在Ubuntu上安装运行mongodb。 安装Ubuntu上安装mongodb比较简单，用apt-get命令。 先upadate一次1sudo apt-get update 然后装上4.4.4版本的mongodb1sudo apt-get install -y mongodb-org=4.4.4 mongodb-org-server=4.4.4 mongodb-org-shell=4.4.4 mongodb-org-mongos=4.4.4 mongodb-org-tools=4.4.4 等它装完后，看一下版本号1234567891011121314~$ mongod --versiondb version v4.4.4Build Info: { &quot;version&quot;: &quot;4.4.4&quot;, &quot;gitVersion&quot;: &quot;8db30a63db1a9d84bdcad0c83369623f708e0397&quot;, &quot;openSSLVersion&quot;: &quot;OpenSSL 1.0.2g 1 Mar 2016&quot;, &quot;modules&quot;: [], &quot;allocator&quot;: &quot;tcmalloc&quot;, &quot;environment&quot;: { &quot;distmod&quot;: &quot;ubuntu1604&quot;, &quot;distarch&quot;: &quot;x86_64&quot;, &quot;target_arch&quot;: &quot;x86_64&quot; }}可以发现，这里的gitVersion和前面用mac装的是一样的。一些关于Linux的操作笔记，可以访问 https://rustfisher.com/tags/Linux/ 运行Ubuntu操作mongodb的官方文档 默认的配置文件为 /etc/mongod.conf 把端口改为1993，服务器如果启用了防火墙，记得允许1993端口1sudo ufw allow 1993或者在云服务器控制台那里检查一些，是否开放了端口 服务器使用的是systemctl 启动mongodb1sudo systemctl start mongod 查看状态1sudo systemctl status mongod 重启1sudo systemctl restart mongod MongoDB Compasss前面我们已经安装好了mongodb，并且运行起来了。接下来我们找一个有图形化界面的软件来访问数据库。 MongoDB Compass能让用户清晰地看到文档结构，执行查询，修改等等操作。 在这里可以下载MongoDB Compasss https://www.mongodb.com/try/download/compass这里我们使用mac下的1.25.0版本。 连接到本地的数据库，在Compass中选择新建连接1mongodb://127.0.0.1:1993/rustfisher-db?readPreference=primary&amp;appname=MongoDB%20Compass&amp;ssl=false前面我们启动mongodb是在1993端口，连接的时候要注意端口号。 127.0.0.1是我们本地的ip，如果要连接到服务器的mongodb，一般可以直接用服务器ip来连接。 例如服务器公网ip是1.2.3.4，端口是19931mongodb://1.2.3.4:1993/rustfisher-db?readPreference=primary&amp;appname=MongoDB%20Compass&amp;ssl=false 连上mongodb后，就可以自由地进行操作了。","link":"/2021/07/09/MongoDB/mongodb-install-deploy/"},{"title":"【运营的Python指南】绘制漏斗图","text":"写给运营朋友的Python指南。 漏斗图可对业务的各个关键环节进行描述，衡量各个环节的业务表现。可以非常直观地看到各个业务地转化程度。 本文介绍使用Python从Excel中读取数据，使用pyecharts绘制漏斗图。 操作步骤说明下面是操作的具体步骤。 1.开发环境示例使用的IDE是PyCharm社区版，开发语言是Python3.x。 在工程中，新建Python文件demo_data_funnel.py。然后在同级的位置新建一个res文件夹，后面用来存放文件。 2.准备数据创建一个Excel文件事件demo.xlsx。将表名改为data3。这个名字在代码中会用到。 写入两列数据123456事件 次数e1 10000e2 4695e3 2584e4 1295e5 954得到如下的表格： 与demo_data_funnel.py同级的地方新建了res文件夹，把Excel文件放进去。 这里我们暂时用测试数据看效果。后面再填入你的真实数据。 3.编写脚本现在开始写Python代码。demo_data_funnel.py完整的代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from openpyxl import load_workbookfrom pyecharts.charts import Funnelimport pyecharts.options as optsdef read_in_data(file_path): print('获取原始数据 &gt;&gt;&gt;') wb = load_workbook(file_path) st = wb['data3'] data_list = [] for row_index in range(2, st.max_row + 1): event_name = st.cell(row=row_index, column=1).value event_value = st.cell(row=row_index, column=2).value data_list.append([event_name, event_value]) print(data_list) return data_listdef draw_funnel_default(input_data): print('绘制漏斗图 &gt;&gt;&gt; https://gallery.pyecharts.org/#/Funnel/funnel_base') ( Funnel(init_opts=opts.InitOpts(width=&quot;800px&quot;, height=&quot;400px&quot;)) .add(series_name='漏斗1', data_pair=input_data, ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;漏斗图1&quot;, subtitle=&quot;默认样式&quot;)) .render(&quot;funnel_chart_1.html&quot;) )def draw_funnel_2(input_data): print('绘制漏斗图1 &gt;&gt;&gt; https://gallery.pyecharts.org/#/Funnel/funnel_base') ( Funnel(init_opts=opts.InitOpts(width=&quot;1000px&quot;, height=&quot;600px&quot;)) .add(series_name='漏斗1', data_pair=input_data, label_opts=opts.LabelOpts(position=&quot;inside&quot;, formatter='{b} 数量: {c}'), gap=2, tooltip_opts=opts.TooltipOpts(trigger=&quot;item&quot;, formatter=&quot;{a} &lt;br/&gt;{b} 数量: {c}&quot;), ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;漏斗图1&quot;, subtitle=&quot;改变了label&quot;)) .render(&quot;funnel_chart_2.html&quot;) )def draw_funnel_3(input_data): print('绘制漏斗图2 &gt;&gt;&gt; https://gallery.pyecharts.org/#/Funnel/funnel_base') data = input_data.copy() # 复制一份出来处理标题 base_value = data[0][1] for x in range(0, len(data)): event_name = data[x][0] value = data[x][1] # 拿到数值 ratio = value / base_value event_name += '\\n总体转化率: {:.2f}%'.format(ratio * 100) if x &gt; 0: event_name += '\\n相对转化率: {:.2f}%'.format(100 * value / data[x - 1][1]) data[x][0] = event_name print(event_name) ( Funnel(init_opts=opts.InitOpts(width=&quot;1000px&quot;, height=&quot;800px&quot;)) .add(series_name='漏斗1', data_pair=data, label_opts=opts.LabelOpts(position=&quot;inside&quot;, formatter='{b}\\n数量: {c}'), gap=2, tooltip_opts=opts.TooltipOpts(trigger=&quot;item&quot;, formatter=&quot;{a} &lt;br/&gt;{b} 数量: {c}&quot;), ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;漏斗图1&quot;, subtitle=&quot;修改了各项的标题&quot;)) .render(&quot;funnel_chart_3.html&quot;) )if __name__ == '__main__': src_data = read_in_data('res/事件demo.xlsx') draw_funnel_default(src_data) draw_funnel_2(src_data) draw_funnel_3(src_data)把上面的代码复制进你的脚本里。可能会需要装上pyecharts和openpyxl。用PyCharm的时候，可以点到报红线的地方，根据它的提示，把这2个库装上。 运行代码，会得到3个html文件 用浏览器打开这3个html就可以看到效果了。 把你的数据填到那个Excel里，保存。然后运行代码即可。 比如说把Excel里的事件改一下 运行代码，可以得到新的结果 以上是简化流程，运营朋友照着做，一般都可以看到运行结果。下面我们来看一些细节。 读取数据我们先准备一些测试数据。新建一个xlsx文件，填入测试数据。如下图： 我们把数据放在了data3里。A列是事件名称，B列是次数。名称这里可以随意替换，可根据业务需求进行修改。事件流程按照先后顺序，从上到下排列好。 首先需要把数据从excel中读取出来。我们用openpyxl来操作。12345678910111213from openpyxl import load_workbookdef read_in_data(file_path): print('获取原始数据 &gt;&gt;&gt;') wb = load_workbook(file_path) st = wb['data3'] data_list = [] for row_index in range(2, st.max_row + 1): event_name = st.cell(row=row_index, column=1).value event_value = st.cell(row=row_index, column=2).value data_list.append([event_name, event_value]) print(data_list) return data_list将事件名和数据装到一个小的列表里[event_name, event_value]。所有的事件放进一个大的列表，并返回。 当然，从别的途径拿到数据也是可以的。 绘制漏斗图我们用pyecharts来绘制漏斗图。 Echarts 是一个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是一门富有表达力的语言，很适合用于数据处理。当数据分析遇上数据可视化时，pyecharts 诞生了。 pyecharts会输出html文件。 默认样式拿到数据后，我们把数据传给Funnel。 123456789101112131415from pyecharts.charts import Funnelimport pyecharts.options as optsdef draw_funnel_default(input_data): print('绘制漏斗图 &gt;&gt;&gt; https://gallery.pyecharts.org/#/Funnel/funnel_base') ( Funnel(init_opts=opts.InitOpts(width=&quot;800px&quot;, height=&quot;400px&quot;)) .add(series_name='漏斗1', data_pair=input_data, ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;漏斗图1&quot;, subtitle=&quot;默认样式&quot;)) .render(&quot;funnel_chart_1.html&quot;) )if __name__ == '__main__': src_data = read_in_data('res/事件demo.xlsx') draw_funnel_default(src_data) 初始配置里设定宽高 InitOpts(width=&quot;800px&quot;, height=&quot;400px&quot;) input_data就是我们前面获取的数据列表；将它传给data_pair，即data_pair=input_data 输出的网页文件名为funnel_chart_1.html set_global_opts()方法设置全局配置 标题设置 title=&quot;漏斗图1&quot; 副标题设置 subtitle=&quot;默认样式&quot; 输出的html文件，用浏览器打开，如图： 鼠标放上去会有小弹框提示（tooltip） 🔗 默认样式网页的链接 修改labelpyecharts开放了很多配置。我们可以修改一下每一项的标题。123456789101112def draw_funnel_2(input_data): print('绘制漏斗图1 &gt;&gt;&gt; https://gallery.pyecharts.org/#/Funnel/funnel_base') ( Funnel(init_opts=opts.InitOpts(width=&quot;1000px&quot;, height=&quot;600px&quot;)) .add(series_name='漏斗1', data_pair=input_data, label_opts=opts.LabelOpts(position=&quot;inside&quot;, formatter='{b} 数量: {c}'), gap=2, tooltip_opts=opts.TooltipOpts(trigger=&quot;item&quot;, formatter=&quot;{a} &lt;br/&gt;{b} 数量: {c}&quot;), ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;漏斗图1&quot;, subtitle=&quot;改变了label&quot;)) .render(&quot;funnel_chart_2.html&quot;) ) formatter {a}是series_name，在这里是图表的名字 {b}是这一项的标题 {c}是这一项的数量 tooltip_opts和label_opts都会用到formatter。 🔗 浏览网页 自己计算转化率为了显示出相对转化率和总体转化率。我们可以自己计算。 123456789101112131415161718192021222324def draw_funnel_3(input_data): print('绘制漏斗图2 &gt;&gt;&gt; https://gallery.pyecharts.org/#/Funnel/funnel_base') data = input_data.copy() # 复制一份出来处理标题 base_value = data[0][1] for x in range(0, len(data)): event_name = data[x][0] value = data[x][1] # 拿到数值 ratio = value / base_value event_name += '\\n总体转化率: {:.2f}%'.format(ratio * 100) if x &gt; 0: event_name += '\\n相对转化率: {:.2f}%'.format(100 * value / data[x - 1][1]) data[x][0] = event_name print(event_name) ( Funnel(init_opts=opts.InitOpts(width=&quot;1000px&quot;, height=&quot;800px&quot;)) .add(series_name='漏斗1', data_pair=data, label_opts=opts.LabelOpts(position=&quot;inside&quot;, formatter='{b}\\n数量: {c}'), gap=2, tooltip_opts=opts.TooltipOpts(trigger=&quot;item&quot;, formatter=&quot;{a} &lt;br/&gt;{b} 数量: {c}&quot;), ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;漏斗图1&quot;, subtitle=&quot;修改了各项的标题&quot;)) .render(&quot;funnel_chart_3.html&quot;) ) 在for循环里计算转化率，并把结果写到事件的名称里。 🔗 浏览网页","link":"/2021/06/28/Python/Python-op-draw-funnel-1/"},{"title":"HTTP状态码","text":"HTTP状态码被分成了5大类。本文对每一类常见的状态码进行总结。 列出的是HTTP/1.1规范推荐使用的原因短语。 100~199 信息性状态码 状态码 原因短语 描述 (图文无关) 100 Continue 说明收到了请求的初始部分，请客户端继续。 101 Switching Protocols 说明服务器正在根据客户端的指定，将协议切换成Update首部所列的协议 * 200~299 成功状态码 状态码 原因短语 描述 (图文无关) 200 OK OK 201 Created * 202 Accepted * 203 Non-Authoritative Information * 204 No Content * 205 Reset Content * 206 Partical Content * 300~399 重定向状态码 状态码 原因短语 描述 (图文无关) 300 Multiple Choices 客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和法语版本。服务器可以在location首部包含首选URL。 301 Moved Permanently 在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL。 302 Found 与301类似，但客户端应该使用Location首部给出的URL来临时定位资源。 304 Not Modified 有条件的首部。如果客户端发起了一个条件GET请求，而最近资源未被修改，就可以用这个状态码来说没资源未被修改。带有这个状态码的响应不应该包含实体的主体部分。 * 400~499 客户端错误状态码 状态码 原因短语 描述 (图文无关) 400 Bad Request 告知客户端发送了一个错误的请求。 401 Unauthorized 未认证。 403 Forbidden 请求被服务器拒绝。 404 Not Found 服务器无法找到所请求的URL。 405 Method Not Allowed 发起的请求中带有所请求的URL不支持的方法时，使用此状态码。应该在响应中包含Allow首部，以告知客户端对所请求的资源可以使用哪些方法。 406 Not Acceptable 服务器没有与客户端可接受的URL相匹配的资源时，使用此代码。 408 Request Timeout 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。 410 Gone 与404类似，只是服务器曾经有过此资源。 411 Length Required 服务器要求Content-Length首部。 412 Precondition Failed 客户端发起了条件请求，且其中一个条件失败了。 415 Unsupported Media Type 服务器无法理解或无法支持客户端所发实体的内容类型。 416 Requested Range Not Satisfiable 请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足。 500~599 服务器错误状态码 状态码 原因短语 描述 (图文无关) 500 Internal Server Error 服务器遇到一个妨碍它为请求提供服务的错误 501 Not Implement 客户端发起的请求超过服务器能力范围 503 Service Unavailable 服务器现在无法为请求提供服务，但将来可以 504 Gateway Timeout 与408类似，只是这里的响应来自一个网关或代理 505 HTTP Version Not Supported 服务器收到的请求使用了它无法或不愿支持的协议版本 *","link":"/2021/06/25/Network/http-code/"},{"title":"NestJS 部署与维护","text":"我们可以把nestjs的工程传到服务器上，然后直接进行npm操作。也可以在本地打包出nestjs的包，将dist目录传到服务器上。 在这里为了方便演示，我们描述的是将工程传到服务器后的操作。传工程文件，可以用github/gitee当作中间桥梁，也可以用vscode的插件传输，或者使用scp命令。 同理，dist目录也可以传到github/gitee上，服务器直接使用编译好的文件。 直接启动启动前，进入工程目录，先安装一次。1$ npm install 用npm run命令启动服务12345# 开发模式$ npm run start# 观察模式$ npm run start:dev 在服务器上，运行正式环境（生产环境 production）12345# 启动生产环境前 先start$ npm run start# 生产环境$ npm run start:prod使用npm run运行的程序，可以ctrl + c停止。 run起来后，编译后的文件在dist目录里。 使用pm2管理pm2是常用的node进程管理工具，它可以提供node.js应用管理，如自动重载、性能监控、负载均衡等。 在服务器上，我们使用npm安装这个工具1npm install pm2 安装完毕后，查看一下版本12$ pm2 -v4.4.1 pm2启动服务我们知道，nestjs编译后的文件在dist目录里，入口文件是dist/main.js 用pm2启动服务之前，先把该装的库用npm装好。运行npm run start:prod，然后ctrl + c停止。 接下来用pm2启动1pm2 start dist/main.js --name=&quot;这里是自定义的名字&quot; 查看服务使用命令pm2 list查看服务 例如在某个服务器上12345678910$ pm2 list ┌─────┬───────────────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐│ id │ name │ namespace │ version │ mode │ pid │ uptime │ ↺ │ status │ cpu │ mem │ user │ watching │├─────┼───────────────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤│ 3 │ rustfisher-debug │ default │ 1.0.0 │ fork │ 12260 │ 2M │ 0 │ online │ 0% │ 39.7mb │ ubuntu │ disabled ││ 2 │ rustfisher-release│ default │ 1.0.0 │ fork │ 12090 │ 2M │ 46 │ online │ 0% │ 44.6mb │ ubuntu │ disabled ││ 0 │ index │ default │ 1.0.0 │ fork │ 0 │ 0 │ 68 │ stopped │ 0% │ 0b │ ubuntu │ disabled ││ 1 │ index │ default │ 1.0.0 │ fork │ 0 │ 0 │ 15 │ stopped │ 0% │ 0b │ ubuntu │ disabled ││ 4 │ an.rustfisher │ default │ 0.0.1 │ fork │ 32252 │ 74m │ 0 │ online │ 0% │ 51.5mb │ ubuntu │ disabled │└─────┴───────────────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘ 停止服务想要停止某个服务，使用pm2 stop + 服务名（name）或者id 例如1pm2 stop rustfisher-debug执行完毕后，会自动运行一次pm2 list 重启服务用pm2 restart + 服务名（name）或者id1pm2 restart rustfisher-debug或者1pm2 restart 3 日志管理默认情况下，pm2的日志存放在~/.pm2/log里。每个启动的服务有对应的log文件。 例如，在某个服务器上123$ ls .pm2/logs/app-error.log dr-debug-error.log dr-release-error.log index-error.log www-error.logapp-out.log dr-debug-out.log dr-release-out.log index-out.log www-out.log nohup后台启动我们也可用nohup后台启动。 进入工程目录，运行1nohup npm run start:prod &gt;&gt; nohup.log &amp; 查看进程12345$ ps -aux | grep nodeubuntu 11826 0.0 1.2 674064 10988 ? Ssl Mar16 0:00 /usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/update-notifier/check.js {&quot;pkg&quot;:{&quot;name&quot;:&quot;npm&quot;,&quot;version&quot;:&quot;6.14.6&quot;}}ubuntu 16478 0.0 0.0 4512 788 pts/3 S 11:49 0:00 sh -c node dist/mainubuntu 16479 0.4 5.1 578840 45228 pts/3 Sl 11:49 0:00 node dist/mainubuntu 16959 0.0 0.1 13232 928 pts/3 S+ 11:52 0:00 grep --color=auto node可以看到有2个相关的进程16478和16479 查看端口占用情况。假设我们工程监听的是8090端口。12345$ netstat -anp | grep 8090(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)tcp 0 0 127.0.0.1:52788 127.0.0.1:8090 TIME_WAIT - tcp6 0 0 :::8090 :::* LISTEN 16479/node 结合一看，进程16479是我们后台运行的服务没错了。 停止后台进程1sudo kill 16479kill然后再查询进程和端口占用情况，就没有相关的进程了。 总结可以用不同的方式后台启动服务。启动生产环境之前，要先同步并编译。","link":"/2021/06/20/NestJS/nest-devops/"},{"title":"Shell for循环语句","text":"Shell里的for循环语句写法。我们分别用命令行和shell脚本来进行演示。 常见的一种for结构如下。for里面要跟着do和done关键字。 1234for i in {1..3}do echo YES $i # 这里是循环体done 数字范围数字范围，例如从1到3，从1到100。 for infor in 的写法，定义i为变量，使用大括号来指定范围。范围的数字之间有2个点..。例如{1..3}1234$ for i in {1..3};do echo now is $i; donenow is 1now is 2now is 3上面是命令行，一行把所有的指令写完。也可以再加一行代码，同样用分号;来分隔。1234567$ for i in {1..3};do echo now is $i;echo rustfisher.com; donenow is 1rustfisher.comnow is 2rustfisher.comnow is 3rustfisher.com 或者写成脚本。其实就是拆成几行。1234567#!/bin/bash for i in {1..3}do echo now is $i echo rustfisher.comdone 前面我们用的是大括号来指定循环范围。我们也可以用$(seq 1 3)。开头依旧是for i in1234567$ for i in $(seq 1 3);do echo now is $i;echo rustfisher.com; donenow is 1rustfisher.comnow is 2rustfisher.comnow is 3rustfisher.com 写成脚本如下1234567#!/bin/bash for i in $(seq 1 3)do echo now is $i echo rustfisher.comdone 实际上我们使用了seq命令。seq后面接2个数字，可以输出这个范围内的数字。123456789101112$ seq 1 512345~ $ seq 5 154321 for((i=1;i&lt;=3;i++))我们也可以写成像Java/C语言里的for循环那样。但要注意这里的for有2层小括号。1234$ for((i=1;i&lt;=3;i++));do echo -n now is [$i] ;echo rustfisher.com; donenow is [1]rustfisher.comnow is [2]rustfisher.comnow is [3]rustfisher.com 更改一下步进值，改为i+=2123for((i=1;i&lt;=3;i+=2));do echo -n now is [$i] ;echo rustfisher.com; donenow is [1]rustfisher.comnow is [3]rustfisher.com 或者加上一些小运算，用expr加上我们想要的运算。注意$i与\\*和3之间要有空格。123$ for((i=1;i&lt;=3;i+=2));do echo -n $(expr $i \\* 3) ' ' ;echo rustfisher.com; done3 rustfisher.com9 rustfisher.com后面加的空格是为了隔开好看一些。 在shell脚本中，我们有时候会定义变量。变量也可以作为for循环的范围。123456789#!/bin/bash startNum=1endNum=3for i in $(seq $startNum $endNum)do echo current is $idone我们定义2个变量startNum与endNum。要使用它们的值时，需要加上$符号。 字符循环for循环可以与一些指令结合起来，获取指令中的结果。 for i in ls先用命令行看一个效果，for与ls结合使用12$ for i in `ls`; do echo $i ; donefor1.sh当前目录里只有1个文件。 如果是ls -a命令，输出会更多。1234$ for i in `ls -a`; do echo $i ; done...for1.sh 换一个目录，我们可以输出所有png文件的文件名123456789$ for i in `ls *.png`; do echo $i ; doneandroid-cover-2.pngfish.pngic_book_blue.pngic_tools_gear.pngic_web.pngkotlin-android-1.pngpython-logo.pngts-blue-1.png for i in ll换成ll命令，输出更加丰富123456789101112$ for i in `ll`; do echo $i ; donetotal8-rw-r--r--1rustfisherstaff18361921:25for1.sh 我们知道ll命令会输出当前目录下的文件信息123$ lltotal 8-rw-r--r-- 1 rustfisher staff 183 6 19 21:25 for1.sh 结合for循环可以看出，for循环是获取了空格或换行为间隔的字符串。 显示各个子目录里md文件的个数1for i in `ls`; do echo $i; find $i -name &quot;*.md&quot; | wc -l; done 字符串变量那么我们可以在脚本中尝试一些，for循环配合字符串1234567#!/bin/bash word=&quot;Welcome to rustfisher.com&quot;for i in $worddo echo $idone word中间有很多个空格，但输出的依旧是这3行。123Welcometorustfisher.com 进一步扩展，定义3个变量，都作为for in的参数123456789#!/bin/bash word1=&quot;Welcome to rustfisher.com&quot;word2=&quot;Hello world&quot;word3=&quot;我很好&quot;for i in $word1 $word2 $word3do echo $idone 输出123456Welcometorustfisher.comHelloworld我很好 目录例如查找某个目录下的文件。 当前目录中有一个img目录，里面有一些图片。我们在for in 后面用img/*来表示查找这个目录中所有文件。123$ for i in img/*; do echo $i ; doneimg/android-2botsm.jpgimg/android-cover-2.png 如果只想看png文件，路径写为img/*.png。12$ for i in img/*.png; do echo $i ; doneimg/android-cover-2.png 从上面的例子可以看出，for in结构用的十分频繁。","link":"/2021/06/19/Linux/for-use/"},{"title":"Cocos Creator 拖动去指定区域","text":"我们要实现的效果是，按住并拖动一个小物体，物体跟随手指（鼠标）移动。拖到指定位置放下。如果没有到指定位置，则回到上一个位置。 新建脚本DragToTarget.ts，挂到预制体上。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const { ccclass, property } = cc._decorator;@ccclassexport default class DragToTarget extends cc.Component { @property(cc.Label) nameLabel: cc.Label = null; @property(cc.Node) targetOfDragList: cc.Node[] = []; _oldPos = null; // 上一个位置 start() { this._oldPos = this.node.position; } onEnable() { this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this); this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this); } onDisable() { this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this); this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this); } // update (dt) {} _onTouchMove(touchEvent) { let location = touchEvent.getLocation(); this.node.position = this.node.parent.convertToNodeSpaceAR(location); // 确定位置 } _onTouchEnd(touchEvent) { if (this.targetOfDragList.length === 0) { return; // 没有目标位置 } let inTarget = false; for (const targetNode of this.targetOfDragList) { if (this._withinTarget(targetNode, touchEvent)) { inTarget = true; break; } } if (!inTarget) { this.node.position = this._oldPos; // 回去 } } // 判断触摸事件是否在槽位里 _withinTarget(targetNode: cc.Node, touchEvent) { let rect = targetNode.getBoundingBox(); let location = touchEvent.getLocation(); let point = targetNode.parent.convertToNodeSpaceAR(location); return rect.contains(point); }}思路与之前的拖动类似。在最后TOUCH_END的时候，判断自己是否在目标区域内。如果不在则返回上一个坐标。 在场景中使用1234567891011121314151617181920212223242526272829import DragToTarget from &quot;./DragToTarget&quot;;const { ccclass, property } = cc._decorator;@ccclassexport default class DragToControl extends cc.Component { @property(cc.Prefab) drag_to_item: cc.Prefab = null; @property(cc.Node) dragTargets: cc.Node[] = []; itemNum = 1; start() { this.createItem(); } // update (dt) {} createItem() { let d = cc.instantiate(this.drag_to_item); this.node.addChild(d); let dragTo = d.getComponent(DragToTarget); dragTo.targetOfDragList = this.dragTargets; // 设置目的地 dragTo.nameLabel.string = '' + this.itemNum++; }}","link":"/2020/12/30/CocosCreator/ccc-drag-to-target/"},{"title":"Cocos Creator 坐标与转换","text":"ccc的坐标系 ccc提供了api，在世界坐标和本地坐标之间可以相互转换。 12345let postion = node.position; // postion是在父节点中的坐标cc.log(name, 'position (', postion.x.toFixed(2), ',', postion.y.toFixed(2), ')');let worldPos = node.parent.convertToWorldSpaceAR(node.position); // 世界坐标cc.log(name, '世界坐标(', worldPos.x.toFixed(2), ',', worldPos.y.toFixed(2), ')'); node.position是本地坐标，也就是在父节点中的坐标。让父节点调用convertToWorldSpaceAR方法，把节点的本地坐标转换为世界坐标。 p是本地坐标 w是世界坐标 代码参考CCCTry","link":"/2020/12/29/CocosCreator/ccc-postion-and-cvt/"},{"title":"Cocos Creator 拖动效果","text":"我们要实现的效果是，按住并拖动一个小物体，物体跟随手指（鼠标）移动。 代码DragToAnywhere.ts12345678910111213141516171819202122232425262728293031@ccclassexport default class DragToAnywhere extends cc.Component { @property(cc.Label) label: cc.Label = null; start () { } onEnable() { this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this); this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this); } onDisable() { this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this); this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this); } // update (dt) {} _onTouchMove(touchEvent) { let location = touchEvent.getLocation(); this.node.position = this.node.parent.convertToNodeSpaceAR(location); // 确定位置 } _onTouchEnd(touchEvent) { // 放下 }} 把DragToAnywhere.ts挂在预制体上。在场景中创建预制体对象。12345let node1 = cc.instantiate(this.drag_item);this.node.addChild(node1);node1.x = 100;node1.y = 100;node1.getComponent(DragToAnywhere).label.string = '水星';","link":"/2020/12/28/CocosCreator/ccc-drag-anywhere/"},{"title":"TypeScript 单例模式","text":"ts中的单例模式 构造器设置为私有的 建立static方法，获取唯一的对象 1234567891011121314export default class DataMgr { private static mgr: DataMgr; private constructor() { // 构造器 } public static getMgr(): DataMgr { if (this.mgr == null) { this.mgr = new DataMgr(); } return this.mgr; }} 写法上与Java的单例模式类似","link":"/2020/12/27/Ts/ts-singleton-pattern/"},{"title":"Cocos Creator 触摸事件穿透","text":"触摸事件假设给整个Canvas添加了事件监听。用网页模拟时，鼠标移动，点击子node都会监听到。12345678910111213141516171819202122start() { this._cfgTouchField();}_onTouchFieldDown(e) { cc.log('table', '_onTouchFieldDown');}_onTouchFieldMove(e) { cc.log('table', '_onTouchFieldMove');}_onTouchFieldEnd(e) { cc.log('table', '_onTouchFieldEnd');}_cfgTouchField() { this.node.on(cc.Node.EventType.MOUSE_DOWN, this._onTouchFieldDown, this); this.node.on(cc.Node.EventType.MOUSE_MOVE, this._onTouchFieldMove, this); this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onTouchFieldEnd, this); this.node.on(cc.Node.EventType.MOUSE_UP, this._onTouchFieldEnd, this);} 网页模拟，鼠标从空白地方移入Toggle的范围时，会触发一次cc.Node.EventType.MOUSE_LEAVE；然后又是cc.Node.EventType.MOUSE_MOVE","link":"/2020/12/26/CocosCreator/ccc-touch-event/"},{"title":"Kotlin快速上手","text":"快速介绍Kotlin的用法。有些地方会和Java进行类比。 变量声明Kotlin 使用两个不同的关键字（即 val 和 var）来声明变量。 val 用于值从不更改的变量。您不能为使用 val 声明的变量重新赋值。var 用于值可以更改的变量。在以下示例中，count 是一个 Int 类型的变量，为其赋予的初始值为 10： 1var count: Int = 10 Java中我们会写成int count = 10;，类型写在前面，结尾需要分号。 Int 是一种表示整数的类型，它是可以在 Kotlin 中表示的众多数值类型之一。与其他语言类似，您也可以使用 Byte、Short、Long、Float 和 Double，具体取决于您的数值数据。 var 关键字表示您可以根据需要为 count 重新赋值。例如，您可以将 count 的值从 10 更改为 15：12var count: Int = 10 count = 15 不过，有些值不应更改。假设有一个名为 languageName 的 String。如果您要确保 languageName 的值始终为“Kotlin”，则可以使用 val 关键字来声明 languageName： 1val languageName: String = &quot;Kotlin&quot; 通过这些关键字，您可以明确指出哪些变量的值可以更改。您可以根据需要加以利用。如果变量引用必须可重新赋值，则将其声明为 var。否则，请使用 val。 类型推断接着前面的示例来讲，当您为 languageName 赋予初始值时，Kotlin 编译器可根据所赋值的类型来推断类型。 由于 “Kotlin” 的值的类型为 String，因此编译器推断 languageName 也为 String。请注意，Kotlin 是一种静态类型的语言。这意味着，类型在编译时解析且从不改变。 在以下示例中，languageName 推断为 String，因此您无法对其调用任何不属于 String 类的函数：12345val languageName = &quot;Kotlin&quot; val upperCaseName = languageName.toUpperCase() // Fails to compile languageName.inc() toUpperCase() 是一个只能对 String 类型的变量调用的函数。由于 Kotlin 编译器已将 languageName 推断为 String，因此您可以安全地调用 toUpperCase()。不过，inc() 是一个 Int 运算符函数，因此无法对 String 调用它。利用 Kotlin 的类型推断，您既能确保代码简洁，又能确保类型安全。 Null 安全在某些语言中，可以声明引用类型变量而不明确提供初始值。在这些情况下，变量通常包含 null 值。默认情况下，Kotlin 变量不能持有 null 值。这意味着以下代码段无效： 12// Fails to compile val languageName: String = null 要使变量持有 null 值，它必须是可为 null 类型。您可以在变量类型后面加上 ? 后缀，将变量指定为可为 null，如以下示例所示：1val languageName: String? = null 指定 String? 类型后，您可以为 languageName 赋予 String 值或 null。 您必须小心处理可为 null 的变量，否则可能会出现可怕的 NullPointerException。例如，在 Java 中，如果您尝试对 null 值调用方法，您的程序会发生崩溃。 条件语句Kotlin 提供了几种用来实现条件逻辑的机制，其中最常见的是 if-else 语句。如果 if 关键字后面括在圆括号内的表达式求值为 true，则会执行该分支中的代码（即，紧跟在后面的括在大括号内的代码）。否则，会执行 else 分支中的代码。12345if (count == 42) { println(&quot;I have the answer.&quot;) } else { println(&quot;The answer eludes me.&quot;) } 您可以使用 else if 表示多个条件。这样，您就可以在单个条件语句中表示更精细且更复杂的逻辑，如以下示例所示：1234567if (count == 42) { println(&quot;I have the answer.&quot;) } else if (count &gt; 35) { println(&quot;The answer is close.&quot;) } else { println(&quot;The answer eludes me.&quot;) } 条件语句对于表示有状态的逻辑很有用，但您可能会发现，编写这些语句时会重复。在上面的示例中，就是在每个分支中输出一个 String。为了避免这种重复，Kotlin 提供了条件表达式。最后一个示例可以重新编写如下：123456789val answerString: String = if (count == 42) { &quot;I have the answer.&quot; } else if (count &gt; 35) { &quot;The answer is close.&quot; } else { &quot;The answer eludes me.&quot; } println(answerString) 每个条件分支都隐式地返回其最后一行上的表达式的结果，因此您无需使用 return 关键字。由于全部三个分支的结果都是 String 类型，因此 if-else 表达式的结果也是 String 类型。在本例中，根据 if-else 表达式的结果为 answerString 赋予了一个初始值。可以利用类型推断来省略 answerString 的显式类型声明，但为了清楚起见，通常最好添加该声明。 注意：Kotlin 不包含传统的三元运算符，而是倾向于使用条件表达式。 随着条件语句的复杂性不断增加，您可以考虑将 if-else 表达式替换为 when 表达式，如以下示例所示：1234567val answerString = when { count == 42 -&gt; &quot;I have the answer.&quot; count &gt; 35 -&gt; &quot;The answer is close.&quot; else -&gt; &quot;The answer eludes me.&quot; } println(answerString) when 表达式中的每个分支都由一个条件、一个箭头 (-&gt;) 和一个结果来表示。如果箭头左侧的条件求值为 true，则会返回右侧的表达式结果。请注意，执行并不是从一个分支跳转到下一个分支。when 表达式示例中的代码在功能上与上一个示例中的代码等效，但可以说更易读。 Kotlin 的条件语句彰显了它的一项更强大的功能，即智能类型转换。您不必使用安全调用运算符或非 null 断言运算符来处理可为 null 的值，而是可以使用条件语句来检查变量是否包含对 null 值的引用，如以下示例所示：12345val languageName: String? = null if (languageName != null) { // No need to write languageName?.toUpperCase() println(languageName.toUpperCase()) }如果代码中已经进行null检查，就不用写languageName?里的问号了。 在条件分支中，languageName 可能会被视为不可为 null。Kotlin 非常智能，能够明白执行分支的条件是 languageName 不持有 null 值，因此您不必在该分支中将 languageName 视为可为 null。 函数您可以将一个或多个表达式归入一个函数。您可以将相应的表达式封装在一个函数中并调用该函数，而不必在每次需要某个结果时都重复同一系列的表达式。 要声明函数，请使用 fun 关键字，后跟函数名称。接下来，定义函数接受的输入类型（如果有），并声明它返回的输出类型。函数的主体用于定义在调用函数时调用的表达式。 以前面的示例为基础，下面给出了一个完整的 Kotlin 函数：12345678fun generateAnswerString(): String { val answerString = if (count == 42) { &quot;I have the answer.&quot; } else { &quot;The answer eludes me&quot; } return answerString } 上面示例中的函数名为 generateAnswerString。它不接受任何输入。它会输出 String 类型的结果。要调用函数，请使用函数名称，后跟调用运算符 (())。在下面的示例中，使用 generateAnswerString() 的结果对 answerString 变量进行了初始化。1val answerString = generateAnswerString() 函数可以接受参数输入，如以下示例所示：123456789fun generateAnswerString(countThreshold: Int): String { val answerString = if (count &gt; countThreshold) { &quot;I have the answer.&quot; } else { &quot;The answer eludes me.&quot; } return answerString } 在声明函数时，您可以指定任意数量的参数及其类型。在上面的示例中，generateAnswerString() 接受一个名为 countThreshold 且类型为 Int 的参数。在函数中，您可以使用参数的名称来引用参数。 调用此函数时，您必须在函数调用的圆括号内添加一个参数：1val answerString = generateAnswerString(42) 简化函数声明generateAnswerString() 是一个相当简单的函数。该函数声明一个变量，然后立即返回结果。从函数返回单个表达式的结果时，您可以通过直接返回函数中包含的 if-else 表达式的结果来跳过声明局部变量，如以下示例所示：1234567fun generateAnswerString(countThreshold: Int): String { return if (count &gt; countThreshold) { &quot;I have the answer.&quot; } else { &quot;The answer eludes me.&quot; } } 您还可以将 return 关键字替换为赋值运算符：12345fun generateAnswerString(countThreshold: Int): String = if (count &gt; countThreshold) { &quot;I have the answer&quot; } else { &quot;The answer eludes me&quot; } 匿名函数并非每个函数都需要一个名称。某些函数由其输入和输出更直接地进行标识。这些函数称为“匿名函数”。您可以保留对某个匿名函数的引用，以便日后使用此引用来调用该匿名函数。与其他引用类型一样，您也可以在应用中传递引用。123val stringLengthFunc: (String) -&gt; Int = { input -&gt; input.length }小括号里表示传入的类型，-&gt;右边是返回类型。input代表输入的变量。 与命名函数一样，匿名函数也可以包含任意数量的表达式。函数的返回值是最终表达式的结果。 在上面的示例中，stringLengthFunc 包含对一个匿名函数的引用，该函数将 String 当作输入，并将输入 String 的长度作为 Int 类型的输出返回。因此，该函数的类型表示为 (String) -&gt; Int。不过，此代码不会调用该函数。要检索该函数的结果，您必须像调用命名函数一样调用该函数。调用 stringLengthFunc 时，您必须提供 String，如以下示例所示：12345val stringLengthFunc: (String) -&gt; Int = { input -&gt; input.length }val stringLength: Int = stringLengthFunc(&quot;Android&quot;) 高阶函数一个函数可以将另一个函数当作参数。将其他函数用作参数的函数称为“高阶函数”。此模式对组件之间的通信（其方式与在 Java 中使用回调接口相同）很有用。 下面是一个高阶函数的示例：1234fun stringMapper(str: String, mapper: (String) -&gt; Int): Int { // Invoke function return mapper(str) }stringMapper() 函数接受一个 String 以及一个函数，该函数根据您传递给它的 String 来推导 Int 值。 要调用 stringMapper()，您可以传递一个 String 和一个满足其他输入参数的函数（即，将 String 当作输入并输出 Int 的函数），如以下示例所示：123stringMapper(&quot;Android&quot;, { input -&gt; input.length }) 如果匿名函数是在某个函数上定义的最后一个参数，则您可以在用于调用该函数的圆括号之外传递它，如以下示例所示：123stringMapper(&quot;Android&quot;) { input -&gt; input.length } 您可以在整个 Kotlin 标准库中找到匿名函数。 Java中可能要定义接口来实现类似功能。Kotlin中需要的是满足要求的方法即可。 示例，在viewModel中定义如下3个函数123456789101112val stringLengthFunc: (String) -&gt; Int = { inputStr -&gt; inputStr.length}val stringLengthDouble: (String) -&gt; Int = { inputStr -&gt; inputStr.length * 2}fun stringMapper(str: String, mapper: (String) -&gt; Int): Int { // 调用传入的方法 return mapper(str)}使用函数123val inputStr = &quot;Rust Fisher&quot;var res1: Int = viewModel.stringMapper(inputStr, viewModel.stringLengthFunc)var res2: Int = viewModel.stringMapper(inputStr, viewModel.stringLengthDouble) 类到目前为止提到的所有类型都内置在 Kotlin 编程语言中。如果您想要添加自己的自定义类型，可以使用 class 关键字来定义类，如以下示例所示：1class Car 像前面的例子1234567891011121314151617import androidx.lifecycle.ViewModelclass KotlinGuideViewModel : ViewModel() { val stringLengthFunc: (String) -&gt; Int = { inputStr -&gt; inputStr.length } val stringLengthDouble: (String) -&gt; Int = { inputStr -&gt; inputStr.length * 2 } fun stringMapper(str: String, mapper: (String) -&gt; Int): Int { // 调用传入的方法 return mapper(str) }} 属性类使用属性来表示状态。属性是类级变量，可以包含 getter、setter 和后备字段。由于汽车需要轮子来驱动，因此您可以添加 Wheel 对象的列表作为 Car 的属性，如以下示例所示：123class Car { val wheels = listOf&lt;Wheel&gt;() }请注意，wheels 是一个 public val，这意味着，可以从 Car 类外部访问 wheels，并且不能为其重新赋值。如果要获取 Car 的实例，您必须先调用其构造函数。这样一来，您便可以访问它的任何可访问属性。12val car = Car() // construct a Car val wheels = car.wheels // retrieve the wheels value from the Car 如果要自定义轮子，您可以定义一个自定义构造函数，用来指定如何初始化类属性：1class Car(val wheels: List&lt;Wheel&gt;) 在上面的示例中，类构造函数将 List 当作构造函数参数，并使用该参数来初始化其 wheels 属性。 类函数和封装类使用函数对行为建模。函数可以修改状态，从而帮助您只公开希望公开的数据。这种访问控制机制属于一个更大的面向对象的概念（称为“封装”）。 在以下示例中，doorLock 属性对 Car 类外部的一切都不公开。要解锁汽车，您必须调用 unlockDoor() 函数并传入有效的“钥匙”，如以下示例所示：12345678class Car(val wheels: List&lt;Wheel&gt;) { private val doorLock: DoorLock = ... fun unlockDoor(key: Key): Boolean { // Return true if key is valid for door lock, false otherwise } } 如果您想要自定义属性的引用方式，则可以提供自定义的 getter 和 setter。例如，如果您想要公开属性的 getter 而限制访问其 setter，则可以将该 setter 指定为 private：1234567891011class Car(val wheels: List&lt;Wheel&gt;) { private val doorLock: DoorLock = ... val gallonsOfFuelInTank: Int = 15 private set fun unlockDoor(key: Key): Boolean { // Return true if key is valid for door lock, false otherwise } } 通过结合使用属性和函数，您可以创建能够对所有类型的对象建模的类。 互操作性Kotlin 最重要的功能之一就是它与 Java 之间流畅的互操作性。由于 Kotlin 代码可编译为 JVM 字节码，因此 Kotlin 代码可直接调用 Java 代码，反之亦然。这意味着，您可以直接从 Kotlin 利用现有的 Java 库。此外，绝大多数 Android API 都是用 Java 编写的，您可以直接从 Kotlin 调用它们。","link":"/2020/04/10/Kotlin/kotlin-breif-intro/"},{"title":"微信小程序 居中布局css","text":"居中放置元素是一个比较常见的需求。可以水平居中，垂直居中。同时水平和垂直居中等等。在Android的RelativeLayout中，可以使用android:layout_centerInParent=&quot;true&quot;。在小程序中我们该怎么做呢？ 居中示例下面列举几个居中的例子。 水平居中wxml中放置一个view。123&lt;view class=&quot;flex-center-in-row&quot;&gt; Rust Fisher 水平方向居中&lt;/view&gt; wxss中的class。使用了flex布局，设置justify-content: center;。1234567.flex-center-in-row { background: #eaeaea; display: flex; flex-direction: row; justify-content: center; height: 40px;} 垂直居中垂直方向居中。123&lt;view class=&quot;flex-center-in-column&quot;&gt; Rust Fisher 垂直方向居中&lt;/view&gt; 确定它的高度，设置display: flex; align-items: center;。12345.flex-center-in-column { display: flex; align-items: center; height: 60px;} 水平并且垂直居中要居中，需要确定宽和高。123&lt;view class=&quot;flex-center-in-cube&quot;&gt; Rust Fisher 方块内居中&lt;/view&gt; 需要设置flex布局，justify-content: center; align-items: center;。1234567.flex-center-in-cube { width: 100%; height: 60px; display: flex; justify-content: center; align-items: center;} 小结从上面的几个例子我们可以看出，它们都用了flex布局。垂直居中需要设置align-items: center;；水平居中需要设置justify-content: center;。 工程放在： https://github.com/AnRFDev/tutorial-miniprogram 更多阅读: 小程序开发记录","link":"/2020/02/03/Miniprogram/wx-mini-css_center_tutorial/"},{"title":"Android SurfaceView TextureView 预览Camera，获取NV21数据","text":"win7 Android Studio 3.0.1 本文目的：使用 Camera API 进行视频的采集，分别使用 SurfaceView、TextureView 来预览 Camera 数据，取到 NV21 的数据回调 准备使用相机权限1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;camera预览回调中默认使用NV21格式。 检查手机是否支持摄像头。 UI准备12345&lt;!-- 全屏显示 --&gt;&lt;style name=&quot;FullScreenTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;&lt;/style&gt;承载预览图像1234&lt;FrameLayout android:id=&quot;@+id/camera_preview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 使用 SurfaceView 预览 Camera，取到NV21数据自定义CameraPreview继承SurfaceView，实现SurfaceHolder.Callback接口 获取NV21数据，Camera.setPreviewCallback() 要放在 Camera.startPreview() 之前。使用Camera.PreviewCallback获取预览数据回调。默认是NV21格式。 surfaceChanged中，camera启动预览前可以进行设置，例如设置尺寸，调整方向123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * camera预览视图 * Created by Rust on 2018/2/26. */public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback { private static final String TAG = &quot;rustApp&quot;; private SurfaceHolder mHolder; private Camera mCamera; private int mFrameCount = 0; public CameraPreview(Context context) { super(context); } public CameraPreview(Context context, Camera camera) { super(context); mCamera = camera; mHolder = getHolder(); mHolder.addCallback(this); mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); } public void setCamera(Camera c) { this.mCamera = c; } @Override public void surfaceCreated(SurfaceHolder holder) { // 开启预览 try { mCamera.setPreviewDisplay(holder); mCamera.startPreview(); } catch (IOException e) { Log.d(TAG, &quot;Error setting camera preview: &quot; + e.getMessage()); } } @Override public void surfaceDestroyed(SurfaceHolder holder) { // 可在此释放camera } @Override public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) { // 若需要旋转、更改大小或重新设置，请确保证已停止预览 if (mHolder.getSurface() == null) { return; } try { mCamera.stopPreview(); } catch (Exception e) { // ignore: tried to stop a non-existent preview } Camera.Parameters parameters = mCamera.getParameters(); // ImageFormat.NV21 == 17 Log.d(TAG, &quot;parameters.getPreviewFormat(): &quot; + parameters.getPreviewFormat()); if (this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE) { mCamera.setDisplayOrientation(90); } else { mCamera.setDisplayOrientation(0); } try { mCamera.setPreviewDisplay(mHolder); mCamera.setPreviewCallback(mCameraPreviewCallback); // 回调要放在 startPreview() 之前 mCamera.startPreview(); } catch (Exception e) { Log.d(TAG, &quot;Error starting camera preview: &quot; + e.getMessage()); } } private Camera.PreviewCallback mCameraPreviewCallback = new Camera.PreviewCallback() { @Override public void onPreviewFrame(byte[] data, Camera camera) { mFrameCount++; Log.d(TAG, &quot;onPreviewFrame: data.length=&quot; + data.length + &quot;, frameCount=&quot; + mFrameCount); } };} 为了防止阻塞UI线程，在子线程中打开camera。camera常放在try catch中使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;rustApp&quot;; private Camera mCamera; private CameraPreview mPreview; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new InitCameraThread().start(); } @Override protected void onResume() { if (null == mCamera) { if (safeCameraOpen()) { mPreview.setCamera(mCamera); // 重新获取camera操作权 } else { Log.e(TAG, &quot;无法操作camera&quot;); } } super.onResume(); } @Override protected void onPause() { super.onPause(); releaseCamera(); } private boolean safeCameraOpen() { boolean qOpened = false; try { releaseCamera(); mCamera = Camera.open(); qOpened = (mCamera != null); } catch (Exception e) { Log.e(TAG, &quot;failed to open Camera&quot;); e.printStackTrace(); } return qOpened; } private void releaseCamera() { if (mCamera != null) { mCamera.setPreviewCallback(null); mCamera.release(); // release the camera for other applications mCamera = null; } } private class InitCameraThread extends Thread { @Override public void run() { super.run(); if (safeCameraOpen()) { Log.d(TAG, &quot;开启摄像头&quot;); runOnUiThread(new Runnable() { @Override public void run() { mPreview = new CameraPreview(MainActivity.this, mCamera); FrameLayout preview = findViewById(R.id.camera_preview); preview.addView(mPreview); } }); } } }} 使用 TextureView 预览 Camera，取到NV21数据TextureView可用于显示内容流。内容流可以是视频或者OpenGL的场景。内容流可来自应用进程或是远程其它进程。 Textureview必须在硬件加速开启的窗口中使用。若是软解，TextureView不会显示东西。 不同于SurfaceView，TextureView不会建立一个单独的窗口，而是像一个常规的View一样（个人认为这是个优点）。这使得TextureView可以被移动，转换或是添加动画。比如，可以调用myView.setAlpha(0.5f)将其设置成半透明。 使用TextureView很简单：获取到它的SurfaceTexture，使用SurfaceTexture呈现内容。 CameraPreview继承了TextureView，外部需要传入camera实例。在onSurfaceTextureAvailable中，配置camera，比如设置图像方向。通过设置Camera.PreviewCallback来取得预览数据。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.IOException;import android.content.Context;import android.content.res.Configuration;import android.graphics.SurfaceTexture;import android.hardware.Camera;import android.util.Log;import android.view.TextureView;public class CameraPreview extends TextureView implements TextureView.SurfaceTextureListener { private static final String TAG = &quot;rustApp&quot;; private Camera mCamera; public CameraPreview(Context context) { super(context); } public CameraPreview(Context context, Camera camera) { super(context); mCamera = camera; } public void setCamera(Camera camera) { this.mCamera = camera; } @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) { Log.d(TAG, &quot;TextureView onSurfaceTextureAvailable&quot;); if (this.getResources().getConfiguration().orientation != Configuration.ORIENTATION_LANDSCAPE) { mCamera.setDisplayOrientation(90); } else { mCamera.setDisplayOrientation(0); } try { mCamera.setPreviewCallback(mCameraPreviewCallback); mCamera.setPreviewTexture(surface); // 使用SurfaceTexture mCamera.startPreview(); } catch (IOException ioe) { // Something bad happened } } @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) { Log.d(TAG, &quot;TextureView onSurfaceTextureSizeChanged&quot;); // Ignored, Camera does all the work for us } @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) { Log.d(TAG, &quot;TextureView onSurfaceTextureDestroyed&quot;); mCamera.stopPreview(); mCamera.release(); return true; } @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) { // Invoked every time there's a new Camera preview frame } private Camera.PreviewCallback mCameraPreviewCallback = new Camera.PreviewCallback() { @Override public void onPreviewFrame(byte[] data, Camera camera) { Log.d(TAG, &quot;onPreviewFrame: data.length=&quot; + data.length); } };} 操作界面TextureAct。获取camera操作权，初始化CameraPreview并添加到布局中。第一次获取camera时在子线程中操作。 在onPause中释放camera，onResume中尝试取回camera控制权。这样应用暂时退回后台时，其他应用可以操作摄像头。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class TextureAct extends AppCompatActivity { private static final String TAG = &quot;rustApp&quot;; private Camera mCamera; private CameraPreview mPreview; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_texture); new InitCameraThread().start(); } @Override protected void onResume() { if (null == mCamera) { if (safeCameraOpen()) { mPreview.setCamera(mCamera); // 重新获取camera操作权 } else { Log.e(TAG, &quot;无法操作camera&quot;); } } super.onResume(); } @Override protected void onPause() { super.onPause(); releaseCamera(); } @Override protected void onDestroy() { super.onDestroy(); releaseCamera(); } private boolean safeCameraOpen() { boolean qOpened = false; try { releaseCamera(); mCamera = Camera.open(); qOpened = (mCamera != null); } catch (Exception e) { Log.e(TAG, &quot;failed to open Camera&quot;); e.printStackTrace(); } return qOpened; } private void releaseCamera() { if (mCamera != null) { mCamera.setPreviewCallback(null); mCamera.release(); // release the camera for other applications mCamera = null; } } private class InitCameraThread extends Thread { @Override public void run() { super.run(); if (safeCameraOpen()) { Log.d(TAG, &quot;TextureAct 开启摄像头&quot;); runOnUiThread(new Runnable() { @Override public void run() { mPreview = new CameraPreview(TextureAct.this, mCamera); mPreview.setSurfaceTextureListener(mPreview); FrameLayout preview = findViewById(R.id.camera_preview); preview.addView(mPreview); } }); } } }}Textureview必须在硬件加速开启的窗口中使用。android:hardwareAccelerated=&quot;true&quot; 默认的这个属性就是true，无需再设置。 每接到一帧数据，就会调用一次onSurfaceTextureUpdated()。通过这个接口。能够将上来的SurfaceTexture送给OpenGL再去处理。 参考资料 Controlling the Camera - Android Developer Camera API - Android Developer TextureView - Android Developer","link":"/2020/01/11/Android/Android-Camera_SurfaceView_TextureView_get_nv21/"},{"title":"Android Camera API 音视频采集、编码、封包成mp4","text":"win7 Android Studio 3.0.1 相关代码请参阅： https://github.com/RustFisher/android-CameraRecorder 概述本文目的：使用 Android Camera API 完成音视频的采集、编码、封包成 mp4 输出 基于android.hardware.Camera，创建一个横屏应用，实时预览摄像头图像，实现录像并输出MP4的功能。这里不使用Camera2。 申请权限123456&lt;!-- 需要录制音视频权限和写外部存储权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt; 在activity中动态申请权限12345private static final String[] VIDEO_PERMISSIONS = { Manifest.permission.CAMERA, Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_EXTERNAL_STORAGE}; 实现摄像头预览功能使用SurfaceView来预览。新建CameraPreview类继承自SurfaceView并实现SurfaceHolder.Callback；camera相关操作都放在这个View里。 surfaceCreated中获取Camera实例，启动预览；设置预览相关参数 surfaceDestroyed释放Camera 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback { private static final String TAG = &quot;rustAppCameraPreview&quot;; private SurfaceHolder mHolder; private Camera mCamera; public static final int MEDIA_TYPE_IMAGE = 1; public static final int MEDIA_TYPE_VIDEO = 2; private static int mOptVideoWidth = 1920; // 默认视频帧宽度 private static int mOptVideoHeight = 1080; private Uri outputMediaFileUri; private String outputMediaFileType; public CameraPreview(Context context) { super(context); mHolder = getHolder(); mHolder.addCallback(this); } private static Camera getCameraInstance() { Camera c = null; try { c = Camera.open(); } catch (Exception e) { Log.d(TAG, &quot;camera is not available&quot;); } return c; } @Override public void surfaceCreated(SurfaceHolder holder) { mCamera = getCameraInstance(); try { mCamera.setPreviewDisplay(holder); mCamera.startPreview(); getCameraOptimalVideoSize(); // 找到最合适的分辨率 } catch (IOException e) { Log.d(TAG, &quot;Error setting camera preview: &quot; + e.getMessage()); } } private void getCameraOptimalVideoSize() { try { Camera.Parameters parameters = mCamera.getParameters(); List&lt;Camera.Size&gt; mSupportedPreviewSizes = parameters.getSupportedPreviewSizes(); List&lt;Camera.Size&gt; mSupportedVideoSizes = parameters.getSupportedVideoSizes(); Camera.Size optimalSize = CameraHelper.getOptimalVideoSize(mSupportedVideoSizes, mSupportedPreviewSizes, getWidth(), getHeight()); mOptVideoWidth = optimalSize.width; mOptVideoHeight = optimalSize.height; Log.d(TAG, &quot;prepareVideoRecorder: optimalSize:&quot; + mOptVideoWidth + &quot;, &quot; + mOptVideoHeight); } catch (Exception e) { Log.e(TAG, &quot;getCameraOptimalVideoSize: &quot;, e); } } @Override public void surfaceDestroyed(SurfaceHolder holder) { mHolder.removeCallback(this); mCamera.setPreviewCallback(null); mCamera.stopPreview(); mCamera.release(); mCamera = null; } @Override public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) { }} 在Fragment中显示摄像头预览预置一个FrameLayout，实例化一个CameraPreview添加进去123456789101112131415161718192021222324252627282930313233343536373839/** * 视频录制界面 * Created by Rust on 2018/5/17. */public class VideoRecordFragment extends Fragment { private static final String TAG = &quot;rustAppVideoFrag&quot;; private Button mCaptureBtn; private CameraPreview mCameraPreview; public static VideoRecordFragment newInstance() { return new VideoRecordFragment(); } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(TAG, &quot;frag onCreate&quot;); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { Log.d(TAG, &quot;frag onCreateView&quot;); return inflater.inflate(R.layout.frag_video_record, container, false); } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { Log.d(TAG, &quot;frag onViewCreated&quot;); super.onViewCreated(view, savedInstanceState); mCaptureBtn = view.findViewById(R.id.capture_btn); //mCaptureBtn.setOnClickListener(mOnClickListener);// 录制键 mCameraPreview = new CameraPreview(getContext()); FrameLayout preview = view.findViewById(R.id.camera_preview); preview.addView(mCameraPreview); }} 使用MediaRecorder录制给MediaRecorder指定参数后，调用start()开始录制，stop()结束录制 录制开始前，获取camera，mCamera.unlock()解锁；录制完毕后，清除MediaRecorder，mCamera.lock() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private MediaRecorder mMediaRecorder; public boolean startRecording() { if (prepareVideoRecorder()) { mMediaRecorder.start(); return true; } else { releaseMediaRecorder(); } return false; } public void stopRecording() { if (mMediaRecorder != null) { mMediaRecorder.stop(); } releaseMediaRecorder(); } public boolean isRecording() { return mMediaRecorder != null; } private boolean prepareVideoRecorder() { if (null == mCamera) { mCamera = getCameraInstance(); } mMediaRecorder = new MediaRecorder(); mCamera.unlock(); mMediaRecorder.setCamera(mCamera); mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH)); mMediaRecorder.setVideoSize(mOptVideoWidth, mOptVideoHeight); mMediaRecorder.setOutputFile(getOutputMediaFile(MEDIA_TYPE_VIDEO).toString()); mMediaRecorder.setPreviewDisplay(mHolder.getSurface()); try { mMediaRecorder.prepare(); } catch (IllegalStateException e) { Log.d(TAG, &quot;IllegalStateException preparing MediaRecorder: &quot; + e.getMessage()); releaseMediaRecorder(); return false; } catch (IOException e) { Log.d(TAG, &quot;IOException preparing MediaRecorder: &quot; + e.getMessage()); releaseMediaRecorder(); return false; } return true; } private void releaseMediaRecorder() { if (mMediaRecorder != null) { mMediaRecorder.reset(); mMediaRecorder.release(); mMediaRecorder = null; mCamera.lock(); } } private File getOutputMediaFile(int type) { File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), TAG); if (!mediaStorageDir.exists()) { if (!mediaStorageDir.mkdirs()) { Log.d(TAG, &quot;failed to create directory&quot;); return null; } } String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.CHINA).format(new Date()); File mediaFile; if (type == MEDIA_TYPE_IMAGE) { mediaFile = new File(mediaStorageDir.getPath() + File.separator + &quot;IMG_&quot; + timeStamp + &quot;.jpg&quot;); outputMediaFileType = &quot;image/*&quot;; } else if (type == MEDIA_TYPE_VIDEO) { mediaFile = new File(mediaStorageDir.getPath() + File.separator + &quot;VID_&quot; + timeStamp + &quot;.mp4&quot;); outputMediaFileType = &quot;video/*&quot;; } else { return null; } outputMediaFileUri = Uri.fromFile(mediaFile); return mediaFile; } 后台返回时预览黑屏的问题CameraPreview是我们在Fragment创建时实例化并添加进去的。应用退到后台后，CameraPreview已经被销毁。应用回到前台时，我们应该在onResume方法中进行操作。恢复CameraPreview。 在Fragment中，判断销毁和重建预览的时机。12345678910111213141516171819202122@Overridepublic void onPause() { super.onPause(); Log.d(TAG, &quot;onPause: 销毁预览&quot;); mCameraPreview = null;}@Overridepublic void onResume() { super.onResume(); Log.d(TAG, &quot;onResume: 回到前台&quot;); if (null == mCameraPreview) { initCameraPreview(); }}private void initCameraPreview() { mCameraPreview = new CameraPreview(getContext()); FrameLayout preview = mRoot.findViewById(R.id.camera_preview); preview.addView(mCameraPreview);} 参考资料 Android相机开发(三): 实现拍照录像和查看 googlesamples/android-MediaRecorder Controlling the Camera - Android Developer Camera API - Android Developer","link":"/2020/01/11/Android/Android-Camera_record_video_and_output/"},{"title":"Android 音频PCM数据的采集和播放，读写音频wav文件","text":"本文目的：使用 AudioRecord 和 AudioTrack 完成音频PCM数据的采集和播放，并读写音频wav文件 准备工作Android提供了AudioRecord和MediaRecord。MediaRecord可选择录音的格式。AudioRecord得到PCM编码格式的数据。AudioRecord能够设置模拟信号转化为数字信号的相关参数，包括采样率和量化深度，同时也包括通道数目等。 PCMPCM是在由模拟信号向数字信号转化的一种常用的编码格式，称为脉冲编码调制，PCM将模拟信号按照一定的间距划分为多段，然后通过二进制去量化每一个间距的强度。PCM表示的是音频文件中随着时间的流逝的一段音频的振幅。Android在WAV文件中支持PCM的音频数据。 WAVWAV，MP3等比较常见的音频格式，不同的编码格式对应不通过的原始音频。为了方便传输，通常会压缩原始音频。为了辨别出音频格式，每种格式有特定的头文件（header）。WAV以RIFF为标准。RIFF是一种资源交换档案标准。RIFF将文件存储在每一个标记块中。基本构成单位是trunk，每个trunk由标记位，数据大小，数据存储，三个部分构成。 PCM打包成WAVPCM是原始音频数据，WAV是windows中常见的音频格式，只是在pcm数据中添加了一个文件头。 起始地址 占用空间 本地址数字的含义 00H 4byte RIFF，资源交换文件标志。 04H 4byte 从下一个地址开始到文件尾的总字节数。高位字节在后面，这里就是001437ECH，换成十进制是1325036byte，算上这之前的8byte就正好1325044byte了。 08H 4byte WAVE，代表wav文件格式。 0CH 4byte FMT ，波形格式标志 10H 4byte 00000010H，16PCM，我的理解是用16bit的数据表示一个量化结果。 14H 2byte 为1时表示线性PCM编码，大于1时表示有压缩的编码。这里是0001H。 16H 2byte 1为单声道，2为双声道，这里是0001H。 18H 4byte 采样频率，这里是00002B11H，也就是11025Hz。 1CH 4byte Byte率=采样频率*音频通道数*每次采样得到的样本位数/8，00005622H，也就是22050Byte/s=11025*1*16/2 20H 2byte 块对齐=通道数每次采样得到的样本位数/8，0002H，也就是 `2 == 116/8` 22H 2byte 样本数据位数，0010H即16，一个量化样本占2byte。 24H 4byte data，一个标志而已。 28H 4byte Wav文件实际音频数据所占的大小，这里是001437C8H即1325000，再加上2CH就正好是1325044，整个文件的大小。 2CH 不定 量化数据 AudioRecordAudioRecord可实现从音频输入设备记录声音的功能。得到PCM格式的音频。读取音频的方法有read(byte[], int, int)， read(short[], int, int) 或 read(ByteBuffer, int)。可根据存储方式和需求选择使用这项方法。 需要权限&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; AudioRecord 构造函数public AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes) audioSource 音源设备，常用麦克风MediaRecorder.AudioSource.MIC samplerateInHz 采样频率，44100Hz是目前所有设备都支持的频率 channelConfig 音频通道，单声道还是立体声 audioFormat 该参数为量化深度，即为每次采样的位数 bufferSizeInBytes 可通过getMinBufferSize()方法确定，每次从硬件读取数据所需要的缓冲区的大小。 获取wav文件若要获得wav文件，需要在PCM基础上增加一个header。可以将PCM文件转换成wav，这里提供一种PCM与wav几乎同时生成的思路。 PCM与wav同时创建，给wav文件一个默认的header。录制线程启动后，同时写PCM与wav。录制完成时，重新生成header，利用RandomAccessFile修改wav文件的header。 AudioTrack使用AudioTrack播放音频。初始化AudioTrack时，要根据录制时的参数进行设定。 代码示例工具类WindEar实现音频PCM数据的采集和播放，与读写音频wav文件的功能。 AudioRecordThread 使用AudioRecord录制PCM文件，可选择同时生成wav文件 AudioTrackPlayThread 使用AudioTrack播放PCM或wav音频文件的线程 WindState 表示当前状态，例如是否在播放，录制等等 PCM文件的读写采用FileOutputStream和FileInputStream generateWavFileHeader方法可以生成wav文件的header 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384/** * 音频录制器 * 使用 AudioRecord 和 AudioTrack API 完成音频 PCM 数据的采集和播放，并实现读写音频 wav 文件 * 检查权限，检查麦克风的工作放在Activity中进行 * Created by Rust on 2018/2/24. */public class WindEar { private static final String TAG = &quot;rustApp&quot;; private static final String TMP_FOLDER_NAME = &quot;AnWindEar&quot;; private static final int RECORD_AUDIO_BUFFER_TIMES = 1; private static final int PLAY_AUDIO_BUFFER_TIMES = 1; private static final int AUDIO_FREQUENCY = 44100; private static final int RECORD_CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_STEREO; private static final int PLAY_CHANNEL_CONFIG = AudioFormat.CHANNEL_OUT_STEREO; private static final int AUDIO_ENCODING = AudioFormat.ENCODING_PCM_16BIT; private AudioRecordThread aRecordThread; // 录制线程 private volatile WindState state = WindState.IDLE; // 当前状态 private File tmpPCMFile = null; private File tmpWavFile = null; private OnState onStateListener; private Handler mainHandler = new Handler(Looper.getMainLooper()); /** * PCM缓存目录 */ private static String cachePCMFolder; /** * wav缓存目录 */ private static String wavFolderPath; private static WindEar instance = new WindEar(); private WindEar() { } public static WindEar getInstance() { if (null == instance) { instance = new WindEar(); } return instance; } public void setOnStateListener(OnState onStateListener) { this.onStateListener = onStateListener; } /** * 初始化目录 */ public static void init(Context context) { // 存储在App内或SD卡上// cachePCMFolder = context.getFilesDir().getAbsolutePath() + File.separator + TMP_FOLDER_NAME; cachePCMFolder = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + TMP_FOLDER_NAME; File folder = new File(cachePCMFolder); if (!folder.exists()) { boolean f = folder.mkdirs(); Log.d(TAG, String.format(Locale.CHINA, &quot;PCM目录:%s -&gt; %b&quot;, cachePCMFolder, f)); } else { for (File f : folder.listFiles()) { boolean d = f.delete(); Log.d(TAG, String.format(Locale.CHINA, &quot;删除PCM文件:%s %b&quot;, f.getName(), d)); } Log.d(TAG, String.format(Locale.CHINA, &quot;PCM目录:%s&quot;, cachePCMFolder)); } wavFolderPath = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + TMP_FOLDER_NAME;// wavFolderPath = context.getFilesDir().getAbsolutePath() + File.separator + TMP_FOLDER_NAME; File wavDir = new File(wavFolderPath); if (!wavDir.exists()) { boolean w = wavDir.mkdirs(); Log.d(TAG, String.format(Locale.CHINA, &quot;wav目录:%s -&gt; %b&quot;, wavFolderPath, w)); } else { Log.d(TAG, String.format(Locale.CHINA, &quot;wav目录:%s&quot;, wavFolderPath)); } } /** * 开始录制音频 */ public synchronized void startRecord(boolean createWav) { if (!state.equals(WindState.IDLE)) { Log.w(TAG, &quot;无法开始录制，当前状态为 &quot; + state); return; } try { tmpPCMFile = File.createTempFile(&quot;recording&quot;, &quot;.pcm&quot;, new File(cachePCMFolder)); if (createWav) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyMMdd_HHmmss&quot;, Locale.CHINA); tmpWavFile = new File(wavFolderPath + File.separator + &quot;r&quot; + sdf.format(new Date()) + &quot;.wav&quot;); } Log.d(TAG, &quot;tmp file &quot; + tmpPCMFile.getName()); } catch (IOException e) { e.printStackTrace(); } if (null != aRecordThread) { aRecordThread.interrupt(); aRecordThread = null; } aRecordThread = new AudioRecordThread(createWav); aRecordThread.start(); } public synchronized void stopRecord() { if (!state.equals(WindState.RECORDING)) { return; } state = WindState.STOP_RECORD; notifyState(state); } /** * 播放录制好的PCM文件 */ public synchronized void startPlayPCM() { if (!isIdle()) { return; } new AudioTrackPlayThread(tmpPCMFile).start(); } /** * 播放录制好的wav文件 */ public synchronized void startPlayWav() { if (!isIdle()) { return; } new AudioTrackPlayThread(tmpWavFile).start(); } public synchronized void stopPlay() { if (!state.equals(WindState.PLAYING)) { return; } state = WindState.STOP_PLAY; } public synchronized boolean isIdle() { return WindState.IDLE.equals(state); } /** * 音频录制线程 * 使用FileOutputStream来写文件 */ private class AudioRecordThread extends Thread { AudioRecord aRecord; int bufferSize = 10240; boolean createWav = false; AudioRecordThread(boolean createWav) { this.createWav = createWav; bufferSize = AudioRecord.getMinBufferSize(AUDIO_FREQUENCY, RECORD_CHANNEL_CONFIG, AUDIO_ENCODING) * RECORD_AUDIO_BUFFER_TIMES; Log.d(TAG, &quot;record buffer size = &quot; + bufferSize); aRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, AUDIO_FREQUENCY, RECORD_CHANNEL_CONFIG, AUDIO_ENCODING, bufferSize); } @Override public void run() { state = WindState.RECORDING; notifyState(state); Log.d(TAG, &quot;录制开始&quot;); try { // 这里选择FileOutputStream而不是DataOutputStream FileOutputStream pcmFos = new FileOutputStream(tmpPCMFile); FileOutputStream wavFos = new FileOutputStream(tmpWavFile); if (createWav) { writeWavFileHeader(wavFos, bufferSize, AUDIO_FREQUENCY, aRecord.getChannelCount()); } aRecord.startRecording(); byte[] byteBuffer = new byte[bufferSize]; while (state.equals(WindState.RECORDING) &amp;&amp; !isInterrupted()) { int end = aRecord.read(byteBuffer, 0, byteBuffer.length); pcmFos.write(byteBuffer, 0, end); pcmFos.flush(); if (createWav) { wavFos.write(byteBuffer, 0, end); wavFos.flush(); } } aRecord.stop(); // 录制结束 pcmFos.close(); wavFos.close(); if (createWav) { // 修改header RandomAccessFile wavRaf = new RandomAccessFile(tmpWavFile, &quot;rw&quot;); byte[] header = generateWavFileHeader(tmpPCMFile.length(), AUDIO_FREQUENCY, aRecord.getChannelCount()); Log.d(TAG, &quot;header: &quot; + getHexString(header)); wavRaf.seek(0); wavRaf.write(header); wavRaf.close(); Log.d(TAG, &quot;tmpWavFile.length: &quot; + tmpWavFile.length()); } Log.i(TAG, &quot;audio tmp PCM file len: &quot; + tmpPCMFile.length()); } catch (Exception e) { Log.e(TAG, &quot;AudioRecordThread:&quot;, e); notifyState(WindState.ERROR); } notifyState(state); state = WindState.IDLE; notifyState(state); Log.d(TAG, &quot;录制结束&quot;); } } private static String getHexString(byte[] bytes) { StringBuilder sb = new StringBuilder(); for (byte b : bytes) { sb.append(Integer.toHexString(b)).append(&quot;,&quot;); } return sb.toString(); } /** * AudioTrack播放音频线程 * 使用FileInputStream读取文件 */ private class AudioTrackPlayThread extends Thread { AudioTrack track; int bufferSize = 10240; File audioFile = null; AudioTrackPlayThread(File aFile) { setPriority(Thread.MAX_PRIORITY); audioFile = aFile; int bufferSize = AudioTrack.getMinBufferSize(AUDIO_FREQUENCY, PLAY_CHANNEL_CONFIG, AUDIO_ENCODING) * PLAY_AUDIO_BUFFER_TIMES; track = new AudioTrack(AudioManager.STREAM_MUSIC, AUDIO_FREQUENCY, PLAY_CHANNEL_CONFIG, AUDIO_ENCODING, bufferSize, AudioTrack.MODE_STREAM); } @Override public void run() { super.run(); state = WindState.PLAYING; notifyState(state); try { FileInputStream fis = new FileInputStream(audioFile); track.play(); byte[] aByteBuffer = new byte[bufferSize]; while (state.equals(WindState.PLAYING) &amp;&amp; fis.read(aByteBuffer) &gt;= 0) { track.write(aByteBuffer, 0, aByteBuffer.length); } track.stop(); track.release(); } catch (Exception e) { Log.e(TAG, &quot;AudioTrackPlayThread:&quot;, e); notifyState(WindState.ERROR); } state = WindState.STOP_PLAY; notifyState(state); state = WindState.IDLE; notifyState(state); } } private synchronized void notifyState(final WindState currentState) { if (null != onStateListener) { mainHandler.post(new Runnable() { @Override public void run() { onStateListener.onStateChanged(currentState); } }); } } public interface OnState { void onStateChanged(WindState currentState); } /** * 表示当前状态 */ public enum WindState { ERROR, IDLE, RECORDING, STOP_RECORD, PLAYING, STOP_PLAY } /** * @param out wav音频文件流 * @param totalAudioLen 不包括header的音频数据总长度 * @param longSampleRate 采样率,也就是录制时使用的频率 * @param channels audioRecord的频道数量 * @throws IOException 写文件错误 */ private void writeWavFileHeader(FileOutputStream out, long totalAudioLen, long longSampleRate, int channels) throws IOException { byte[] header = generateWavFileHeader(totalAudioLen, longSampleRate, channels); out.write(header, 0, header.length); } /** * 任何一种文件在头部添加相应的头文件才能够确定的表示这种文件的格式， * wave是RIFF文件结构，每一部分为一个chunk，其中有RIFF WAVE chunk， * FMT Chunk，Fact chunk,Data chunk,其中Fact chunk是可以选择的 * * @param pcmAudioByteCount 不包括header的音频数据总长度 * @param longSampleRate 采样率,也就是录制时使用的频率 * @param channels audioRecord的频道数量 */ private byte[] generateWavFileHeader(long pcmAudioByteCount, long longSampleRate, int channels) { long totalDataLen = pcmAudioByteCount + 36; // 不包含前8个字节的WAV文件总长度 long byteRate = longSampleRate * 2 * channels; byte[] header = new byte[44]; header[0] = 'R'; // RIFF header[1] = 'I'; header[2] = 'F'; header[3] = 'F'; header[4] = (byte) (totalDataLen &amp; 0xff);//数据大小 header[5] = (byte) ((totalDataLen &gt;&gt; 8) &amp; 0xff); header[6] = (byte) ((totalDataLen &gt;&gt; 16) &amp; 0xff); header[7] = (byte) ((totalDataLen &gt;&gt; 24) &amp; 0xff); header[8] = 'W';//WAVE header[9] = 'A'; header[10] = 'V'; header[11] = 'E'; //FMT Chunk header[12] = 'f'; // 'fmt ' header[13] = 'm'; header[14] = 't'; header[15] = ' ';//过渡字节 //数据大小 header[16] = 16; // 4 bytes: size of 'fmt ' chunk header[17] = 0; header[18] = 0; header[19] = 0; //编码方式 10H为PCM编码格式 header[20] = 1; // format = 1 header[21] = 0; //通道数 header[22] = (byte) channels; header[23] = 0; //采样率，每个通道的播放速度 header[24] = (byte) (longSampleRate &amp; 0xff); header[25] = (byte) ((longSampleRate &gt;&gt; 8) &amp; 0xff); header[26] = (byte) ((longSampleRate &gt;&gt; 16) &amp; 0xff); header[27] = (byte) ((longSampleRate &gt;&gt; 24) &amp; 0xff); //音频数据传送速率,采样率*通道数*采样深度/8 header[28] = (byte) (byteRate &amp; 0xff); header[29] = (byte) ((byteRate &gt;&gt; 8) &amp; 0xff); header[30] = (byte) ((byteRate &gt;&gt; 16) &amp; 0xff); header[31] = (byte) ((byteRate &gt;&gt; 24) &amp; 0xff); // 确定系统一次要处理多少个这样字节的数据，确定缓冲区，通道数*采样位数 header[32] = (byte) (2 * channels); header[33] = 0; //每个样本的数据位数 header[34] = 16; header[35] = 0; //Data chunk header[36] = 'd';//data header[37] = 'a'; header[38] = 't'; header[39] = 'a'; header[40] = (byte) (pcmAudioByteCount &amp; 0xff); header[41] = (byte) ((pcmAudioByteCount &gt;&gt; 8) &amp; 0xff); header[42] = (byte) ((pcmAudioByteCount &gt;&gt; 16) &amp; 0xff); header[43] = (byte) ((pcmAudioByteCount &gt;&gt; 24) &amp; 0xff); return header; }} 参考资料 AudioRecord - developer.android.com AudioTrack - developer.android.com Android音视频相关文章请参考 https://rustfisher.com/tags/Android-Media/","link":"/2020/01/10/Android/Android-AudioRecord_AudioTrack_pcm_wav/"},{"title":"Android教程2020 - 系列简介","text":"Android教程2020迁移到Android教程2020，欢迎大家前来阅读👏 为了方便朋友入门安卓应用开发，开始整理2020年的Android新手教程。突出一个简单明了，上手快。从实用性出发，快速掌握Android开发基本技能。需要读者有一定的Java基础。 学完本课程后，读者可以自己做出一个个方便工作生活的小工具来。 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1htj93xu8gcij","link":"/2019/12/08/Android_tutorial_2020/Android-tutorial_2020_a_menu/"},{"title":"【运营的Python指南】Python Excel 绘制柱形图","text":"这是一份写给运营人员的Python指南。本文主要讲述如何使用Python操作Excel绘制柱形图。 相关代码请参考 https://github.com/RustFisher/python-playground 本文链接：https://www.rustfisher.com/2019/11/19/Python/Python-op-excel_openpyxl_bar_column_chart/ 开发工具，环境 PyCharm Python3 Office Excel 前面我们已经创建好了一张Excel表。现在我们要根据已有的数据，往里面添加柱形图。 柱形图 BarChart参考《Python openpyxl Excel绘制柱形图》得知，我们主要使用BarChart与BarChart3D类。图表中许多的细节由BarChart属性控制。 后文都以chart1来表示柱形图对象 chart1 = BarChart() 。 数据来源范围 Reference首先我们应该确定数据的范围。有数据才好绘图。这里使用的是Reference类来表示数据“引用”范围。12data1 = Reference(st, min_col=2, min_row=1, max_row=7, max_col=3)cats1 = Reference(st, min_col=1, min_row=2, max_row=7)需要注意的是，范围的下标是从1开始的。这里的data1把标题也框进去了。设定数据的时候，需要设置titles_from_data=True1chart1.add_data(data1, titles_from_data=True) 设置种类使用set_categories方法，也是把一个范围（Reference）的数据传入。1chart1.set_categories(cats1) 柱子方向控制 type方向由属性type来控制，有2个可选参数：bar表示横向，col表示竖直。 12chart1.type = &quot;bar&quot; # 横向柱形图chart1.type = &quot;col&quot; # 纵向柱形图 标题 title属性title控制标题。如果置为None则不显示标题。 图表的标题 chart1.title = &quot;日均值对比&quot; 坐标的标题，首先需要拿到x，y的坐标。12chart1.y_axis.title = '数值'chart1.x_axis.title = st.cell(column=1, row=1).value # 直接用单元格的内容做标题 添加图表add_chart将图表添加到sheet中。图表的左上角对齐某个单元格。下面是对齐A8。1st.add_chart(chart1, 'A8') 3D柱形图 BarChart3D柱子的形状 shape默认是立方体，但也可以从下面的形状里选一个。 {'box', 'pyramid', 'pyramidToMax', 'coneToMax', 'cone', 'cylinder'} 1chart1.type = 'cone' box 是立方体，中规中矩。pyramid 是金字塔，顶部也是尖的。cone 是圆锥，看起来很尖锐。cylinder 是圆柱。 配色风格 stylestyle 会影响图表的配色风格，一般用10比较多彩多样。 代码示例绘制图表用的数据来自运营的Python指南 - Python 操作Excel。我们在已有的表格中添加柱形图。代码参考python-playground - Github 绘制2D柱形图123456789101112131415161718192021222324def create_bar_chart_1(file_path): &quot;&quot;&quot; 插入柱形图 :param file_path: Excel 文件路径 :return: None &quot;&quot;&quot; wb = load_workbook(file_path) st = wb.active data1 = Reference(st, min_col=2, min_row=1, max_row=7, max_col=3) cats1 = Reference(st, min_col=1, min_row=2, max_row=7) chart1 = BarChart() chart1.type = &quot;col&quot; chart1.style = 9 chart1.title = &quot;日均值对比&quot; # chart1.y_axis.title = '数值' chart1.x_axis.title = st.cell(column=1, row=1).value chart1.add_data(data1, titles_from_data=True) chart1.set_categories(cats1) chart1.shape = 0 st.add_chart(chart1, 'A8') wb.save(file_path) 绘制3D柱形图1234567891011121314151617181920212223def create_bar_chart_2(file_path): &quot;&quot;&quot; 插入3D柱形图 :param file_path: Excel 文件路径 :return: None &quot;&quot;&quot; wb = load_workbook(file_path) st = wb.active data1 = Reference(st, min_col=2, min_row=1, max_row=7, max_col=3) cats1 = Reference(st, min_col=1, min_row=2, max_row=7) chart1 = BarChart3D() chart1.type = &quot;bar&quot; chart1.style = 10 chart1.title = &quot;日均值对比&quot; chart1.x_axis.title = None chart1.shape = 'cylinder' chart1.add_data(data1, titles_from_data=True) chart1.set_categories(cats1) st.add_chart(chart1, 'A26') wb.save(file_path) 运行结果示例图片 相关代码请参考 https://github.com/RustFisher/python-playground","link":"/2019/11/19/Python/Python-op-excel_openpyxl_bar_column_chart/"},{"title":"Python openpyxl Excel绘制柱形图","text":"这是一份openpyxl的使用指南。 大体内容翻译自官网 https://openpyxl.readthedocs.io/en/stable/charts/bar.html#vertical-horizontal-and-stacked-bar-charts 本文在官网基础上会有一些改动。代码请参考 https://github.com/RustFisher/python-playground 本文链接 https://rustfisher.com/2019/11/14/Python/Python-openpyxl_charts_Bar_and_Column/ 柱形图数据会被绘制成垂直，水平或者是层叠效果的柱形图。 注意： 接下来的设置会影响到不同类型的图表。 设置类别可以控制柱形图是垂直或是水平。 使用层叠图形时，需要设置overlap成100。 如果柱形是水平的，x和y坐标会对调过来。 2D图表 示例代码如下，根据给定的数据绘制了4张图表。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from openpyxl import Workbookfrom openpyxl.chart import BarChart, Series, Referencedef bar_chart_demo(): wb = Workbook(write_only=True) ws = wb.create_sheet() rows = [ ('Number', 'Batch 1', 'Batch 2'), (2, 10, 30), (3, 40, 60), (4, 50, 70), (5, 20, 10), (6, 10, 40), (7, 50, 30), ] for row in rows: ws.append(row) chart1 = BarChart() chart1.type = &quot;col&quot; chart1.style = 10 chart1.title = &quot;Bar Chart&quot; chart1.y_axis.title = 'Test number' chart1.x_axis.title = 'Sample length (mm)' data = Reference(ws, min_col=2, min_row=1, max_row=7, max_col=3) cats = Reference(ws, min_col=1, min_row=2, max_row=7) chart1.add_data(data, titles_from_data=True) chart1.set_categories(cats) chart1.shape = 4 ws.add_chart(chart1, &quot;A10&quot;) from copy import deepcopy chart2 = deepcopy(chart1) chart2.style = 11 chart2.type = &quot;bar&quot; chart2.title = &quot;Horizontal Bar Chart&quot; ws.add_chart(chart2, &quot;I10&quot;) chart3 = deepcopy(chart1) chart3.type = &quot;col&quot; chart3.style = 12 chart3.grouping = &quot;stacked&quot; chart3.overlap = 100 chart3.title = 'Stacked Chart' ws.add_chart(chart3, &quot;A27&quot;) chart4 = deepcopy(chart1) chart4.type = &quot;bar&quot; chart4.style = 13 chart4.grouping = &quot;percentStacked&quot; chart4.overlap = 100 chart4.title = 'Percent Stacked Chart' ws.add_chart(chart4, &quot;I27&quot;) wb.save(&quot;out/bar.xlsx&quot;)if __name__ == '__main__': bar_chart_demo() 译者注：这里调整了图表在excel中的位置，原文是在G列，即G10和G27，这里改为了I列。代码格式也有微调。 我们需要生成图表的时候，Excel会要我们先选定数据范围（来源）。在代码中用Reference来指定数据来源范围。 3D图表绘制3D图表，使用BarChart3D。1234567891011121314151617181920212223def bar_3d(): wb = Workbook() ws = wb.active rows = [ (None, 2013, 2014), (&quot;Apples&quot;, 5, 4), (&quot;Oranges&quot;, 6, 2), (&quot;Pears&quot;, 8, 3) ] for row in rows: ws.append(row) data = Reference(ws, min_col=2, min_row=1, max_col=3, max_row=4) titles = Reference(ws, min_col=1, min_row=2, max_row=4) chart = BarChart3D() chart.title = &quot;3D Bar Chart&quot; chart.add_data(data=data, titles_from_data=True) chart.set_categories(titles) ws.add_chart(chart, &quot;E5&quot;) wb.save(&quot;out/bar3d.xlsx&quot;) 创建好的图表用WPS打开发现是2D的。用Office Excel打开是3D的。 代码请参考 https://github.com/RustFisher/python-playground","link":"/2019/11/14/Python/Python-openpyxl_charts_Bar_and_Column/"},{"title":"【运营的Python指南】Python 操作Excel","text":"这是一份写给运营人员的Python指南。本文主要讲述如何使用Python操作Excel。完成Excel的创建，查询和修改操作。相关代码请参考 https://github.com/RustFisher/python-playground 本文链接：https://www.rustfisher.com/2019/11/05/Python/Python-op-excel_openpyxl_use/ 开发工具，环境 PyCharm - 方便好用的IDE Python3 这里默认你的电脑上已经装有python3.x，环境变量已经配置好。 引入openpyxl这里使用openpyxl库来操作Excel。类似的库还有xlrd。 penpyxl的基础使用方法请参见Python openpyxl 处理Excel使用指南。 1pip install openpyxl 数据准备假定数据来自百度指数，以常见的一些搜索指数为例。给后面的操作准备一些数据，把数据写入Excel中。 创建Workbook对象，获取到当前可用的表格（sheet）。直接使用append方法把一行数据追加写入。最后调用Workbook的保存方法，存储数据。 1234567891011121314151617def create_excel_demo(file_path): &quot;&quot;&quot; 创建Excel文件，并写入数据 :param file_path: 目标文件路径 :return none &quot;&quot;&quot; wb = Workbook() ws = wb.active ws.title = '搜索指数概览' ws.append(['关键词', '整体日均值', '移动日均值', '整体同比', '整体环比', '移动同比', '移动环比']) ws.append(['excel', 27782, 18181, -0.11, -2, 0.21, 0.02]) ws.append(['python', 24267, 8204, 0.27, 0.06, 0.56, 0.01]) ws.append(['文案', 2411, 1690, 0.56, 0.33, 0.91, 0.46]) ws.append(['okr', 1928, 880, 0.38, 0.15, 0.29, 0.09]) ws.append(['kpi', 4212, 2784, 0.21, -0.19, 0.36, -0.22]) wb.save(file_path) 创建出来的表格，示例数据如下 关键词 整体日均值 移动日均值 整体同比 整体环比 移动同比 移动环比 excel 27782 18181 -0.11 -2 0.21 0.02 python 24267 8204 0.27 0.06 0.56 0.01 … … … … … … … 读取数据访问整个表格的数据访问表格中所有的数据，并打印出来。首先我们要知道表格中有数据的单元格的范围，使用sheet.max_row与sheet.max_column获取表格的行列数量。 12345678910111213def read_xlsx_basic(file_path): &quot;&quot;&quot; 读取Excel的数据并打印出来 &quot;&quot;&quot; wb = load_workbook(file_path) st = wb.active end_row = st.max_row + 1 end_column = st.max_column + 1 print(st.title, '有', end_row, '行', end_column, '列') for row in range(1, end_row): for col in range(1, end_column): print('{:10}'.format(st.cell(row=row, column=col).value), end='') print() 值得注意的是，单元格下标是从1开始的。如果使用了不当的下标，报错信息 ValueError: Row or column values must be at least 1 参考： https://stackoverflow.com/questions/34492322/how-to-scan-all-sheet-cells 修改表格有了Excel表格后，我们可以修改表格的一些格式和数据。 st表示当前表。 调整列的宽度用 column_dimensions 来获取列。例如column_dimensions[‘A’]获取到的是第A列。ord方法是将字符转换为ascii码。ord(‘A’)得到65。 这里调整的是A列到G列的宽度。12for col in range(ord('A'), ord('G') + 1): st.column_dimensions[chr(col)].width = 15 设置单元格格式格式，比如字体大小，对齐模式，粗体斜体等。 字体首先我们要拿到单元格cell，这里使用st.cell(row=1, column=col)来获取某一个格子。Cell持有的font是不可修改的。不能使用如cell.font.size = 13这样的操作，会报异常。copy方法是复制一个对象。这里复制的是font。 12345cell = st.cell(row=1, column=col)font = copy(cell.font)font.size = 13font.bold = Truecell.font = font 对齐对齐模式。使用alignment属性。1cell.alignment = Alignment(horizontal=&quot;center&quot;, vertical=&quot;center&quot;) 数据显示操作Excel时，我们可以设置单元格数据显示的方式，比如常规，数值，货币，百分比等等。这里使用的是number_format属性。 如果数据（value）是0.02，经过下面的设置后，Excel中显示的是2%。1cell.number_format = '0%' 修改数据修改单元格的数值（value）。修改数据首先要拿到那个单元格cell，然后对其value赋值。1st.cell(row=2, column=7).value = 0.42 # 修改数值 修改了单元格的样式和数据后，可以打开表格看看效果。 参考： https://stackoverflow.com/questions/12387212/openpyxl-setting-number-format https://stackoverflow.com/questions/30050716/how-to-put-two-decimals-in-cell-with-type-of-percent 相关代码请参考 https://github.com/RustFisher/python-playground","link":"/2019/11/05/Python/Python-op-excel_openpyxl_use/"},{"title":"Python openpyxl 处理Excel使用指南","text":"这是一份openpyxl的使用指南。翻译自官网 https://openpyxl.readthedocs.io/en/stable/tutorial.html 本文链接 https://rustfisher.com/2019/11/03/Python/Python-openpyxl_tutorial/ 创建工作本workbook指的就是Excel文件。使用openpyxl并不需要你在电脑上自己创建文件。直接引入Workbook类就可以开始工作。 12&gt;&gt;&gt; from openpyxl import Workbook&gt;&gt;&gt; wb = Workbook() 至此一个至少有1个工作表的工作本已经被创建了。你可以通过Workbook.active属性来获取到工作表。1&gt;&gt;&gt; ws = wb.active 注意：默认工作表序号是被设置成0的。除非你修改了这个值，否则用这个方法获取到的都是第一张表。 可以通过 Workbook.create_sheet() 方法来创建新的工作表 12345&gt;&gt;&gt; ws1 = wb.create_sheet(&quot;Mysheet&quot;) # 默认在后面插入一张新表# 或者&gt;&gt;&gt; ws2 = wb.create_sheet(&quot;Mysheet&quot;, 0) # 在第一位插入新表# 或者&gt;&gt;&gt; ws3 = wb.create_sheet(&quot;Mysheet&quot;, -1) # 在倒数第二的位置插入表 工作表被创建的时候会自动命名，名字是以数字序列来排的（例如Sheet, Sheet1, Sheet2, …）。可以使用 Worksheet.title 来修改工作表的名字。 1ws.title = &quot;New Title&quot; 默认情况下，工作表名字的标题颜色是白色的。赋予RGB值 Worksheet.sheet_properties.tabColor 来修改颜色。 1ws.sheet_properties.tabColor = &quot;1072BA&quot; 当你命名了工作表后，也可以通过名字来获取到这张表。 1&gt;&gt;&gt; ws3 = wb[&quot;New Title&quot;] 查看工作本中所有表格的名字，使用 Workbook.sheetname 属性。 12&gt;&gt;&gt; print(wb.sheetnames)['Sheet2', 'New Title', 'Sheet1'] 循环打印名字12&gt;&gt;&gt; for sheet in wb:... print(sheet.title) 在同一个工作本（Excel文件）中，可以使用 Workbook.copy_worksheet() 复制表格。12&gt;&gt;&gt; source = wb.active&gt;&gt;&gt; target = wb.copy_worksheet(source) 注意只有单元格（包括数值，风格，超链接和注释）和确定的工作表属性（包括尺寸，格式和属性）可以被复制。工作表其他的内容是不能复制的，比如图片，图表等。 也可以在不同的Excel文件中复制表格。如果Excel文件是只读或只写的，就不能复制表格。 处理数据单元格现在我们知道来如何获取到工作表。我们可以开始修改单元格数据了。用单元格的坐标可以获取到单元格。1&gt;&gt;&gt; c = ws['A4']返回的是A4单元格。如果之前A4不存在，则会创建A4单元格。 给单元格传入数据，直接赋值1&gt;&gt;&gt; ws['A4'] = 4 我们也可以用 Worksheet.cell() 方法，通过行列序号的方式来拿到单元格。1&gt;&gt;&gt; d = ws.cell(row=4, column=2, value=10) 注意如果工作表是在内存中创建的，它是不包含单元格的。第一次获取单元格时会先创建单元格。 警告：因为这个特性，就算是没给单元格赋值，遍历的时候会直接在内存中创建它们。 例如123&gt;&gt;&gt; for x in range(1,101):... for y in range(1,101):... ws.cell(row=x, column=y)会在内存中创建 100x100 个没有值的单元格。 处理多个单元格获取一个范围内的多个单元格。1&gt;&gt;&gt; cell_range = ws['A1':'C2'] 获取行或列的单元格1234&gt;&gt;&gt; colC = ws['C']&gt;&gt;&gt; col_range = ws['C:D']&gt;&gt;&gt; row10 = ws[10]&gt;&gt;&gt; row_range = ws[5:10] 也可以用 Worksheet.iter_rows() 方法123456789&gt;&gt;&gt; for row in ws.iter_rows(min_row=1, max_col=3, max_row=2):... for cell in row:... print(cell)&lt;Cell Sheet1.A1&gt;&lt;Cell Sheet1.B1&gt;&lt;Cell Sheet1.C1&gt;&lt;Cell Sheet1.A2&gt;&lt;Cell Sheet1.B2&gt;&lt;Cell Sheet1.C2&gt; 类似的 Worksheet.iter_cols() 也会返回列单元格123456789&gt;&gt;&gt; for col in ws.iter_cols(min_row=1, max_col=3, max_row=2):... for cell in col:... print(cell)&lt;Cell Sheet1.A1&gt;&lt;Cell Sheet1.A2&gt;&lt;Cell Sheet1.B1&gt;&lt;Cell Sheet1.B2&gt;&lt;Cell Sheet1.C1&gt;&lt;Cell Sheet1.C2&gt; 注意：性能原因 Worksheet.iter_cols() 方法在只读模式下不能使用。 如果你需要遍历文件中的所有行列，可以使用Worksheet.rows123456789101112&gt;&gt;&gt; ws = wb.active&gt;&gt;&gt; ws['C9'] = 'hello world'&gt;&gt;&gt; tuple(ws.rows)((&lt;Cell Sheet.A1&gt;, &lt;Cell Sheet.B1&gt;, &lt;Cell Sheet.C1&gt;),(&lt;Cell Sheet.A2&gt;, &lt;Cell Sheet.B2&gt;, &lt;Cell Sheet.C2&gt;),(&lt;Cell Sheet.A3&gt;, &lt;Cell Sheet.B3&gt;, &lt;Cell Sheet.C3&gt;),(&lt;Cell Sheet.A4&gt;, &lt;Cell Sheet.B4&gt;, &lt;Cell Sheet.C4&gt;),(&lt;Cell Sheet.A5&gt;, &lt;Cell Sheet.B5&gt;, &lt;Cell Sheet.C5&gt;),(&lt;Cell Sheet.A6&gt;, &lt;Cell Sheet.B6&gt;, &lt;Cell Sheet.C6&gt;),(&lt;Cell Sheet.A7&gt;, &lt;Cell Sheet.B7&gt;, &lt;Cell Sheet.C7&gt;),(&lt;Cell Sheet.A8&gt;, &lt;Cell Sheet.B8&gt;, &lt;Cell Sheet.C8&gt;),(&lt;Cell Sheet.A9&gt;, &lt;Cell Sheet.B9&gt;, &lt;Cell Sheet.C9&gt;)) 或者是Worksheet.columns属性1234567891011121314151617181920&gt;&gt;&gt; tuple(ws.columns)((&lt;Cell Sheet.A1&gt;,&lt;Cell Sheet.A2&gt;,&lt;Cell Sheet.A3&gt;,&lt;Cell Sheet.A4&gt;,&lt;Cell Sheet.A5&gt;,&lt;Cell Sheet.A6&gt;,...&lt;Cell Sheet.B7&gt;,&lt;Cell Sheet.B8&gt;,&lt;Cell Sheet.B9&gt;),(&lt;Cell Sheet.C1&gt;,&lt;Cell Sheet.C2&gt;,&lt;Cell Sheet.C3&gt;,&lt;Cell Sheet.C4&gt;,&lt;Cell Sheet.C5&gt;,&lt;Cell Sheet.C6&gt;,&lt;Cell Sheet.C7&gt;,&lt;Cell Sheet.C8&gt;,&lt;Cell Sheet.C9&gt;)) 注意：基于性能方面的考虑，Worksheet.columns在只读模式中不能使用。 读取数据如果只是要读取表中的数据，可以使用 Worksheet.values。它会返回表中所有行的单元格的值。 123for row in ws.values: for value in row: print(value) Worksheet.iter_rows() 和 Worksheet.iter_cols() 都可以获取到单元格的值。12345&gt;&gt;&gt; for row in ws.iter_rows(min_row=1, max_col=3, max_row=2, values_only=True):... print(row)(None, None, None)(None, None, None) 数据存储当我们有了单元格后，可以赋值1234567&gt;&gt;&gt; c.value = 'hello, world'&gt;&gt;&gt; print(c.value)'hello, world'&gt;&gt;&gt; d.value = 3.14&gt;&gt;&gt; print(d.value)3.14 保存文件最简单和最安全的保存文件的方法就是使用 Workbook.save()。 12wb = Workbook()wb.save('balances.xlsx') 注意，这个方法会在没有警告的情况下覆盖已有的文件。 文件扩展名并没有被限制为xlsx或xlsm。 存储成为流（stream）如果要把文件存成流，例如web应用Pyramid, Flask 或者Django，提供一个NamedTemporaryFile()即可1234567&gt;&gt;&gt; from tempfile import NamedTemporaryFile&gt;&gt;&gt; from openpyxl import Workbook&gt;&gt;&gt; wb = Workbook()&gt;&gt;&gt; with NamedTemporaryFile() as tmp: wb.save(tmp.name) tmp.seek(0) stream = tmp.read() 把工作本保存成为模板，需要指定属性 template=True123&gt;&gt;&gt; wb = load_workbook('document.xlsx')&gt;&gt;&gt; wb.template = True&gt;&gt;&gt; wb.save('document_template.xltx') 设template为False，即保存为文档。123&gt;&gt;&gt; wb = load_workbook('document_template.xltx')&gt;&gt;&gt; wb.template = False&gt;&gt;&gt; wb.save('document.xlsx', as_template=False) 注意：在保存文档的时候应该注意文件扩展名，比如.xltx和.xlsx。以防后面用其他软件打开的时候遇到麻烦。 接下来的这些是错误操作123456789101112131415161718&gt;&gt;&gt; wb = load_workbook('document.xlsx')&gt;&gt;&gt; # 需要存储成*.xlsx文件&gt;&gt;&gt; wb.save('new_document.xlsm')&gt;&gt;&gt; # MS Excel 将无法打开这个文件&gt;&gt;&gt;&gt;&gt;&gt; # 或者&gt;&gt;&gt;&gt;&gt;&gt; # 需要指定 keep_vba=True&gt;&gt;&gt; wb = load_workbook('document.xlsm')&gt;&gt;&gt; wb.save('new_document.xlsm')&gt;&gt;&gt; # MS Excel 将无法打开这个文件&gt;&gt;&gt;&gt;&gt;&gt; # 或者&gt;&gt;&gt;&gt;&gt;&gt; wb = load_workbook('document.xltm', keep_vba=True)&gt;&gt;&gt; # 如果我们需要一个模板文件，我们必须指定扩展名为xltm&gt;&gt;&gt; wb.save('new_document.xlsm')&gt;&gt;&gt; # MS Excel 将无法打开这个文件 读取文件和写文件类似，使用openpyxl.load_workbook()方法去打开一个已有文件。1234&gt;&gt;&gt; from openpyxl import load_workbook&gt;&gt;&gt; wb2 = load_workbook('test.xlsx')&gt;&gt;&gt; print wb2.sheetnames['Sheet2', 'New Title', 'Sheet1']","link":"/2019/11/03/Python/Python-openpyxl_tutorial/"},{"title":"Android OkHttp + Retrofit 断点续传","text":"本文链接 前面我们已经知道如何使用OkHttp+Retrofit下载文件。下载文件时，可能会遇到一些意外情况，比如网络错误或是用户暂停了下载。再次启动下载，如果又要从头开始，会白白浪费前面下载好的内容。断点续传功能可以从上次停止的地方继续下载文件。 http范围请求Range 是一个请求首部，告知服务器返回文件的哪一部分。在一个 Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码。假如所请求的范围不合法，那么服务器会返回 416 Range Not Satisfiable 状态码，表示客户端错误。服务器允许忽略Range首部，从而返回整个文件，状态码用200。 示例1234Range: &lt;unit&gt;=&lt;range-start&gt;-Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt; 发起请求时，一般Range的内容写成 bytes=0-100 这样的形式。或者请求多个部分时，指定多个范围。1Range: bytes=200-1000, 2000-6576, 19000- Content-Range 表示主体长度或者尺寸。 参考： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range 使用示例参考https://github.com/AnRFDev/android-Basic4/tree/master/appdowloadsample 使用OkHttp添加Range头部，告知服务器我们需要的文件数据范围。 定义的方法中要求传入 @Header(“Range”)12345private interface ApiService { @Streaming @GET Observable&lt;ResponseBody&gt; downloadPartial(@Url String url, @Header(&quot;Range&quot;) String range);} 需要传入的Range字符串形如 bytes=200-1000 123456789101112131415161718192021222324252627282930313233343536373839retrofit.create(ApiService.class) .downloadPartial(callBack.getUrl(), &quot;bytes=&quot; + startByte + &quot;-&quot;) .subscribeOn(Schedulers.newThread()) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;ResponseBody&gt;() { @Override public void accept(ResponseBody responseBody) throws Exception { callBack.saveFile(responseBody); } }) .doOnError(new Consumer&lt;Throwable&gt;() { @Override public void accept(Throwable throwable) throws Exception { tellDownloadError(callBack.getUrl(), throwable); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;ResponseBody&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(ResponseBody responseBody) { } @Override public void onError(Throwable e) { callBack.setState(DownloadTaskState.ERROR); tellDownloadError(callBack.getUrl(), e); } @Override public void onComplete() { } }); 我们也可以在下载前，先去检查文件已下载的部分的大小，再决定Range范围。续传时，写入本地文件注意选择流的append模式。 1fos = new FileOutputStream(file, true); 更多请参考： Android OkHttp + Retrofit 使用示例 Android OkHttp + Retrofit 取消请求的方法 Android OkHttp + Retrofit 下载文件与进度监听 Android OkHttp + Retrofit 断点续传","link":"/2019/10/18/Android/Android-OkHttp_Retrofit_download_file_partial/"},{"title":"Android OkHttp + Retrofit 下载文件与进度监听","text":"本文链接 下载文件是一个比较常见的需求。给定一个url，我们可以使用URLConnection下载文件。使用OkHttp也可以通过流来下载文件。给OkHttp中添加拦截器，即可实现下载进度的监听功能。 使用流来实现下载文件代码可以参考：https://github.com/AnRFDev/android-Basic4/tree/master/appdowloadsample 获取并使用字节流，需要注意两个要点，一个是服务接口方法的 @Streaming 注解，另一个是获取到ResponseBody。 获取流（Stream）。先定义一个服务ApiService。给方法添加上@Streaming的注解。 12345private interface ApiService { @Streaming @GET Observable&lt;ResponseBody&gt; download(@Url String url);} 初始化OkHttp。记得填入你的baseUrl。123456789OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(8, TimeUnit.SECONDS) .build();retrofit = new Retrofit.Builder() .client(okHttpClient) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(&quot;https://yourbaseurl.com&quot;) .build(); 发起网络请求。获取到ResponseBody。123456789101112131415161718192021222324252627282930313233343536373839String downUrl = &quot;xxx.com/aaa.apk&quot;;retrofit.create(ApiService.class) .download(downUrl) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.io()) .doOnNext(new Consumer&lt;ResponseBody&gt;() { @Override public void accept(ResponseBody responseBody) throws Exception { // 处理 ResponseBody 中的流 } }) .doOnError(new Consumer&lt;Throwable&gt;() { @Override public void accept(Throwable throwable) throws Exception { Log.e(TAG, &quot;accept on error: &quot; + downUrl, throwable); } }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;ResponseBody&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(ResponseBody responseBody) { } @Override public void onError(Throwable e) { Log.e(TAG, &quot;Download center retrofit onError: &quot;, e); } @Override public void onComplete() { } }); 通过ResponseBody拿到字节流 body.byteStream()。这里会先创建一个临时文件tmpFile，把数据写到临时文件里。下载完成后再重命名成目标文件targetFile。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public void saveFile(ResponseBody body) { state = DownloadTaskState.DOWNLOADING; byte[] buf = new byte[2048]; int len; FileOutputStream fos = null; try { Log.d(TAG, &quot;saveFile: body content length: &quot; + body.contentLength()); srcInputStream = body.byteStream(); File dir = tmpFile.getParentFile(); if (dir == null) { throw new FileNotFoundException(&quot;target file has no dir.&quot;); } if (!dir.exists()) { boolean m = dir.mkdirs(); onInfo(&quot;Create dir &quot; + m + &quot;, &quot; + dir); } File file = tmpFile; if (!file.exists()) { boolean c = file.createNewFile(); onInfo(&quot;Create new file &quot; + c); } fos = new FileOutputStream(file); long time = System.currentTimeMillis(); while ((len = srcInputStream.read(buf)) != -1 &amp;&amp; !isCancel) { fos.write(buf, 0, len); int duration = (int) (System.currentTimeMillis() - time); int overBytes = len - downloadBytePerMs() * duration; if (overBytes &gt; 0) { try { Thread.sleep(overBytes / downloadBytePerMs()); } catch (Exception e) { e.printStackTrace(); } } time = System.currentTimeMillis(); if (isCancel) { state = DownloadTaskState.CLOSING; srcInputStream.close(); break; } } if (!isCancel) { fos.flush(); boolean rename = tmpFile.renameTo(targetFile); if (rename) { setState(DownloadTaskState.DONE); onSuccess(url); } else { setState(DownloadTaskState.ERROR); onError(url, new Exception(&quot;Rename file fail. &quot; + tmpFile)); } } } catch (FileNotFoundException e) { Log.e(TAG, &quot;saveFile: FileNotFoundException &quot;, e); setState(DownloadTaskState.ERROR); onError(url, e); } catch (Exception e) { Log.e(TAG, &quot;saveFile: IOException &quot;, e); setState(DownloadTaskState.ERROR); onError(url, e); } finally { try { if (srcInputStream != null) { srcInputStream.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { Log.e(TAG, &quot;saveFile&quot;, e); } if (isCancel) { onCancel(url); } }} 每次读数据的循环，计算读了多少数据和用了多少时间。超过限速后主动sleep一下，达到控制下载速度的效果。要注意不能sleep太久，以免socket关闭。这里控制的是网络数据流与本地文件的读写速度。 下载进度监听OkHttp实现下载进度监听，可以从字节流的读写那里入手。也可以使用拦截器，参考官方的例子。这里用拦截器的方式实现网络下载进度监听功能。 定义回调与网络拦截器先定义回调。123public interface ProgressListener { void update(String url, long bytesRead, long contentLength, boolean done);} 自定义ProgressResponseBody。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ProgressResponseBody extends ResponseBody { private final ResponseBody responseBody; private final ProgressListener progressListener; private BufferedSource bufferedSource; private final String url; ProgressResponseBody(String url, ResponseBody responseBody, ProgressListener progressListener) { this.responseBody = responseBody; this.progressListener = progressListener; this.url = url; } @Override public MediaType contentType() { return responseBody.contentType(); } @Override public long contentLength() { return responseBody.contentLength(); } @Override public BufferedSource source() { if (bufferedSource == null) { bufferedSource = Okio.buffer(source(responseBody.source())); } return bufferedSource; } private Source source(final Source source) { return new ForwardingSource(source) { long totalBytesRead = 0L; @Override public long read(Buffer sink, long byteCount) throws IOException { long bytesRead = super.read(sink, byteCount); // read() returns the number of bytes read, or -1 if this source is exhausted. totalBytesRead += bytesRead != -1 ? bytesRead : 0; progressListener.update(url, totalBytesRead, responseBody.contentLength(), bytesRead == -1); return bytesRead; } }; }} 定义拦截器。从Response中获取信息。1234567891011121314151617public class ProgressInterceptor implements Interceptor { private ProgressListener progressListener; public ProgressInterceptor(ProgressListener progressListener) { this.progressListener = progressListener; } @NotNull @Override public Response intercept(@NotNull Chain chain) throws IOException { Response originalResponse = chain.proceed(chain.request()); return originalResponse.newBuilder() .body(new ProgressResponseBody(chain.request().url().url().toString(), originalResponse.body(), progressListener)) .build(); }} 添加拦截器在创建OkHttpClient时添加ProgressInterceptor。123456789OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(8, TimeUnit.SECONDS) .addInterceptor(new ProgressInterceptor(new ProgressListener() { @Override public void update(String url, long bytesRead, long contentLength, boolean done) { // tellProgress(url, bytesRead, contentLength, done); } })) .build(); 值得注意的是这里的进度更新非常频繁。并不一定每次回调都要去更新UI。 更多请参考： Android OkHttp + Retrofit 使用示例 Android OkHttp + Retrofit 取消请求的方法 Android OkHttp + Retrofit 下载文件与进度监听 Android OkHttp + Retrofit 断点续传","link":"/2019/10/18/Android/Android-OkHttp_Retrofit_download_file/"},{"title":"Python 使用FFmpeg操作mp4","text":"使用FFmpeg首先得了解FFmpeg的用法。 1ffmpeg -i red.mkv -f flac -vn red.flac 如果音频（视频）比字幕快（或慢），则在裁剪的时候统一加上或减去一个时间差。 FFmpegPyCharm 报错 ‘ffmpeg’ 不是内部或外部命令，也不是可运行的程序 虚拟环境中需要找到FFmpeg的绝对路径 1ffmpeg_bin = 'E:/ffmpeg-20191019-31aafda-win64-static/bin/ffmpeg' 1subprocess.call(get_mp3_cmd, shell=True) Pythonpython 读取文件时报错 UnicodeDecodeError: 'gbk' codec can't decode错误UnicodeEncodeError: ‘gbk' codec can't encode character ‘\\xa0' in position 在网上一查，发现是 Windows 的控制台的问题。控制台的编码是 GBK，Python 是 UTF-8，造成了冲突。 第一种方法：直接替换出错的内容123import requests url = 'https://blog.csdn.net/jianhong1990/article/details/17349537'print(requests.get(url).text.replace('\\xa0', ' ')) 第二种方法：再解码 先用 GBK 编码，加个 ignore 丢弃错误的字符，然后再解码。 123import requestsurl = 'https://blog.csdn.net/jianhong1990/article/details/17349537'print(requests.get(url).text.encode('gbk', 'ignore').decode('gbk') int与string之间的转化str转成数字1ms = int(ms) 数字转成str补零1'{:0&gt;2d}'.format(1) # output 01 获取当前时间1234567import timetime.time() # 格式化时间戳为标准格式print(time.strftime('%Y%m%d-%H%M%S', time.localtime(time.time())))# 获取30天前的时间（通过加减秒数来获取现在或者未来某个时间点）print time.strftime('%Y.%m.%d',time.localtime(time.time()-2592000)) 参考 http://www.zimuku.la/detail/123853.html http://assrt.net/","link":"/2019/10/09/Python/Python-FFmpeg-extraction-mp4_tool/"},{"title":"Android MediaPlayer 音频倍速播放，调整播放速度","text":"本文链接： Android MediaPlayer 音频倍速播放，调整播放速度 现在市面上的很多音视频App都有倍速播放的功能，例如把播放速度调整为0.5、1.5、2倍等等。 从Android API 23 (Android M)开始，MediaPlayer支持调整播放速度。使用的方法是setPlaybackParams，传入一个代表播放属性的类PlaybackParams。 本文介绍如何使用MediaPlayer调整播放速度。 MediaPlayer.setPlaybackParams 说明播放速度设置在PlaybackParams对象中，再将此对象传入setPlaybackParams。 setPlaybackParams是一个native方法。如果MediaPlayer没有准备（在prepared之前），调用此方法并不会改变MediaPlayer的状态。在MediaPlayer成功prepare之后，如果设置的速度为0，相当于调用了pause方法；如果设置速度不为0，相当于调用了start方法。 异常情况如果MediaPlayer没有初始化或者已经被释放，即处于Idle或End状态，调用setPlaybackParams方法会抛出IllegalStateException异常。 如果传入的PlaybackParams不被支持，则抛出IllegalArgumentException异常。 如果设置速度小于0，则抛出java.lang.IllegalArgumentException异常。 MediaPlayer.setPlaybackParams 方法示例设置播放速度。先判断当前系统版本。 123456789private boolean setPlaySpeed(float speed) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { PlaybackParams params = mediaPlayer.getPlaybackParams(); params.setSpeed(speed); mediaPlayer.setPlaybackParams(params); return true; } return false;} getPlaybackParams可以获取到MediaPlayer当前的PlaybackParams对象。也可以给这个方法加上try catch，结合返回的boolean值判断设置速度是否成功。 1234567891011121314private boolean setPlaySpeed(float speed) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { try { PlaybackParams params = mediaPlayer.getPlaybackParams(); params.setSpeed(speed); mediaPlayer.setPlaybackParams(params); return true; } catch (Exception e) { Log.e(TAG, &quot;setPlaySpeed: &quot;, e); return false; } } return false;} 参考代码 https://github.com/RustFisher/android-MediaPlayer PlaybackParams 包含的速度值调整MediaPlayer播放速度时，我们使用了PlaybackParams对象。AudioTrack也会用到这个类。 PlaybackParams包含着播放时候的一些属性。例如speed就是播放速度。 PlaybackParams.setSpeed(float speed)传入速度倍率值。会标记当前设置过了速度。 12345public PlaybackParams setSpeed(float speed) { mSpeed = speed; mSet |= SET_SPEED; return this;} PlaybackParams.getSpeed()获取已设置的速度值。如果之前没设置过速度，则抛出IllegalStateException异常。 123456public float getSpeed() { if ((mSet &amp; SET_SPEED) == 0) { throw new IllegalStateException(&quot;speed not set&quot;); } return mSpeed;} 更多参考： Android MediaPlayer 基础简介 Android MediaPlayer 播放音频 Android 使用URLConnection下载音频文件 Android MediaPlayer 音频倍速播放，调整播放速度 Android音视频相关文章请参考 https://rustfisher.com/tags/Android-Media/","link":"/2019/09/25/Android/Android-MediaPlayer_use_play_speed/"},{"title":"Android 使用URLConnection下载音频文件","text":"本文链接： Android 使用URLConnection下载音频文件 使用MediaPlayer播放在线音频，请参考Android MediaPlayer 播放音频 有时候我们会需要下载音频文件。这里提供一种思路，将在线音频文件通过流写到本地文件中。使用URLConnection来建立连接，获取到的数据写到文件中。 URLConnection建立连接后，可以获取到数据长度。由此我们可以计算出下载进度。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class DownloadStreamThread extends Thread { String urlStr; final String targetFileAbsPath; public DownloadStreamThread(String urlStr, String targetFileAbsPath) { this.urlStr = urlStr; this.targetFileAbsPath = targetFileAbsPath; } @Override public void run() { super.run(); int count; File targetFile = new File(targetFileAbsPath); try { boolean n = targetFile.createNewFile(); Log.d(TAG, &quot;Create new file: &quot; + n + &quot;, &quot; + targetFile); } catch (IOException e) { Log.e(TAG, &quot;run: &quot;, e); } try { URL url = new URL(urlStr); URLConnection connection = url.openConnection(); connection.connect(); int contentLength = connection.getContentLength(); InputStream input = new BufferedInputStream(url.openStream()); OutputStream output = new FileOutputStream(targetFileAbsPath); byte[] buffer = new byte[1024]; long total = 0; while ((count = input.read(buffer)) != -1) { total += count; Log.d(TAG, String.format(Locale.CHINA, &quot;Download progress: %.2f%%&quot;, 100 * (total / (double) contentLength))); output.write(buffer, 0, count); } output.flush(); output.close(); input.close(); } catch (Exception e) { Log.e(TAG, &quot;run: &quot;, e); } }} 启动下载，即启动线程。1new DownloadStreamThread(urlStr, targetFileAbsPath).start(); 值得注意的是，如果本地已经有了文件，需要做一些逻辑判断。例如是否删掉旧文件，重新下载。或是判断出已有文件，中止此次下载任务。例如可以用connection.getContentLength()与当前文件长度来比较，如果不一致，则删掉本地文件，重新下载。 实际上，URLConnection能处理很多流媒体。在这里是用来下载音频文件。可以实现下载功能和类似“边下边播”的功能。 代码可以参考示例工程： https://github.com/RustFisher/android-MediaPlayer 更多参考： Android MediaPlayer 基础简介 Android MediaPlayer 播放音频 Android 使用URLConnection下载音频文件 Android MediaPlayer 音频倍速播放，调整播放速度 Android音视频相关文章请参考 https://rustfisher.com/tags/Android-Media/","link":"/2019/09/23/Android/Android-Media_download_stream_file/"},{"title":"Android MediaPlayer 播放音频","text":"本文链接： Android MediaPlayer 播放音频 主要介绍使用MediaPlayer播放音频的方式。关于MediaPlayer的基础知识，比如状态，可以参考Android MediaPlayer 基础简介。 为了方便表达，定义变量名为mediaPlayer。 MediaPlayer的使用方式创建MediaPlayer可以直接 new MediaPlayer，也可以用MediaPlayer提供的create方法创建。1mediaPlayer = new MediaPlayer(); 使用create方法创建成功后，mediaPlayer处于Prepared状态。可以直接start播放。12mediaPlayer = MediaPlayer.create(getApplicationContext(), Uri.fromFile(file));mediaPlayer.start(); 设置音源 - setDataSource通过调用setDataSource来设置音源。setDataSource有多个重载方法，我们来看常用的几种。 例如设置使用assets里的资源。实际情况可能需要try catch。1234AssetFileDescriptor fd = null;MediaPlayer mediaPlayer = new MediaPlayer();fd = context.getApplicationContext().getAssets().openFd(name);mediaPlayer.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength()); 本地文件，需要文件的绝对路径。1mediaPlayer.setDataSource(file.getAbsolutePath()); 或者获取文件的Uri来创建mediaPlayer。1mediaPlayer = MediaPlayer.create(getApplicationContext(), Uri.fromFile(file)); 设置网络音频，也是用setDataSource方法，设置url。1mediaPlayer.setDataSource(&quot;https://demo.com/sample.mp3&quot;)); 播放网络音频时，如果使用的是http，有可能会报错1java.io.IOException: Cleartext HTTP traffic to demo.com not permitted 可以简单地设置一下manifest，设置usesCleartextTraffic=”true”12&lt;application android:usesCleartextTraffic=&quot;true&quot;&gt; 准备 - prepare同步和异步准备音频资源。prepareAsync()是异步的方式，prepare是同步的。注意线程调度问题，同时不要阻塞UI线程。 使用异步方式准备音频，经常与MediaPlayer.OnPreparedListener监听器配合使用。异步准备时，也可以进行其他的设置。1234567mediaPlayer.prepareAsync();mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { mediaPlayer.start(); // 准备好了就播放 }}); 循环播放 - Looping设置循环播放setLooping。1mediaPlayer.setLooping(true);播放完毕后，不会回调OnCompletionListener，而是从头播放当前音频。 播放 - start播放音频，调用start方法。1mediaPlayer.start(); 处于Prepared，Pause和PlaybackComplete状态时，可以调用start方法，进入Started状态。 暂停 - pause暂停播放，使用pause方法。在暂停前先判断一下mediaPlayer的是否在播放。 123if (mediaPlayer.isPlaying()) { mediaPlayer.pause();} 暂停成功则处于Paused状态。 停止 - stop回顾一下MediaPlayer状态切换的图示，我们可以得知在播放中，暂停，播放完成这3个状态下，可以调用stop方法，进入Stopped状态。 1mediaPlayer.stop(); 调进度 - seekTo调整播放进度。我们平时使用音乐播放软件一般都会有这个功能。seekTo方法接受一个毫秒参数。 12int targetMS = (int) (percent * mediaPlayer.getDuration());mediaPlayer.seekTo(targetMS); seekTo并不会改变MediaPlayer的状态。 重置 - resetreset后的mediaPlayer进入Idle状态。需要重新设置音源与准备。 释放 - release不再使用这个mediaPlayer时，应当尽快释放掉，以释放相关的资源。调用release后，mediaPlayer进入End状态。此时这个mediaPlayer就不能再使用了。 常用监听器缓冲监听器 OnBufferingUpdateListener比如我们加载网络音频的时候，常用这个监听器来监听缓冲进度。显示缓冲进度，也可以提高用户体验。 1234567mMediaPlayer.prepareAsync();mMediaPlayer.setOnBufferingUpdateListener(new MediaPlayer.OnBufferingUpdateListener() { @Override public void onBufferingUpdate(MediaPlayer mp, int percent) { // percent代表缓冲百分比 }}); 错误监听器 OnErrorListener123456mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mediaPlayer, int i, int i1) { return true; // 返回true表示在此处理错误，不会回调onCompletion }}); 注意onError的返回值。可以选择自己处理error。 12345 * @return True if the method handled the error, false if it didn't. * Returning false, or not having an OnErrorListener at all, will * cause the OnCompletionListener to be called. */boolean onError(MediaPlayer mp, int what, int extra); 播放完毕监听器 OnCompletionListener123456mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { // 播放完毕 }}); 使用示例播放assets里的音频播放assets里的音频文件，使用到AssetFileDescriptor类。使用后记得关闭AssetFileDescriptor。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private void playAssetsAudio(final String name, Context context) { Log.d(TAG, &quot;playAssetWordSound: try to play assets sound file. -&gt; &quot; + name); AssetFileDescriptor fd = null; try { MediaPlayer mediaPlayer; Log.v(TAG, &quot;Looking in assets.&quot;); fd = context.getApplicationContext().getAssets().openFd(name); mediaPlayer = new MediaPlayer(); mediaPlayer.reset(); mediaPlayer.setDataSource(fd.getFileDescriptor(), fd.getStartOffset(), fd.getLength()); mediaPlayer.prepareAsync(); mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { Log.d(TAG, &quot;onPrepared: &quot; + name); mediaPlayer.start(); } }); mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mp) { mp.release(); Log.d(TAG, &quot;onCompletion: &quot; + name); } }); mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mp, int i, int i1) { mp.release(); return true; } }); } catch (Exception e) { try { if (fd != null) { fd.close(); } } catch (Exception e1) { Log.e(TAG, &quot;Exception close fd: &quot;, e1); } } finally { if (fd != null) { try { fd.close(); } catch (IOException e) { Log.e(TAG, &quot;Finally, close fd &quot;, e); } } }} 播放本地音频文件尝试播放音频文件。仅播放一次。 1234567891011121314151617181920212223242526private void playAudioFile(final File file) { Log.d(TAG, &quot;playAudioFile: &quot; + file.getAbsolutePath()); MediaPlayer mediaPlayer; try { mediaPlayer = new MediaPlayer(); mediaPlayer.setLooping(false); mediaPlayer.setDataSource(file.getAbsolutePath()); mediaPlayer.prepare(); mediaPlayer.start(); mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mp) { mp.release(); } }); mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mediaPlayer, int i, int i1) { Log.d(TAG, &quot;Play local sound onError: &quot; + i + &quot;, &quot; + i1); return true; } }); } catch (Exception e) { Log.e(TAG, &quot;playAudioFile: &quot;, e); }} 播放在线音频设置url，播放在线音频 12345678910111213141516171819202122232425262728293031private void playOnlineSound(String soundUrlDict) { try { MediaPlayer mediaPlayer = new MediaPlayer(); mediaPlayer.setDataSource(soundUrlDict); mediaPlayer.prepareAsync(); mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { mediaPlayer.start(); } }); mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mp) { if (mp != null) { mp.release(); } Log.d(TAG, &quot;onCompletion: play sound.&quot;); } }); mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mediaPlayer, int i, int i1) { Log.d(TAG, &quot;Play online sound onError: &quot; + i + &quot;, &quot; + i1); return false; } }); } catch (IOException e1) { Log.e(TAG, &quot;url: &quot;, e1); }} 代码可以参考示例工程： https://github.com/RustFisher/android-MediaPlayer 更多参考： Android MediaPlayer 基础简介 Android MediaPlayer 播放音频 Android 使用URLConnection下载音频文件 Android MediaPlayer 音频倍速播放，调整播放速度 Android音视频相关文章请参考 https://rustfisher.com/tags/Android-Media/","link":"/2019/09/22/Android/Android-MediaPlayer_use_play_audio/"},{"title":"Android MediaPlayer 基础简介","text":"本文链接： Android MediaPlayer 基础简介 简单介绍MediaPlayer的基本概念，状态，常用的方法与监听器。 什么是MediaPlayerMediaPlayer类可以用来播放音视频文件，或者是音频流。开发者可以用它来播放本地音频，或者是网络在线音频。 MediaPlayer属于android.media包。 MediaPlayer的状态播放控制由状态机控制。在日常生活中，我们常见的音频状态有播放中，暂停，停止，缓冲等等。MediaPlayer的状态有如下几种： Idle End Error Initialized Preparing Prepared Started Stopped Paused PlaybackCompleted 状态的切换参考官方图例。这里稍微解释一下状态转换图片。椭圆代表MediaPlayer可能停留的状态。椭圆之间的箭头表示方法调用，状态切换的方向。单箭头表示方法同步调用，双箭头表示异步调用。 从图中我们可以看出状态切换的路径和涉及到的方法。 Idle与End状态当new一个MediaPlayer或者调用了reset方法，当前MediaPlayer会处于Idle状态。调用release后，会处于End状态。在这2个状态之间的状态可以看做是MediaPlayer对象的生命周期。 在新创建MediaPlayer和调用reset的MediaPlayer之间有一些细微的差别。这两种情况都处于Idle状态，调用 getCurrentPosition(), getDuration(), getVideoHeight(), getVideoWidth(), setAudioAttributes(android.media.AudioAttributes), setLooping(boolean), setVolume(float, float), pause(), start(), stop(), seekTo(long, int), prepare() 或 prepareAsync()方法都会抛出错误，如果是新实例化的MediaPlayer，不会回调 OnErrorListener.onError()；但如果是reset后的MediaPlayer，会回调 OnErrorListener.onError()并且转换到Error状态。 如果MediaPlayer对象不再使用了，立即调用release()方法，释放内部播放器占用的资源。这些资源可能是唯一的，比如硬件加速组件。如果调用release失败，可能会引起一连串的MediaPlayer实例失效。当MediaPlayer处于End状态，它就不能再转移到其它状态了。 new一个MediaPlayer，处于Idle状态。如果用create方法创建实例，当创建完成时处于Prepared状态。 发生错误一些情形可能会让MediaPlayer操作失败，比如不支持的音视频格式，分辨率过高，网络超时等等。因此在这些情形下错误处理和恢复非常重要。有时候编程错误也会导致MediaPlayer操作错误。开发者可以设置错误监听器setOnErrorListener(android.media.MediaPlayer.OnErrorListener)。当错误发生时，会调用用户实现的OnErrorListener.onError()方法。 不管有没有设置监听器，错误发生时MediaPlayer会进入Error状态。 为了重复使用同一个MediaPlayer对象，可以使用reset()方法把它从Error状态恢复到Idle状态。设置错误监听器OnErrorListener是一个好的编程习惯。开发者可以监听到播放引擎的错误通知。有时候会抛出IllegalStateException异常，比如在错误的状态调用了prepare(), prepareAsync()方法，或是setDataSource方法。 设置音源 setDataSource调用setDataSource(java.io.FileDescriptor), 或者 setDataSource(java.lang.String), 或者 setDataSource(android.content.Context, android.net.Uri), 或者 setDataSource(java.io.FileDescriptor, long, long), 或者 setDataSource(android.media.MediaDataSource) 可以将MediaPlayer的状态从Idle转到Initialized状态。如果在Idle状态之外的状态调用了setDataSource()，会抛出IllegalStateException异常。开发者应该留意setDataSource方法抛出的IllegalArgumentException和IOException异常。 播放音频前必须在Prepared状态MediaPlayer在开始播放音频前必须处于Prepared状态。 MediaPlayer有同步和异步2种方式来进入Prepared状态。如果是异步的方式，会先转到Preparing状态，再转到Prepared状态。当准备完成时，内部的播放引擎会回调用户之前设置的OnPreparedListener的onPrepared()方法。 开发者必须注意的是，Preparing状态是一个过渡状态（transient state）。 处于Prepared状态时，可以通过相对应的方法设置音量，屏幕常亮，播放循环等。 开始播放播放音频必须调用start()方法。调用start()返回成功后，MediaPlayer处于Started状态。可以通过isPlaying()来判断当前是否在Started状态。 如果开发者设置了OnBufferingUpdateListener，Android内部播放器会向外传递buffer信息。 如果当前处于Started状态，再调用start()方法没有效果。 暂停播放与继续播放音频可以被暂停播放和继续播放，也可以调整播放的位置。通过pause()方法来暂停音频播放。成功调用pause()方法后，MediaPlayer进入Paused状态。应当注意的是，MediaPlayer在Started状态与Paused状态之间切换是异步的。播放音频流的时候，这个转换过程可能会需要几秒钟。 MediaPlayer暂停时，start()方法可以从暂停的位置继续播放。成功调用start方法后会进入Started状态。 处于Paused状态时，调用pause()方法没有效果。 停止调用stop()方法让MediaPlayer从Started, Paused, Prepared 或 PlaybackCompleted 状态进入 Stopped 状态。 在Stopped状态时，必须先调用prepare() 或 prepareAsync()进入Prepared状态后，才能播放音频。 处于Stopped状态时，调用stop()方法没有效果。 调整播放位置调用seekTo(long, int)来调整播放位置。 seekTo(long, int)是一个异步方法，虽然它能立刻返回，但实际的位置调整可能会消耗一段时间，特别是在播放音频流的时候。当实际播放位置调整后，内部播放器会回调开发者设置的OnSeekComplete.onSeekComplete()。 在Prepared, Paused 和 PlaybackCompleted状态中，都可以调用seekTo方法。 可以通过getCurrentPosition()方法来获取当前播放位置。开发者可以得知当前播放的进度等等。 播放完毕音频播放完成后，播放完毕。 如果调用setLooping(boolean)为true，MediaPlayer会停留在Started状态。 如果setLooping为false，内部播放器会调用开发者设置的OnCompletion.onCompletion()，并且进入PlaybackCompleted状态。 处于PlaybackCompleted状态时，调用start()方法可以从头开始播放音频。 常用监听器开发者可以设置一些监听器，监听MediaPlayer的状态，错误事件等等。开发者应在同一个线程中创建MediaPlayer与设置的监听器。 setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)监听MediaPlayer准备完成。一般与prepareAsync配合使用。 setOnVideoSizeChangedListener(android.media.MediaPlayer.OnVideoSizeChangedListener)获知video大小或video大小改变时的监听。 setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener)监听调整位置完成。 setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)播放完成。 123456mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mediaPlayer) { // 当前播放完毕 }}); setOnBufferingUpdateListener(android.media.MediaPlayer.OnBufferingUpdateListener)监听缓冲进度。在播放网络音频时常用。 缓冲监听器OnBufferingUpdateListener 1234567mMediaPlayer.prepareAsync();mMediaPlayer.setOnBufferingUpdateListener(new MediaPlayer.OnBufferingUpdateListener() { @Override public void onBufferingUpdate(MediaPlayer mp, int percent) { // 例如在这里更新UI }}); setOnInfoListener(android.media.MediaPlayer.OnInfoListener)监听普通信息或者警告信息。 setOnErrorListener(android.media.MediaPlayer.OnErrorListener)监听错误信息。错误发生时，可以在这里处理错误。 1234567mediaPlayer.setOnErrorListener(new MediaPlayer.OnErrorListener() { @Override public boolean onError(MediaPlayer mediaPlayer, int i, int i1) { LogUtil.e(TAG_PREFIX + &quot; onERR i = &quot; + i + &quot; i1 = &quot; + i1); return true; // 返回true表示在此处理错误，不会回调onCompletion }}); 注意onError的返回值。可以选择自己处理error。 12345 * @return True if the method handled the error, false if it didn't. * Returning false, or not having an OnErrorListener at all, will * cause the OnCompletionListener to be called. */boolean onError(MediaPlayer mp, int what, int extra); 需要的权限播放网络音频时需要Manifest.permission.INTERNET权限。 更多参考： Android MediaPlayer 基础简介 Android MediaPlayer 播放音频 Android 使用URLConnection下载音频文件 Android MediaPlayer 音频倍速播放，调整播放速度 Android音视频相关文章请参考 https://rustfisher.com/tags/Android-Media/","link":"/2019/09/19/Android/Android-MediaPlayer_intro/"},{"title":"Android mmap 文件映射到内存介绍","text":"本文链接： Android mmap 文件映射到内存介绍 Android开发中，我们可能需要记录一些文件。例如记录log文件。如果使用流来写文件，频繁操作文件io可能会引起性能问题。为了降低写文件的频率，我们可能会采用缓存一定数量的log，再一次性把它们写到文件中。如果app异常退出，我们有可能会丢失内存中的log信息。那么有什么比较稳妥的写文件方式，既能降低io，又能尽可能地保证数据被写入文件呢？ mmap简介mmap概念mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。 特点：实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示： mmap内存映射原理mmap内存映射的实现过程，总的来说可以分为三个阶段： 应用进程启动映射，在进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址作为映射区域；调用系统函数mmap，实现文件物理地址和进程虚拟地址的一一映射；应用进程对映射区域访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。 mmap优缺点只有一次数据拷贝：当发生缺页异常时，直接将数据从磁盘拷贝到进程的用户空间，跳过了页缓存。实现了用户空间和内核空间的高效交互方式：两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。提供进程间共享内存及相互通信的方式。 不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。 同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。 mmap注意点对于大文件而言，内存映射比普通IO流要快，小文件则未必；不要经常调用MappedByteBuffer.force()方法，这个方法强制操作系统将内存中的内容写入硬盘，所以如果你在每次写内存映射文件后都调用force()方法，你就不能真正从内存映射文件中获益，而是跟disk IO差不多。读写内存映射文件是操作系统来负责的，因此，即使你的Java程序在写入内存后就挂掉了，只要操作系统工作正常，数据就会写入磁盘。如果电源故障或者主机瘫痪，有可能内存映射文件还没有写入磁盘，意味着可能会丢失一些关键数据。 参考 https://stackoverflow.com/questions/258091/when-should-i-use-mmap-for-file-access https://www.jianshu.com/p/187eada7b900 https://juejin.im/post/5c3ec9ebf265da61223a93de#heading-0 https://stackoverflow.com/questions/30180268/android-ndk-mmap-call-broken-on-32-bit-devices-after-upgrading-to-lollipop https://stackoverflow.com/questions/33897711/android-mmap-fails-with-out-of-memory Android中的Binder也利用的mmap。Binder传递数据时，只需要复制一次，就能把数据传递到另一个进程中。参考Binder机制介绍 Android中使用mmapAndroid中使用mmap，可以通过RandomAccessFile与MappedByteBuffer来配合。参考drone开发记录 - log记录工具 通过randomAccessFile.getChannel().map获取到MappedByteBuffer。然后调用ByteBuffer的put方法添加数据。","link":"/2019/08/20/Android/Android-mmap_intro_and_use/"},{"title":"「小程序」开发记录","text":"wxml标签严格闭合。rpx（responsive pixel）尺寸单位。大小写敏感。 我们只要保持一个原则就可以提高小程序的渲染性能：每次只设置需要改变的最小单位数据。此外需要注意以下3点： 直接修改 Page实例的this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。 由于setData是需要两个线程的一些通信消耗，为了提高性能，每次设置的数据不应超过1024kB。 不要把data中的任意一项的value设为undefined，否则可能会有引起一些不可预料的bug。 “用户在渲染层的行为反馈”以及“组件的部分状态反馈”抽象为渲染层传递给逻辑层的“事件” 数据绑定通过 大括号大括号 语法可以使得 WXML 拥有动态渲染的能力，除此外还可以在其中进行简单的逻辑运算。大括号大括号中还可以直接放置数字、字符串或者是数组。 使用 wx:key 来指定列表中项目的唯一的标识符。 wx:key 的值以两种形式提供： 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 模板WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。使用 name 属性，作为模板的名字。然后在 &lt;template/&gt; 内定义代码片段 使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入 WXML 提供两种文件引用方式import和include。 import 可以在该文件中使用目标文件定义的 template import 不具有递归的特性。 条件渲染在wxml中使用wx:if。1&lt;text wx:if=&quot;{{showPing}}&quot;&gt;{{s.ping}} &lt;/text&gt; WXML 中，使用 wx:if=”“ 来判断是否需要渲染该代码块。标签定义的前部使用逻辑判断。使用 wx:elif 和 wx:else 来添加一个 else 块。 排版布局水平居中内容123&lt;view style=&quot;width:100%; display:flex;flex-direction:row;justify-content:center;&quot;&gt;&lt;/view&gt; flex垂直方向居中主要靠align-items: center;。不设置高度的时候。123456.cfg-start { display: flex; flex-direction: row; margin-right: 20px; align-items: center;} 设置了绝对定位。需要同时设置高度。123456789.cfg-end { position: absolute; right: 0px; height: 5vh; display: flex; flex-direction: row; margin-right: 2px; align-items: center;} 确定宽高的view里居中内容需要设置display: flex;，justify-content:center;，align-items: center;。1234567891011.ball { width: 30px; height:30px; margin: 2px 2px; display: flex; justify-content:center; align-items: center; border-radius: 15px; color:white; font-size: 12px;} view位于父容器底部或者叫做div位于父容器底部。父容器设置position: relative。子view设置position: absolute。如果父容器没有设置relative属性，子div（或子view）会相对于页面的底部。 CSS DIV在另一个DIV底部居中例子1234&lt;div style=&quot;min-height: 360px;position:relative;&quot;&gt; &lt;div style=&quot;position: absolute;bottom: 0px;left: 50%;transform: translate(-50%, -50%);&quot;&gt; &lt;/div&gt;&lt;div&gt;设置bottom的时候记得带单位。 动态判断背景色。idx表示下标。1&lt;view style=&quot;background:{{idx%2 == 0? '#757575':'#424242'}}&quot;&gt;五&lt;/view&gt; 动态改变文字颜色1&lt;view bindtap=&quot;onTapShowType&quot; data-type='1' style=&quot;color:{{ showLetterType == 1? '#4fa003':'#424242'}}&quot;&gt;五&lt;/view&gt; textfont-size 字体大小。font-weight 字体粗细，580左右能有粗体效果。 下划线1text-decoration: underline; scroll-view使用scroll view。12345&lt;scroll-view class='word-field' enable-back-to-top scroll-into-view=&quot;{{toView}}&quot; scroll-y=&quot;true&quot; scroll-with-animation=&quot;true&quot; &gt; &lt;view class=&quot;child-field&quot;&gt; &lt;/view&gt;&lt;/scroll-view&gt; wx:for子项方向wx:for的子项方向其实是由它的父view来决定的。 列表自动换行假设横向（row）排列子项，子项太多的时候会换到下一行。需要设置flex-flow。1234.correct-field { display: flex; flex-flow: row wrap;} css 圆角只设置一个值的话，是4个圆角。1border-radius: 4px;单位是px。如果单位用rpx，则不显示圆角。 背景半透明真机调试时，小程序设置background: #895fcce0;是无效的，看不到颜色。要使用opacity属性来设置不透明度。12background: #895fcc;opacity:0.85; 背景渐变色https://developers.weixin.qq.com/community/develop/doc/06e11913e57af653ca251462fcc134f2 css class 按条件选择1&lt;view class=&quot;{{showPage==1?'chooser.chosen':'chooser'}}&quot; &gt;sample&lt;/view&gt; 用大括号里的三目判断。 例子🌰 - 进度条和文字 需求：显示做题的进度。进度条作为背景。文字盖在上面。头尾各一个文字。123456789101112131415161718.top-bar { position: relative; height: 40px;}.pb { position: absolute; width: 100%;}.top-title-field { position: absolute; margin-left: 10px; height: 100%; align-items: center; display: flex; justify-content: center;} 123456789&lt;view class=&quot;top-bar&quot;&gt; &lt;progress class=&quot;pb&quot; stroke-width=&quot;40px&quot; activeColor=&quot;#42A5F5&quot; percent=&quot;40&quot; /&gt; &lt;view class=&quot;top-title-field&quot;&gt; &lt;text&gt;单项选择&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;progress-text&quot;&gt; &lt;text&gt;4/10&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 播放音频播放音频需要用到InnerAudioContext 播放本地文件播放本地音频。音频文件在audio目录里。audio目录和pages目录同级。先创建InnerAudioContext。并且在onLoad方法中设置监听。注意本地音频文件的路径写法，不用写相对路径，用绝对路径就好。123456789101112131415161718192021222324252627282930313233343536373839const iac = wx.createInnerAudioContext()Page({ /** * 生命周期函数--监听页面加载 */ onLoad: function(options) { this.registerAudioContext() console.log('ac ', iac) }, onTapSound: function(event) { // console.log(event) var word = event.currentTarget.id; console.log('cilck', word) iac.src = 'audio/a.mp3' iac.volume = 2 iac.loop = false iac.play() console.log('tap sound done. ') }, // 注册音频 registerAudioContext: function() { iac.onEnded((res) =&gt; { console.log('on ended', res) }) iac.onError((res) =&gt; { // 播放音频失败的回调 console.log('播放音频失败', res); }) iac.onStop((res) =&gt; { console.log('播放结束!'); }) },}) 测试发现，安卓手机播放的音频支持mp3与pepm。iPhone Xs不能播放pepm。在本地放音频文件时，小程序会提示“文件未上传”。可能是小程序编译完成需小于某个大小（2M）才能上传。那么我们把音频文件放在服务器上吧。可以使用微信云开发里的存储。上传文件后，找到文件的下载地址，https开头的。设置给iac的src。 播放网络音频找到音频文件的url，赋值给iac.src。然后播放。1iac.src = 'https://audio....' 文件系统https://developers.weixin.qq.com/miniprogram/dev/framework/ability/file-system.html 使用FileSystemManager的方法。 判断文件是否存在异步的方式判断文件是否存在。1234567891011var fs = wx.getFileSystemManager()fs.access({ path: audioDir, success(res) { console.log(audioDir, remoteDir, res) }, fail(err) { console.log(err) }}); 同步判断。如果不存在则会报错。12345try { fs.accessSync(localFilePath)} catch (t) { console.log(localFilePath, 'not exists.')} 创建目录 mkdir123456789fs.mkdir({ dirPath: audioDir, success(res) { console.log(res) }, fail(err) { console.log('Can not create dir.', audioDir, err) }}) 界面跳回上一个界面1wx.navigateBack({}) 123wx.navigateBack({ delta: 1}) 定时任务123setTimeout(function() { // 操作}, 1000) 下载微信小程序提供了下载api。 下载文件12345678910wx.downloadFile({ url: targetUrl, filePath: localFilePath, success: res =&gt; { console.log('download success') }, fail: err =&gt; { console.log('download fail',err) }}) 点击事件点击事件主要靠bindtap方法。 点击事件传递参数数据在soundRowA里面。渲染一个列表。wxml中加上data类型，这里是data-word。也可以起别的名字，但一定要data-开头。12345&lt;view wx:for=&quot;{{soundRowA}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;s&quot;&gt; &lt;view bindtap=&quot;onTapSound&quot; data-word='{{s}}'&gt; 显示一些数据 &lt;/view&gt;&lt;/view&gt; js中实现onTapSound方法。获取点击事件event。传递回来的数据是在event.currentTarget.dataset中。根据wxml中data-word，传递回来的数据的key是word。123onTapSound: function(event) { var word = event.currentTarget.dataset.word}, tabbarhttps://developers.weixin.qq.com/miniprogram/dev/extended/weui/tabbar.html 在底部，起导航作用","link":"/2019/08/10/Dev-note/dev-note-miniapp-all/"},{"title":"Android Binder 机制介绍","text":"面向对象的IPC - Binderc/s架构，客户端要找得到服务端。Binder使用Client-Server通信方式：一个进程作为Server提供诸如视频/音频解码，视频捕获，地址本查询，网络连接等服务；多个进程作为Client向Server发起服务请求，获得所需要的服务。要想实现Client-Server通信据必须实现以下两点：一是server必须有确定的访问接入点或者说地址来接受Client的请求，并且Client可以通过某种途径获知Server的地址；二是制定Command-Reply协议来传输数据。例如在网络通信中Server的访问接入点就是Server主机的IP地址+端口号，传输协议为TCP协议。对Binder而言，Binder可以看成Server提供的实现某个特定服务的访问接入点， Client通过这个‘地址’向Server发送请求来使用该服务；对Client而言，Binder可以看成是通向Server的管道入口，要想和某个Server通信首先必须建立这个管道并获得管道入口。 与其它IPC不同，Binder使用了面向对象的思想来描述作为访问接入点的Binder及其在Client中的入口。Binder是一个实体位于Server中的对象，该对象提供了一套方法用以实现对服务的请求，就象类的成员函数。遍布于client中的入口可以看成指向这个binder对象的‘指针’，一旦获得了这个‘指针’就可以调用该对象的方法访问server。在Client看来，通过Binder‘指针’调用其提供的方法和通过指针调用其它任何本地对象的方法并无区别，尽管前者的实体位于远端Server中，而后者实体位于本地内存中。‘指针’是C++的术语，而更通常的说法是引用，即Client通过Binder的引用访问Server。而软件领域另一个术语‘句柄’也可以用来表述Binder在Client中的存在方式。从通信的角度看，Client中的Binder也可以看作是Server Binder的‘代理’，在本地代表远端Server为Client提供服务。本文中会使用‘引用’或‘句柄’这个两广泛使用的术语。 Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。最诱人的是，这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。 Binder 通信模型Binder框架定义了四个角色：Server，Client，ServiceManager（以后简称SMgr）以及Binder驱动。其中Server，Client，SMgr运行于用户空间，驱动运行于内核空间。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），驱动是路由器。 Binder 驱动和路由器一样，Binder驱动虽然默默无闻，却是通信的核心。尽管名叫‘驱动’，实际上和硬件设备没有任何关系，只是实现方式和设备驱动程序是一样的：它工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作，以字符驱动设备中的misc设备注册在设备目录/dev下，用户通过/dev/binder访问该它。驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。驱动和应用程序之间定义了一套接口协议，主要功能由ioctl()接口实现，不提供read()，write()接口，因为ioctl()灵活方便，且能够一次调用实现先写后读以满足同步交互，而不必分别调用write()和read()。Binder驱动的代码位于linux目录的drivers/misc/binder.c中。 ServiceManager 与实名Binder和DNS类似，SMgr的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。注册了名字的Binder叫实名Binder，就象每个网站除了有IP地址外还有自己的网址。Server创建了Binder实体，为其取一个字符形式，可读易记的名字，将这个Binder连同名字以数据包的形式通过Binder驱动发送给SMgr，通知SMgr注册一个名叫张三的Binder，它位于某个Server中。驱动为这个穿过进程边界的Binder创建位于内核中的实体节点以及SMgr对实体的引用，将名字及新建的引用打包传递给SMgr。SMgr收数据包后，从中取出名字和引用填入一张查找表中。 ServiceManager什么时候注册的细心的读者可能会发现其中的蹊跷：SMgr是一个进程，Server是另一个进程，Server向SMgr注册Binder必然会涉及进程间通信。当前实现的是进程间通信却又要用到进程间通信，这就好象蛋可以孵出鸡前提却是要找只鸡来孵蛋。Binder的实现比较巧妙：预先创造一只鸡来孵蛋：SMgr和其它进程同样采用Binder通信，SMgr是Server端，有自己的Binder对象（实体），其它进程都是Client，需要通过这个Binder的引用来实现Binder的注册，查询和获取。SMgr提供的Binder比较特殊，它没有名字也不需要注册，当一个进程使用BINDER_SET_CONTEXT_MGR命令将自己注册成SMgr时Binder驱动会自动为它创建Binder实体（这就是那只预先造好的鸡）。其次这个Binder的引用在所有Client中都固定为0而无须通过其它手段获得。也就是说，一个Server若要向SMgr注册自己Binder就必需通过0这个引用号和SMgr的Binder通信。类比网络通信，0号引用就好比域名服务器的地址，你必须预先手工或动态配置好。要注意这里说的Client是相对SMgr而言的，一个应用程序可能是个提供服务的Server，但对SMgr来说它仍然是个Client。 Client 获得实名Binder的引用Server向SMgr注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Client也利用保留的0号引用向SMgr请求访问某个Binder：我申请获得名字叫张三的Binder的引用。SMgr收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder的引用，将该引用作为回复发送给发起请求的Client。从面向对象的角度，这个Binder对象现在有了两个引用：一个位于SMgr中，一个位于发起请求的Client中。如果接下来有更多的Client请求该Binder，系统中就会有更多的引用指向该Binder，就象java里一个对象存在多个引用一样。而且类似的这些指向Binder的引用是强类型，从而确保只要有引用Binder实体就不会被释放掉。通过以上过程可以看出，SMgr象个火车票代售点，收集了所有火车的车票，可以通过它购买到乘坐各趟火车的票-得到某个Binder的引用。 匿名 Binder并不是所有Binder都需要注册给SMgr广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向SMgr注册名字，所以是个匿名Binder。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。 下图展示了参与Binder通信的所有角色，将在后面的内容中一一提到。 Binder 内存映射和接收缓存区管理暂且撇开Binder，考虑一下传统的IPC方式中，数据是怎样从发送端到达接收端的呢？通常的做法是，发送方将准备好的数据存放在缓存区中，调用API通过系统调用进入内核中。内核服务程序在内核空间分配内存，将数据从发送方缓存区复制到内核缓存区中。接收方读数据时也要提供一块缓存区，内核将数据从内核缓存区拷贝到接收方提供的缓存区中并唤醒接收线程，完成一次数据发送。这种存储-转发机制有两个缺陷：首先是效率低下，需要做两次拷贝：用户空间-&gt;内核空间-&gt;用户空间。Linux使用copy_from_user()和copy_to_user()实现这两个跨空间拷贝，在此过程中如果使用了高端内存（high memory），这种拷贝需要临时建立/取消页面映射，造成性能损失。其次是接收数据的缓存要由接收方提供，可接收方不知道到底要多大的缓存才够用，只能开辟尽量大的空间或先调用API接收消息头获得消息体大小，再开辟适当的空间接收消息体。两种做法都有不足，不是浪费空间就是浪费时间。 Binder采用一种全新策略：由Binder驱动负责管理数据接收缓存。我们注意到Binder驱动实现了mmap()系统调用，这对字符设备是比较特殊的，因为mmap()通常用在有物理存储介质的文件系统上，而象Binder这样没有物理介质，纯粹用来通信的字符设备没必要支持mmap()。Binder驱动当然不是为了在物理介质和用户空间做映射，而是用来创建数据接收的缓存空间。先看mmap()是如何使用的： fd = open(“/dev/binder”, O_RDWR); mmap(NULL, MAP_SIZE, PROT_READ, MAP_PRIVATE, fd, 0); 这样Binder的接收方就有了一片大小为MAP_SIZE的接收缓存区。mmap()的返回值是内存映射在用户空间的地址，不过这段空间是由驱动管理，用户不必也不能直接访问（映射类型为PROT_READ，只读映射）。 接收缓存区映射好后就可以做为缓存池接收和存放数据了。前面说过，接收数据包的结构为binder_transaction_data，但这只是消息头，真正的有效负荷位于data.buffer所指向的内存中。这片内存不需要接收方提供，恰恰是来自mmap()映射的这片缓存池。在数据从发送方向接收方拷贝时，驱动会根据发送数据包的大小，使用最佳匹配算法从缓存池中找到一块大小合适的空间，将数据从发送缓存区复制过来。要注意的是，存放binder_transaction_data结构本身以及表4中所有消息的内存空间还是得由接收者提供，但这些数据大小固定，数量也不多，不会给接收方造成不便。映射的缓存池要足够大，因为接收方的线程池可能会同时处理多条并发的交互，每条交互都需要从缓存池中获取目的存储区，一旦缓存池耗竭将产生导致无法预期的后果。 有分配必然有释放。接收方在处理完数据包后，就要通知驱动释放data.buffer所指向的内存区。在介绍Binder协议时已经提到，这是由命令BC_FREE_BUFFER完成的。 通过上面介绍可以看到，驱动为接收方分担了最为繁琐的任务：分配/释放大小不等，难以预测的有效负荷缓存区，而接收方只需要提供缓存来存放大小固定，最大空间可以预测的消息头即可。在效率上，由于mmap()分配的内存是映射在接收方用户空间里的，所有总体效果就相当于对有效负荷数据做了一次从发送方用户空间到接收方用户空间的直接数据拷贝，省去了内核中暂存这个步骤，提升了一倍的性能。顺便再提一点，Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用copy_from_user()拷贝到内核空间，再用copy_to_user()拷贝到另一个用户空间。为了实现用户空间到用户空间的拷贝，mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的‘秘密’。 参考universus的专栏 - Android Binder设计与实现 - 设计篇Android AIDL简介与使用","link":"/2019/08/08/Android/Android-Binder_mechanism_intro/"},{"title":"hexo主题使用与修改","text":"添加一个小图标增加了一个更新日期类别： updated style.scss 添加一个updated，使用FontAwesome12345678910111213141516171819202122232425262728293031323334353637.post { padding: 25px 0 15px; .post-title { margin: 0; color: #555; text-align: left; font: bold 25px/1.1 &quot;ff-tisa-web-pro&quot;, Cambria, &quot;Times New Roman&quot;, Georgia, Times, sans-serif; a { color: #555; } } .post-meta { padding: 0; margin: 15px 0 0; color: #6E7173; float: left; display: inline; text-indent: .15em; &amp;:before { font-family: &quot;FontAwesome&quot;; content: &quot;\\f073&quot;; padding-right: 0.3em; } .category { &amp;:before { font-family: &quot;FontAwesome&quot;; content: &quot;\\f07c&quot;; padding-right: 0.3em; } } .updated { &amp;:before { font-family: &quot;FontAwesome&quot;; content: &quot;\\f044&quot;; padding-right: 0.3em; } } post.pug 使用span，添加updated信息12345678910111213block content .post h1.post-title= page.title .post-meta= page.date.format('ll') if page.categories.length &gt; 0 span= ' | ' span.category for category in page.categories.toArray() a(href=url_for(category.path))= category.name if page.updated span= ' | ' span.updated = page.updated.format('ll') 如果在markdown文件中不添加updated这个值，那么hexo会获取文件的修改日期，并渲染出来。 参考： Font Awesome 参考手册 https://www.runoob.com/font-awesome/fontawesome-reference.html 添加Google Adsense在head.pug中添加 123456script(src='https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js', async)script. (adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: &quot;ca-pub-7286632197002340&quot;, enable_page_level_ads: true }); 添加侧边栏添加一个微信公众号的侧边栏展示 主题layout/_widget中添加qr_code.pug1234.widget .widget-title i(class='fa fa-weixin')= ' ' + __('微信公众号') img(src='http://rustblogres.rustfisher.com/qrcode_for_rf_dev_gzh_258.jpg') _config.yml中添加 qr_code123widgets: # 前面的组建 - qr_code 更改归档界面的链接个数在工程的配置文件_config.yml里修改 123456789101112131415161718# Pagination## Set per_page to 0 to disable paginationpagination_dir: pageindex_generator: per_page: 15 order_by: -datecategory_generator: per_page: 15tag_generator: per_page: 10archive_generator: per_page: 30 yearly: true monthly: true daily: false 文章置顶及置顶标签首先更换一下generator12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 再到themes/maupassant里，查找.post-meta，并且在下面添加top的判断。12345.post-meta= post.date.format(config.date_format) if post.top span.post-top-icon i(class=&quot;fa fa-thumb-tack&quot;) span.post-meta-item-text=&quot; 置顶&quot; 在文章开头的Front-matter中加上top: true即可。 报错大括号报错md中出现形如 大括号大括号 的时候，编译会报错。 fluid主题配置leancloud评论与pv统计使用fluid，配置leancloud评论和pv的时候 检查生成的网页发现leancloud里的app_id是空的。1&quot;leancloud&quot;:{&quot;app_id&quot;:null,&quot;app_key&quot;:null,&quot;server_url&quot;:null,&quot;appid&quot;:&quot;xxx&quot;,&quot;appkey&quot;:&quot;yyy&quot;}意识到评论和pv统计在配置上不同，评论用的是appid。pv统计用的是app_id。 配置应该写成这样12345678910111213141516171819202122232425web_analytics: # 网页访问统计 enable: true leancloud: # LeanCloud 计数统计，可用于 PV UV 展示，如果 web_analytics.enable 没有开启，PV UV 展示只会查询，不会增加 app_id: xxx ## 注意这里的key写法 app_key: yyy ## 注意这里的key写法# ...# 文章的配置post: comments: enable: true type: valine meta: views: # 阅读次数 enable: true source: leancloud # 统计数据来源，可选：leancloud | busuanzi 注意不蒜子会间歇抽风 format: &quot;{} 次&quot;valine: enable: true ## if you want to use Valine comment system, please set the value to true appid: ddddd ## 注意这里的key，没有下划线 your leancloud application appid appkey: aaaaa ## 注意这里的key，没有下划线 your leancloud application appkey placeholder: 输入评论... ## comment input placeholder text avatar: 'mp' ## header image https://github.com/xCss/Valine/wiki","link":"/2019/08/06/Web/hexo-themes_use/"},{"title":"「PhoneInfo」开发记录","text":"开发过程中，一些低频使用的API不太记得，每次都要查一下。比如Build这个类。做一个app，一边显示代码，一边显示结果，岂不美哉。 发布地址 PhoneInfo - 酷安 PhoneInfo - PlayStore 页面布局ViewPager + TabLayout 承载多个fragment，显示不同的信息。 TabLayout字体大小改小一点。 style.xml里增加123456789&lt;style name=&quot;DashPageTabText&quot; parent=&quot;TextAppearance.AppCompat.Button&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;10sp&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;DashPageTabLayout&quot; parent=&quot;Widget.Design.TabLayout&quot;&gt; &lt;item name=&quot;tabTextAppearance&quot;&gt;@style/DashPageTabText&lt;/item&gt; &lt;!--&lt;item name=&quot;tabSelectedTextColor&quot;&gt;SELECTED TAB TEXT COLOR&lt;/item&gt;--&gt; &lt;!--&lt;item name=&quot;tabIndicatorColor&quot;&gt;SELECTED TAB INDICATOR COLOR&lt;/item&gt;--&gt;&lt;/style&gt; tabLayout中增加style12345&lt;com.google.android.material.tabs.TabLayout android:id=&quot;@+id/dash_page_tabs&quot; style=&quot;@style/DashPageTabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; /&gt; 参考 https://stackoverflow.com/questions/31471177/text-size-of-android-design-tablayout-tabs 或者设置选中和未选中tab时文字的颜色，设置tab可以滚动12345678&lt;com.google.android.material.tabs.TabLayout android:id=&quot;@+id/dash_page_tabs&quot; style=&quot;@style/DashPageTabLayout&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;40dp&quot; app:tabMode=&quot;scrollable&quot; app:tabSelectedTextColor=&quot;#000&quot; app:tabTextColor=&quot;#99222222&quot; /&gt; TabLayout ViewPager 联动DashPagerAdapter类。123456789101112131415161718192021222324252627282930313233import android.view.View;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentPagerAdapter;public class DashPagerAdapter extends FragmentPagerAdapter { private int fragCount; // 装着fragment public DashPagerAdapter(FragmentManager fm, int count) { super(fm); fragCount = count; } @Override public int getCount() { return fragCount; } @Override public Fragment getItem(int position) { return // 返回对应的fragment; } @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) { return super.isViewFromObject(view, object); }} onCreate里初始化12345678910111213141516171819202122232425262728293031mTabLayout = findViewById(R.id.dash_page_tabs);mViewPager = findViewById(R.id.dash_page_vp);mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Build&quot;));mTabLayout.addTab(mTabLayout.newTab().setText(&quot;Screen&quot;));mTabLayout.addTab(mTabLayout.newTab().setText(&quot;WiFi&quot;));mTabLayout.addTab(mTabLayout.newTab().setText(&quot;ext-Storage&quot;));mTabLayout.addTab(mTabLayout.newTab().setText(&quot;app-Storage&quot;));mTabLayout.addTab(mTabLayout.newTab().setText(&quot;uri&quot;));mTabLayout.addTab(mTabLayout.newTab().setText(&quot;battery&quot;));mDashPagerAdapter = new DashPagerAdapter(getSupportFragmentManager(), mTabLayout.getTabCount());mViewPager.setAdapter(mDashPagerAdapter);mViewPager.addOnPageChangeListener(new TabLayout.TabLayoutOnPageChangeListener(mTabLayout));mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() { @Override public void onTabSelected(TabLayout.Tab tab) { final int pos = tab.getPosition(); mViewPager.setCurrentItem(pos); } @Override public void onTabUnselected(TabLayout.Tab tab) { } @Override public void onTabReselected(TabLayout.Tab tab) { }}); Build类比如这样 1234567891011if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O &amp;&amp; PackageManager.PERMISSION_GRANTED == ContextCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE)) { mInfoReAdapter.addOrUpdate(K_SERIAL, &quot;Build.getSerial()&quot;, Build.getSerial());} else { mInfoReAdapter.addOrUpdate(Build.SERIAL, &quot;Build.SERIAL&quot;, Build.SERIAL);}mInfoReAdapter.addOrUpdate(&quot;Build.getRadioVersion()&quot;, &quot;Build.getRadioVersion()&quot;, Build.getRadioVersion());mInfoReAdapter.addOrUpdate(&quot;Build.ID &quot;, &quot;Build.ID&quot;, Build.ID);// ....mInfoReAdapter.addOrUpdate(&quot;Build.USER &quot;, &quot;Build.USER&quot;, Build.USER);mInfoReAdapter.notifyDataSetChanged(); 屏幕信息获取屏幕宽高。获取屏幕宽高的方法大约有3种，这里直接用view.post(runnable)的方式来获取实际宽高。 12345678910final View root = findViewById(R.id.container);root.post(new Runnable() { @Override public void run() { final int wid = root.getWidth(); final int height = root.getHeight(); Log.d(TAG, &quot;phone screen size [&quot; + wid + &quot;, &quot; + height + &quot;]&quot;); mDashPagerAdapter.setPhoneScreenSize(wid, height); }}); 把像素转换成dp 123float pxToDp(int px) { return (px / Resources.getSystem().getDisplayMetrics().density);} 存储路径信息比如获取到外部存储的路径等等。 12mInfoReAdapter.addOrUpdateUpDown(&quot;root&quot;, &quot;Environment.getRootDirectory().getAbsolutePath()&quot;, Environment.getRootDirectory().getAbsolutePath()); Uri类信息展示Uri类的一些信息。 1Uri uri = Uri.fromFile(getActivity().getApplicationContext().getFilesDir()); crash java.lang.ClassNotFoundExceptionGoogle play console 收集到的crash信息。崩溃机型是华为和三星。 Galaxy A40 (a40)， Note9 (crownlte)， A70 (a70q)， Note8 (greatlte)；Mate 10 Pro (HWBLA) 1234567891011121314151617java.lang.RuntimeException: at android.app.ActivityThread.handleReceiver (ActivityThread.java:3586) at android.app.ActivityThread.access$1300 (ActivityThread.java:240) at android.app.ActivityThread$H.handleMessage (ActivityThread.java:1808) at android.os.Handler.dispatchMessage (Handler.java:106) at android.os.Looper.loop (Looper.java:214) at android.app.ActivityThread.main (ActivityThread.java:7094) at java.lang.reflect.Method.invoke (Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run (RuntimeInit.java:494) at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:975)Caused by: java.lang.ClassNotFoundException: at dalvik.system.BaseDexClassLoader.findClass (BaseDexClassLoader.java:134) at java.lang.ClassLoader.loadClass (ClassLoader.java:379) at java.lang.ClassLoader.loadClass (ClassLoader.java:312) at android.app.AppComponentFactory.instantiateReceiver (AppComponentFactory.java:84) at androidx.core.app.CoreComponentFactory.instantiateReceiver (CoreComponentFactory.java:56) at android.app.ActivityThread.handleReceiver (ActivityThread.java:3579) 根据ActivityThread.handleReceiver猜测，有一个广播接收器示例化失败了。应用里只有一个动态注册的广播接收器。应该是注册失败了。手头上没有三星和华为。暂时没法重现。 更新记录 [1.1.4] 2020-1-7 使用新的UI样式 [1.1.1] 2019-11-10 修改电池广播接收器的信息类型 [1.0.9] 2019-9-14 修改ui [1.0.8] 2019-9-13 增加了Uri类的信息 [1.0.6] 2019-9-4 增加了Environment类的信息 修复了定位权限对Wi-Fi信息界面的影响 2019-8-17 增加了屏幕尺寸信息 采用ViewPager + TabLayout显示多个页面","link":"/2019/08/06/Dev-note/dev-note-app-PhoneInfo/"},{"title":"「SD编辑」开发记录","text":"SD - Slam Dump（并不是） 这个App的主要目的是满足广大人民群众对图片编辑的需求。 字体问题Android默认的字体不太好看，也不一定能很好地匹配背景图。如果内置字体，遇到最大的问题是版权问题。因此决定增加用户自行导入字体的功能，由用户来决定使用什么字体。 原来的字体文件是放在asset中。Typeface.createFromAsset直接引入并使用。12Typeface tf = Typeface.createFromAsset(mgr, &quot;fonts/fz_grid.ttf&quot;);mContentTv.setTypeface(tf); 设计一个字体管理界面。用户自行选择将字体文件复制到App内部存储路径。使用字体时，再用Typeface.createFromFile()获取Typeface。 选择文件调用系统文件选择器1234567891011121314151617181920212223242526272829303132private static final int REQ_CODE_CHOOSE_FILE = 10; // 启动选择文件... Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(&quot;*/*&quot;); startActivityForResult(intent, REQ_CODE_CHOOSE_FILE); // ...... // 处理选择的文件 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { switch (requestCode) { case REQ_CODE_CHOOSE_FILE: if (data != null) { Uri uri = data.getData(); Log.d(TAG, &quot;onActivityResult: uri: &quot; + uri); if (uri != null &amp;&amp; !TextUtils.isEmpty(uri.getPath())) { copyFile(uri); } else { Log.e(TAG, &quot;onActivityResult: 选择的文件无效&quot;); } } else { showShort(getApplicationContext(), &quot;没选中文件&quot;); Log.e(TAG, &quot;onActivityResult: data is NULL 没选中文件&quot;); } break; default: super.onActivityResult(requestCode, resultCode, data); break; } } 处理uriuri形如 content://com.android.externalstorage.documents/document/primary%3ADownload%2Ffz_grid.ttf uri.getPath获取到的并不是文件的绝对路径。但我们可以利用ContentResolver来获取到InputStream。也可以获取到uri的文件名。 12345678910111213141516171819202122232425262728293031323334353637383940private void copyFile(final Uri uri) { mAddIv.setClickable(false); Animation rotate = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.rotate_scan); rotate.setDuration(400); mAddIv.startAnimation(rotate); new Thread(new Runnable() { @Override public void run() { try { Cursor cursor = getContentResolver().query(uri, null, null, null, null); int nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME); cursor.moveToFirst(); String name = cursor.getString(nameIndex); cursor.close(); InputStream fis = getContentResolver().openInputStream(uri); File outputFile = new File(TypefaceStore.getStorePath(getApplicationContext()), name); if (outputFile.exists()) { boolean d = outputFile.delete(); Log.d(TAG, &quot;删除旧文件: &quot; + d); } boolean n = outputFile.createNewFile(); Log.d(TAG, &quot;copyFile: 新建文件 &quot; + n); FileOutputStream fos = new FileOutputStream(outputFile); byte[] tmp = new byte[2048]; int i; while ((i = fis.read(tmp)) != -1) { fos.write(tmp, 0, i); } fos.flush(); fos.close(); fis.close(); } catch (Exception e) { Log.e(TAG, &quot;copyFile ERROR:&quot;, e); } } }).start();} 也可以简单地使用uri.getLastPathSegment来获取文件名123uri.getLastPathSegment();String[] t = uriPath.split(File.separator);String name = t[t.length - 1]; https://stackoverflow.com/questions/4263002/how-to-get-file-name-from-uri Toolbar问题使用toolbar时经常会遇到问题。例如设置title的问题。 这里自己创建一个统一的标题栏TitleBar。想要什么控件自己添加。 Google MobileAdsMobileAds.initialize(getApplicationContext(), AdsMgr.GOOGLE_ADS_APP_ID);的执行会占用很多时间。测试过程中发现小米手机甚至使用了3秒钟来执行这个方法。 https://stackoverflow.com/questions/37418663/what-is-the-proper-way-to-call-mobileads-initialize 给启动页Activity一个纯色的启动背景。12345&lt;style name=&quot;AppTheme.NoActionBar&quot;&gt; &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorPrimary&lt;/item&gt;&lt;/style&gt; 启动页中初始化Ads时实在是耗时太长，干脆放到子线程中去操作。虽然官方文档建议的是越早初始化越好。但也不希望太影响用户体验。 递归查看某个路径下的文件12345678910111213141516 private static void treeDir(File dir, int level) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; level; i++) { sb.append(&quot;-&quot;); } sb.append(&quot; &quot;); if (dir.isDirectory()) {// LL.d(TAG, sb.toString() + dir.getName()); level++; for (File f : dir.listFiles()) { treeDir(f, level); } } else {// LL.d(TAG, sb.toString() + dir.getName()); } } 提供草稿功能为方便用户使用，提供草稿功能。这就涉及到增删查改的操作。 [2019-7-31] 本来想直接用sqlite，但为了开发方便，选用了greenDAO。 https://github.com/greenrobot/greenDAO 使用2个表，分别为Draft（存档）和DraftContent（图层）。DraftContent中存放着关联的存档ID。 能保存的东西都保存下来。 greendao插入元素1234567Draft draft1 = genDraft(&quot;示例1&quot;, p1Path);Draft draft2 = genDraft(&quot;示例2&quot;, p2Path);Draft draft3 = genDraft(&quot;示例3&quot;, p3Path);Log.d(TAG, &quot;addDemoDraft: id: &quot; + draft1.getDraftId() + &quot;,&quot; + draft3.getDraftId());daoSession.insert(draft1);daoSession.insert(draft2);daoSession.insert(draft3); 插入元素后就有id了。 greendao删除元素1234567891011DraftDao draftDao = daoSession.getDraftDao();DraftContentDao draftContentDao = daoSession.getDraftContentDao();for (Draft d : drafts) { Log.d(TAG, &quot;删除 &quot; + d.getName()); draftDao.queryBuilder() .where(DraftDao.Properties.DraftId.eq(d.getDraftId())).buildDelete() .executeDeleteWithoutDetachingEntities(); draftContentDao.queryBuilder() .where(DraftContentDao.Properties.RelativeDraftId.eq(d.getDraftId())).buildDelete() .executeDeleteWithoutDetachingEntities();} 使用DrawerLayout报错： IllegalArgumentException: No drawer view found with gravity LEFT 123java.lang.IllegalArgumentException: No drawer view found with gravity LEFT at androidx.drawerlayout.widget.DrawerLayout.openDrawer(DrawerLayout.java:1736) at androidx.drawerlayout.widget.DrawerLayout.openDrawer(DrawerLayout.java:1722) 忘记中xml中加上开抽屉方向了 tools:openDrawer=”start”12345678&lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/main_page_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.act.MainActivity&quot; tools:openDrawer=&quot;start&quot;&gt; 抽屉加上方向 android:layout_gravity=”start”1234567&lt;!-- 抽屉 --&gt;&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:layout_marginEnd=&quot;100dp&quot; android:orientation=&quot;vertical&quot;&gt; 美术设计，App交互设计设计是一个比较令我头疼的问题。在这个看脸的时代，App一定要好看！对我而言，直接采用material design的风格会比较省事。经过调整和对比，我选择使用暗色的风格。因为现在主流的图形编辑软件，颜色风格以暗色居多。 参考： 看颜色示例 https://material.io/design/color/applying-color-to-ui.html#sheets-surfaces 查颜色 https://material-ui.com/customization/color/ 文字编辑文字内容，大小，旋转方向，颜色都可以调整。 需要一个调色盘来调整颜色。找个第三方的，好看能用即可。 删除存档报错list类的经典异常 ConcurrentModificationException。 12java.util.ConcurrentModificationException at java.util.ArrayList$Itr.next(ArrayList.java:860) list删除元素时报错。这样写是不行的。12345for (Data d : dataList) { if (d.selected) { dataList.remove(d); }} 用迭代器来删除元素。1234567Iterator&lt;Data&gt; iterator = dataList.iterator();while (iterator.hasNext()) { Data data = iterator.next(); if (data.selected) { iterator.remove(); }} 输出图片保存View的显示内容获取一个view的bitmap，然后保存到文件去。 12345678910111213141516171819202122232425262728293031323334/** * 获取一个 View 的缓存视图 */private Bitmap getCacheBitmapFromView(View view) { final boolean drawingCacheEnabled = true; view.setDrawingCacheEnabled(drawingCacheEnabled); view.buildDrawingCache(drawingCacheEnabled); final Bitmap drawingCache = view.getDrawingCache(); Bitmap bitmap; if (drawingCache != null) { bitmap = Bitmap.createBitmap(drawingCache); view.setDrawingCacheEnabled(false); } else { bitmap = null; } return bitmap;}public static boolean saveBitmapFile(Bitmap bitmap, String fileAbsPath) { File file = new File(fileAbsPath); // 将要保存图片的路径 try { if (file.exists()) { file.delete(); } BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bos); bos.flush(); bos.close(); } catch (IOException e) { e.printStackTrace(); return false; } return true;} 保存图片文件后的处理用户输出图片文件后，打开微信想发送这张图片。但是用户发现微信的快捷发送功能找不到这张图片。怎么才能让微信知道这里新增了一张图片呢？ 如果要发送广播ACTION_MEDIA_MOUNTED 1sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, Uri.fromFile(outputFile))); 报错，没有足够的权限 1java.lang.SecurityException: Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED Android KK开始，这个广播开始只能由系统发出。KK及之后的版本需使用Intent.ACTION_MEDIA_SCANNER_SCAN_FILE 12File outputFile = new File(filePath);sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.fromFile(outputFile))); 参考 https://stackoverflow.com/questions/24072489/java-lang-securityexception-permission-denial-not-allowed-to-send-broadcast-an 移动TextView编辑页中有一个需求是手指拖动文字。 1.1.x版本1.1.0版本的做法是，在Activity的onTouch方法里来改变TextView的坐标。从而实现TextView的拖动效果。父View和子View设同一个OnTouchListener。但是只有父view来处理触摸事件。如果是子view接收到了触摸事件，则做一个bool标记firstOnTv = true，返回false，把触摸事件交给父view来处理。父view处理触摸事件时，判断如果刚才点中的是子view（即mContentTv），则在MotionEvent.ACTION_MOVE时更改子view的坐标。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 private View.OnTouchListener mWsOnTouchListener = new View.OnTouchListener() { boolean firstOnTv = false; // 最开始点中的是tv float originTvX; // tv最开始的坐标 float originTvY; float downX; float downY; @Override public boolean onTouch(View v, MotionEvent event) { final int id = v.getId();// Log.d(TAG, &quot;onTouch: touch tv: &quot; + (id == mContentTv.getId()) + &quot;, touch ws: &quot; + (id == mWorkspaceField.getId())); float x = event.getX(); float y = event.getY();// Log.d(TAG, &quot;onTouch: [&quot; + x + &quot;, &quot; + y + &quot;] , &quot; + event); if (event.getAction() == MotionEvent.ACTION_DOWN) { mSaveIv.setEnabled(true); if (id == mContentTv.getId()) { firstOnTv = true; originTvX = mContentTv.getX(); originTvY = mContentTv.getY();// Log.d(TAG, &quot;onTouch: 保存tv坐标 (&quot; + originTvX + &quot;, &quot; + originTvY + &quot;)&quot;); } downX = event.getX(); downY = event.getY();// Log.d(TAG, &quot;onTouch: down: x,y [&quot; + x + &quot;, &quot; + y + &quot;]&quot;); return id != mContentTv.getId(); } else if (event.getAction() == MotionEvent.ACTION_MOVE) {// Log.d(TAG, &quot;onTouch: move: x,y [&quot; + x + &quot;, &quot; + y + &quot;]&quot;); if (!firstOnTv) { return true; // 不移动tv，直接消耗掉这个操作 } float dx = x - downX; float dy = y - downY; if (Math.abs(dx) &gt; 2 &amp;&amp; Math.abs(dy) &gt; 2) { mContentTv.setX(originTvX + dx); mContentTv.setY(originTvY + dy); } return true; } else if (event.getAction() == MotionEvent.ACTION_UP) { firstOnTv = false; if (mCanvasWid &gt; 0 &amp;&amp; mCanvasHeight &gt; 0) { mDraftContent.setTvLocationXRatio(mContentTv.getX() / mCanvasWid); mDraftContent.setTvLocationYRatio(mContentTv.getY() / mCanvasHeight); } return true; } return false; } }; 版本更新 2019-8-8 v1.1.1 版本更新 解决了一些bug UI调整，增加了抽屉的头图和欢迎文字 2019-8-4 v1.1.0 版本更新","link":"/2019/07/29/Dev-note/dev-note-app-SDEdit/"},{"title":"Web tools 开发记录","text":"http://tools.rustfisher.com/ 平时开发中我们会用到一些工具，比如时间戳工具，查询ascii码，查询颜色色值等等。做一些静态网页，把这些开发者，美术常用的功能集合起来，便于大家的工作和学习。 时间戳工具http://tools.rustfisher.com/timestamp-tool.html 使用了bootstrap。颜色风格类似material design。 父div定义position: relative;，子元素可以指定位置123position: absolute;bottom: 10px;right: 10px; 时钟网页 - 用于kindlehttps://tools.rustfisher.com/clock-k1.html 结合kindle的特点，做一个时钟页面。颜色风格以黑白为主。目前的kindle没有重力传感器，考虑添加功能，用户可以让网页旋转90度。 需要将元素居中显示。这里采用的方法是flex布局。父元素设置display: flex。123456.parentMain{ margin: 0 auto; display: flex; justify-content: center; align-items: center;} 子元素的设置12&lt;div id=&quot;main&quot; class=&quot;parentMain&quot;&gt; &lt;div id=&quot;content&quot; style=&quot;display:inline-block; margin: auto; align-content: center;&quot;&gt; 配合动态调整div大小12345function autoResizeDiv(){ document.getElementById('main').style.height = window.innerHeight +'px';}window.onresize = autoResizeDiv;autoResizeDiv(); 设置display:inline-block;text-align: center;后，可以子元素水平居中显示。 旋转div点击按钮，把某个div顺时针旋转90度。这里是想把时间显示区块旋转90度。js控制css的属性，旋转div 123456789101112131415timeFieldRotateDeg = 0;function rotateTimeFieldRight() { timeFieldRotateDeg += 90; if(timeFieldRotateDeg == 360) { timeFieldRotateDeg = 0; } timeContentField = document.getElementById('timeContentField'); console.log('rotate time content field'); timeContentField.style.webkitTransform = 'rotate('+timeFieldRotateDeg+'deg)'; timeContentField.style.mozTransform = 'rotate('+timeFieldRotateDeg+'deg)'; timeContentField.style.msTransform = 'rotate('+timeFieldRotateDeg+'deg)'; timeContentField.style.oTransform = 'rotate('+timeFieldRotateDeg+'deg)'; timeContentField.style.transform = 'rotate('+timeFieldRotateDeg+'deg)'; } 参考 https://stackoverflow.com/questions/19126432/rotate-a-div-using-javascript https://stackoverflow.com/questions/14233341/how-can-i-rotate-an-html-div-90-degrees kindle适配问题bootstrap似乎并不能在kindle的浏览器上很好的工作。不采用动态计算屏幕宽高的方式。居中元素。 https://tools.rustfisher.com/clock-k2.html","link":"/2019/07/21/Dev-note/dev-note-web-tools/"},{"title":"Android OkHttp + Retrofit 取消请求的方法","text":"本文链接 前言在某一个界面，用户发起了一个网络请求，因为某种原因用户在网络请求完成前离开了当前界面，比较好的做法是取消这个网络请求。对于OkHttp来说，具体是调用Call的cancel方法。 如何找到这一个网络请求并取消掉它呢？ 操作大致分为3步。第一步，在建立请求时，给请求（request）添加标记；第二步，根据标记，找到请求；最后，取消这个请求。 OkHttp中的tag要取消一个请求，OkHttp中可以使用cancel方法，参考。 OkHttp的request对象有tag。可以根据tag来标示请求。参考Stack Overflow。 1234567891011121314151617//Set tags for your requests when you build them:Request request = new Request.Builder().url(url).tag(&quot;requestKey&quot;).build();//When you want to cancel://A) go through the queued calls and cancel if the tag matches:for (Call call : mHttpClient.dispatcher().queuedCalls()) { if (call.request().tag().equals(&quot;requestKey&quot;)) call.cancel();}//B) go through the running calls and cancel if the tag matches:for (Call call : mHttpClient.dispatcher().runningCalls()) { if (call.request().tag().equals(&quot;requestKey&quot;)) call.cancel();} Retrofit中并没有显示地提供取消请求的接口。2018年时Retrofit仍未提供直接访问call对象的方法那么如何找到目标网络请求呢？ Retrofit加入自定义header给每个与页面（Activity，Fragment）相关的request加入自定义header，参考。给OkHttpClient添加拦截器。标记出页面的生存状态。如果页面销毁了，则取消对应的request。 以GithubOnAndroid项目为例，https://github.com/RustFisher/GithubOnAndroid 添加标记持有一个ConcurrentHashMap&lt;String, Boolean&gt;来标记页面存活状态。 123456789private static ConcurrentHashMap&lt;String, Boolean&gt; actLiveMap = new ConcurrentHashMap&lt;&gt;(); // 标记Activity是否存活public static void markPageAlive(String actName) { actLiveMap.put(actName, true);}public static void markPageDestroy(String actName) { actLiveMap.put(actName, false);} Activity中登记界面状态给当前Activity起名字。每个Activity的标记名必须唯一。 123456789101112131415private static final String MY_ACT_NAME = &quot;xxx1Activity&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); NetworkCenter.markPageAlive(MY_ACT_NAME); // ... } @Override protected void onDestroy() { super.onDestroy(); NetworkCenter.markPageDestroy(MY_ACT_NAME); // ... } OkHttpClient添加拦截器给OkHttpClient添加拦截器，在拦截器中检查页面的存活情况。检查后，把这个自定义header移除掉。 12345678910111213141516171819202122232425262728 public static final String HEADER_ACT_NAME = &quot;Activity-Name&quot;; // 标记Activity界面名字 private Interceptor lifeInterceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); String actName = request.header(HEADER_ACT_NAME); if (!TextUtils.isEmpty(actName)) { Log.d(TAG, &quot;lifeInterceptor: actName: &quot; + actName); Boolean actLive = actLiveMap.get(actName); if (actLive == null || !actLive) { chain.call().cancel(); Log.d(TAG, &quot;lifeInterceptor: 取消请求, actName: &quot; + actName); } else { Log.d(TAG, &quot;lifeInterceptor: 发起请求, actName: &quot; + actName); } } Request newRequest = request.newBuilder().removeHeader(HEADER_ACT_NAME).build(); return chain.proceed(newRequest); } };OkHttpClient = new OkHttpClient.Builder() .readTimeout(10, TimeUnit.SECONDS) .connectTimeout(10, TimeUnit.SECONDS) .addInterceptor(lifeInterceptor) // 添加拦截器 .build(); call.cancel()后，不会再走Retrofit的subscribe方法。 添加header12345@GET(&quot;users/{owner}/repos&quot;)Observable&lt;List&lt;UserRepo&gt;&gt; userRepo( @Header(NetworkCenter.HEADER_ACT_NAME) @Nullable String actName, @Path(&quot;owner&quot;) String owner, @Query(&quot;sort&quot;) String sortType); 更多请参考： Android OkHttp + Retrofit 使用示例 Android OkHttp + Retrofit 取消请求的方法 Android OkHttp + Retrofit 下载文件与进度监听 Android OkHttp + Retrofit 断点续传","link":"/2019/06/26/Android/Android-OkHttp_Retrofit_cancel_request/"},{"title":"Android SparseArray 原理解析","text":"Android SparseArray 原理解析什么是SparseArray？SparseArray存储的是键值对，以int作为key，Object作为value。Sparse有稀疏、缺少的意思。SparseArray应用场景是相对稀少的数据，一般是几百以内。 SparseArray采用的数据结构？SparseArray并不像HashMap采用一维数组+单链表和二叉树结构，而是采用两个一维数组，一个是存储key(int类型),一个是存value object。 123private int[] mKeys; // 存储keyprivate Object[] mValues; // 存储value对象private int mSize; // 记录存储键值对的数量 mKeys和mValues读写时采用的下标是一一对应的。 SparseArray默认容量多大？SparseArray在默认构造函数中指定其默认容量大小。默认为10 初始化后mSize = 0，实例化mKeys和mValues。 SparseArray get方法的流程分析输入一个int型的key，通过二分法查找匹配的下标。若没找到对应的下标，则返回null或用户指定的默认对象。 key是递增存放的。二分法查找下标时，可能会返回一个负值，此时表示在mKeys中没找到对应的键。 12345678910111213141516171819public E get(int key) { return get(key, null);}/** * Gets the Object mapped from the specified key, or the specified Object * if no such mapping has been made. */@SuppressWarnings(&quot;unchecked&quot;)public E get(int key, E valueIfKeyNotFound) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); // 二分法查找下标 if (i &lt; 0 || mValues[i] == DELETED) { // 找到的下标为负或当前位置元素以被删除，表明没找到 return valueIfKeyNotFound; } else { return (E) mValues[i]; // 找到指定元素 }} SparseArray put方法的流程分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public void put(int key, E value) { // 二分法找到key的下标 int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i &gt;= 0) { // 代表当前已经存在key及其对应的值，直接替换value mValues[i] = value; } else { // 表示当前并不存在key，则应添加新的键值对 // i取反，得到要添加的数组位置下标。二叉查找返回的是key的“应当”存放的位置下标。 i = ~i; if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) { // 原来位置上的元素已经被删掉了，直接赋值替换 mKeys[i] = key; mValues[i] = value; return; } if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) { // 容量不足，进行回收操作 gc(); // 重新查找目标下标 i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); } // 目标下标为i，将key添加进mKeys数组中 mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); // 目标下标为i，将value插入mValues数组中 mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); // 已存储的数据个数加1 mSize++; }}// GrowingArrayUtils.javapublic static &lt;T&gt; T[] insert(T[] array, int currentSize, int index, T element) { assert currentSize &lt;= array.length; if (currentSize + 1 &lt;= array.length) { // 当前数组容量充足，index开始的元素后移1位 System.arraycopy(array, index, array, index + 1, currentSize - index); array[index] = element; return array; } // 容量不足，先扩容生成新的数组newArray @SuppressWarnings(&quot;unchecked&quot;) T[] newArray = ArrayUtils.newUnpaddedArray((Class&lt;T&gt;)array.getClass().getComponentType(), growSize(currentSize)); // 将原来数组index之前的部分复制到新数组对象中 System.arraycopy(array, 0, newArray, 0, index); newArray[index] = element; // 插入元素 // 将原数组index+1之后的元素拷贝到新数组中 System.arraycopy(array, index, newArray, index + 1, array.length - index); return newArray; }// 扩容计算规则，当前容量小于等于4则返回8；否则返回2倍的容量// 扩容后最小容量是8public static int growSize(int currentSize) { return currentSize &lt;= 4 ? 8 : currentSize * 2;} key下标的二叉查找方法分析二叉查找方法ContainerHelpers.binarySearch(int[] array, int size, int value)123456789101112131415161718static int binarySearch(int[] array, int size, int value) { int lo = 0; int hi = size - 1; while (lo &lt;= hi) { final int mid = (lo + hi) &gt;&gt;&gt; 1; final int midVal = array[mid]; if (midVal &lt; value) { lo = mid + 1; } else if (midVal &gt; value) { hi = mid - 1; } else { return mid; // value found } } return ~lo; // value not present} 如果没有找到输入value对应的下标，则会返回一个按位取反后的值（一般是个负值）。 例如输入array是 [1,2,4,5]，size是4，value是3；那么会得到2的取反值。而2就是value的目标位置下标。 SparseArray最大容量？每次扩容多少？SparseArray并不像HashMap一样定义有最大容量是多少，最大可以达到Integer.MAX_VALUE，可能会报oom。每次扩容时如果当前容量小于5则扩容是8，否则扩容为原容量的2倍。 123public static int growSize(int currentSize) { return currentSize &lt;= 4 ? 8 : currentSize * 2;} SparseArray与HashMap的比较，应用场景是？ SparseArray采用的不是哈希算法，HashMap采用的是哈希算法。 SparseArray采用的是两个一维数组分别用于存储键和值，HashMap采用的是一维数组+单向链表或二叉树。 SparseArray key只能是int类型，而HashMap的key是Object。 SparseArray key是有序存储（升序），而HashMap不是。 SparseArray 默认容量是10，而HashMap默认容量是16。 SparseArray 默认每次扩容是2倍于原来的容量，而HashMap默认每次扩容时是原容量*0.75倍 SparseArray value的存储被不像HashMap一样需要额外的需要一个实体类（Node）进行包装 SparseArray查找元素总体而言比HashMap要逊色，因为SparseArray查找是需要经过二分法的过程，而HashMap不存在冲突的情况其技术处的hash对应的下标直接就可以取到值。 针对上面与HashMap的比较，采用SparseArray还是HashMap，建议根据如下需求选取： 如果对内存要求比较高，而对查询效率没什么大的要求，可以是使用SparseArray 数量在百级别的SparseArray比HashMap有更好的优势 要求key是int类型的，因为HashMap会对int自定装箱变成Integer类型 要求key是有序的且是升序 参考https://www.jianshu.com/p/30a2bfb202b4","link":"/2019/04/21/Android/Android-SparseArray_src_code_note/"},{"title":"MySQL Mac 安装与简单配置","text":"homebrew安装mysql使用brew命令安装mysql1mb:~ rustfisher$ brew install mysql 启动停止mysql服务启动服务 mysql.server start安装时没有设置密码，可以直接mysql -uroot登入。12345678910111213141516171819mb:~ rustfisher$ mysql.server startStarting MySQL. SUCCESS! mb:~ rustfisher$ mysql -urootWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 9Server version: 8.0.12 HomebrewCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; exit;Bye 输入mysql指令遇到错误12mysql&gt; show database;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'database' at line 1 指令输入错误，修正一下12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 停止mysql服务的命令 mysql.server stop123mb:anindexserver rustfisher$ mysql.server stopShutting down MySQL... SUCCESS! 简单操作更改密码12mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'yourpwd';Query OK, 0 rows affected (0.05 sec) 设定了密码后，登录需要输入密码1234mb:anindexserver rustfisher$ mysql -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g. 参考： https://dev.mysql.com/doc/refman/8.0/en/resetting-permissions.html 可视化工具 mysql workbench官方文档请参考 https://dev.mysql.com/downloads/workbench/ mysql workbench 需要primary key需要有primary key才能编辑内容 https://stackoverflow.com/questions/10815029/mysql-workbench-edit-table-data-is-read-only 配置文件mac中配置文件默认路径为 /usr/local/etc/my.cnf 可以修改port。12345# Default Homebrew MySQL server config[mysqld]# Only allow connections from localhostport=9527bind-address = 127.0.0.1这里限制了连接的端口。 参考： https://www.cyberciti.biz/faq/change-default-mysql-port-under-linuxunix/","link":"/2019/02/26/Database/MySQL-install_and_config_Mac/"},{"title":"python3 发送邮件功能","text":"发信邮箱是腾讯企业邮箱。开发环境 Windows7。 主要使用smtplib来实现发邮件的功能。 简单的发送邮件功能1234567891011121314151617181920212223242526272829# 发送邮件import smtplibfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextdef send_email(): fromaddr = &quot;from1@your_email.com&quot; # 你的发件邮箱 toaddr = &quot;to1@your_email.com&quot; # 目标邮箱 msg = MIMEMultipart() msg['From'] = fromaddr msg['To'] = toaddr msg['Subject'] = &quot;SUBJECT OF THE MAIL&quot; body = &quot;YOUR MESSAGE HERE&quot; msg.attach(MIMEText(body, 'plain')) server = smtplib.SMTP('smtp.exmail.qq.com', 25) # 默认端口25 server.starttls() server.login(fromaddr, &quot;xxxx密码&quot;) text = msg.as_string() server.sendmail(fromaddr, toaddr, text) server.quit()if __name__ == '__main__': print('start sending email') send_email() print('end...') 邮件带上附件Windows下注意文件路径的表达方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 发送邮件import smtplibfrom email import encodersfrom email.mime.base import MIMEBasefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextdef send_email(from_email, pwd, target_email_list=[], attachment_file_list=[]): &quot;&quot;&quot; 单独发送邮件 create on 2018-11-14 :param from_email: 源邮箱 :param pwd: 源邮箱密码 :param target_email_list: 目标邮件列表 :param attachment_file_list: 附件路径列表 :return: void &quot;&quot;&quot; if len(target_email_list) &lt;= 0: print('ERR: 目标邮件列表为空 -&gt; 退出') return for target_email in target_email_list: print('sending to ' + target_email) msg = MIMEMultipart() msg['From'] = from_email msg['To'] = target_email msg['Subject'] = &quot;更新&quot; body = '''尊敬的客户， 你好，请查收文件。谢谢！ ''' msg.attach(MIMEText(body, 'plain')) for file_path in attachment_file_list: filename = str(file_path).split('\\\\')[-1] print(&quot;file_path &quot; + file_path + &quot; filename: &quot; + filename) attachment = open(file_path, &quot;rb&quot;) part = MIMEBase('application', 'octet-stream') part.set_payload(attachment.read()) encoders.encode_base64(part) part.add_header('Content-Disposition', &quot;attachment; filename= %s&quot; % filename) msg.attach(part) server = smtplib.SMTP('smtp.exmail.qq.com', 25) server.starttls() server.login(from_email, pwd) text = msg.as_string() server.sendmail(from_email, target_email, text) server.quit()if __name__ == '__main__': print('start sending email') send_email(from_email=&quot;your_email.com&quot;, pwd=&quot;密码&quot;, target_email_list=[&quot;target1@foxmail.com&quot;, &quot;target2@qq.com&quot;], attachment_file_list=[ r&quot;E:\\your_path.rar&quot;]) print('end...') 参考： https://blog.csdn.net/u011846143/article/details/78274911?locationNum=9&amp;fps=1 http://naelshiab.com/tutorial-send-email-python/","link":"/2018/11/14/Python/python3-send-email/"},{"title":"Flutter - 处理手势","text":"Flutter - 处理手势点击，滑动等等手势。 处理点击步骤 创建自定义button类 在其中使用GestureDetector并复写onTap回调 代码实现1234567891011121314151617181920212223import 'package:flutter/material.dart';/// 自定义buttonclass ButtonSample1 extends StatelessWidget { @override Widget build(BuildContext context) { return GestureDetector( onTap: () { final snackBar = SnackBar(content: Text(&quot;Now you tap the $this&quot;),); Scaffold.of(context).showSnackBar(snackBar); }, child: Container( padding: EdgeInsets.all(12.0), margin: EdgeInsets.all(12.0), decoration: BoxDecoration(color: Theme .of(context) .buttonColor, borderRadius: BorderRadius.circular(8.0)), child: Text(&quot;$this&quot;),), ); }} 参考： https://flutter.io/cookbook/gestures/handling-taps/ 带波纹效果的按钮使用InkWell。12345678910111213141516/// 带有波纹效果的按钮class ButtonSample2 extends StatelessWidget { @override Widget build(BuildContext context) { return InkWell( onTap: () { final snackBar = SnackBar(content: Text(&quot;Now you tap the $this&quot;),); Scaffold.of(context).showSnackBar(snackBar); }, child: Container( padding: EdgeInsets.all(12.0), child: Text(&quot;$this&quot;), ), ); }} Flutter提供的按钮控件还有RaisedButton和FlatButton。 列表侧滑删除步骤： 创建一个列表 用Dismissible包装每一个item 提供删除时的UI显示 创建列表1final items = List&lt;String&gt;.generate(10, (i) =&gt; &quot;Item $i&quot;); 创建字符串列表。这个列表不能放在build中，要定义为State的全局变量。否则删除item时，无法从view tree中移除item，从而报错。 删除时的UI设置Dismissible的background，可以在删除时显示。 示例界面代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import 'package:flutter/material.dart';/// 侧滑删除列表界面class SwipeToDismissPage extends StatefulWidget { SwipeToDismissPage({Key key}) : super(key: key); @override State&lt;StatefulWidget&gt; createState() { return SwipeState(); }}class SwipeState extends State&lt;SwipeToDismissPage&gt; { final items = List&lt;String&gt;.generate(10, (i) =&gt; &quot;Item $i&quot;); // 列表必须放在外面定义 @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text( &quot;Swipe to dismiss&quot;, ), ), body: ListView.builder( itemCount: items.length, itemBuilder: (context, index) { final item = items[index]; return Dismissible( key: Key(item), onDismissed: (direction) { setState(() { items.removeAt(index); print(direction); }); Scaffold.of(context) .showSnackBar(SnackBar(content: Text('remove $item'))); }, child: ListTile( title: Text('$item'), ), background: Container( color: Colors.red, ), ); }), ); }} 选择GestureDetector的响应形式1behavior: HitTestBehavior.opaque https://docs.flutter.io/flutter/rendering/HitTestBehavior-class.html","link":"/2018/09/06/Flutter/Flutter-Gesture_handle/"},{"title":"Flutter - 页面间跳转操作","text":"切换到一个新的界面并且能跳回来大多数App都包含多个界面。比如数据列表页和详细页。Android中的页面可以是Activity；iOS中使用ViewController。在Flutter中，页面也是widget。使用Navigator来切换页面。 步骤： 1.创建2个页面 2.用Navigator.push跳去第二个页面 3.用Navigator.pop回到第一个页面 push和pop很容易让人联想到栈。Android中有ActivityStack，用来存放Activity。当前的Activity就在栈顶。 1.创建2个页面创建2个简单的界面，界面中只有一个按钮。1234567891011121314151617181920212223242526class FirstScreen extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold(appBar: AppBar(title: Text('First page'),), body: Center(child: RaisedButton( child: Text('Go to 2nd page'), onPressed: () { print('This is first page'); // 执行想要的操作.......... }),),); }}class SecondScreen extends StatelessWidget { @override Widget build(BuildContext context) { print('${this} hashCode=${this.hashCode}'); return Scaffold(appBar: AppBar(title: Text('Second page'),), body: Center(child: RaisedButton( child: Text(&quot;Go back&quot;), onPressed: () { print('This is 2nd page'); // 执行操作........ }),),); }} 2.用Navigator.push跳转去第二个界面push方法会向栈中添加一个由Navigator管理的Route。push方法接受一个Route（暂称为路由），这里新建一个Route，使用用MaterialPageRoute。 在第一个页面中按钮添加回调的操作1234onPressed: () {Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; SecondScreen()));} 3.用Navigator.pop回到第一个界面Navigator.pop会移除navigator管理的当前的路由（效果是移除当前界面）。 12345// 第二个页面中onPressed: () { Navigator.pop(context);} 完整代码1234567891011121314151617181920212223242526272829303132333435import 'package:flutter/material.dart';void main() { runApp(new MaterialApp( title: 'navigate demo', home: new FirstScreen(),));}class FirstScreen extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold(appBar: AppBar(title: Text('First page'),), body: Center(child: RaisedButton( child: Text('Go to 2nd page'), onPressed: () { print('This is first page'); Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; SecondScreen())); }),),); }}class SecondScreen extends StatelessWidget { @override Widget build(BuildContext context) { print('${this} hashCode=${this.hashCode}'); return Scaffold(appBar: AppBar(title: Text('Second page'),), body: Center(child: RaisedButton( child: Text(&quot;Go back&quot;), onPressed: () { print('This is 2nd page'); Navigator.pop(context); }),),); }} 代码请参阅： https://github.com/RustFisher/flutter_basic","link":"/2018/09/05/Flutter/Flutter-Navigator_demo1/"},{"title":"「Learn」开发记录","text":"开发App过程中遇到的一些问题和解决办法。临时记录一些解决方案。 音频Android MediaPlayer基础。在线音频播放，使用MediaPlayer。下载在线音频到本地，使用URLConnection。 自定义ViewGroup继承自LinearLayout，自定义子View的排布方式。 crash ViewGroup.resetResolvedLayoutDirection给LinearLayout addView的时候报错12E/AndroidRuntime: at android.view.ViewGroup.resetResolvedLayoutDirection(ViewGroup.java:7291) at android.view.ViewGroup.resetResolvedLayoutDirection(ViewGroup.java:7291) 检查代码，发现addView的时候把LinearLayout自己添加进去了。12final LinearLayout wordCube = new LinearLayout(this);wordCube.addView(wordCube, chTvParams); 改成12final LinearLayout wordCube = new LinearLayout(this);wordCube.addView(tv, chTvParams); // 要加的是tv Bugly热更新Bugly热更新方案集成了腾讯的tinker，自带了补丁包发布平台。 文档 https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20181014122344#_3 tinker不支持热更新新增四大组件，不能修改Manifest文件。但是可以修改四大组件里面的逻辑。可以修改layout文件和资源文件。 Assets遍历文件assets里存放着四千多个文件，红米6A遍历一次要2秒多。 1String[] list = context.getAssets().list(&quot;folder&quot;); // 执行这一句要两千多毫秒 语音识别方案主力方案为百度语音识别。 综合价格考虑，将科大讯飞的语音听写作为备用方案。 将百度语音识别与讯飞听写的SDK一起引入到App中。由后台控制用户使用哪一个语音引擎。 下载文件项目采用的是mvvm架构。有2个页面要用到同一个数据源。把这个数据源单独抽出来，设计监听器。 原框架的下载文件功能有一个bug。如果下载时抛出了异常，也会调用success回调。这里是在下载时记录目标文件的长度，在success回调中检查本地文件大小与这个长度是否一致。 限速下载在io流那里进行延时操作。用Thread.sleep方法。阻塞的是socket的操作。 下载安装apk下载了新版本apk后，调用代码进行安装。根据手机系统版本的不同选择不同的安装方式。 12345678910111213141516public static void installApk(Context context,String downloadApk) { Intent intent = new Intent(Intent.ACTION_VIEW); File file = new File(downloadApk); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { Uri apkUri = FileProvider.getUriForFile(context, &quot;com.iNTGO.nndc.fileprovider&quot;, file); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION| Intent.FLAG_GRANT_WRITE_URI_PERMISSION); intent.setDataAndType(apkUri, &quot;application/vnd.android.package-archive&quot;); } else { Uri uri = Uri.fromFile(file); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType(uri, &quot;application/vnd.android.package-archive&quot;); } context.startActivity(intent);} 对于小米4c android 5.1.1（API 22），如果把apk放在app内部存储，packageInstaller是无法安装的。要把apk放在公共存储中才能安装。 修改Android系统镜像（img）装一个VMware Workstation Pro，下载一个Ubuntu 16的镜像（iso）。用的是阿里云的资源，比较快。一系列的mount，打包后，刷机一直不成功。找到个ROM助手，尝试一下。修改了system.img后，线刷进去，卡米（卡在开机的MI logo界面）。查一下发现，是selinux处于enforcing状态，没法装。小米4c用的是MIUI8，商家说没法root。MiUI7可以root。还没找到非root情况下关闭selinux的方法。 动画效果加一些动效会让界面更加生动有活力。 属性动画 - 星星飞行控制星星飞入，定位，飞出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 final int flyInTime = 100; final int stayTime = 520; final int flyOutTime = 250; final int totalTime = flyInTime + stayTime + flyOutTime; binding.starIv.setX(inX); binding.starIv.setY(yStay); binding.starIv.setVisibility(View.VISIBLE); setStarIvSize(0, 0); final ValueAnimator animator = ValueAnimator.ofInt(1, totalTime); animator.setDuration(totalTime); animator.setInterpolator(new AccelerateInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator valueAnimator) { int value = (int) valueAnimator.getAnimatedValue(); ImageView starIv = binding.starIv; if (value &lt; flyInTime) { float inProgress = value / (1.0f * flyInTime); float x = inProgress * (xStay - inX) + inX; float y; if (value &lt; flyInTime / 2) { y = yStay + 20 - inProgress * 60; } else { y = yStay - 20 + inProgress * 60; } starIv.setX(x); starIv.setY(y); setStarIvSize((int) (mStarIvOriginWid * (inProgress)), (int) (mStarIvOriginHeight * (inProgress)));// Log.d(TAG, &quot;onAnimationUpdate: value: &quot; + value + &quot;, progress: &quot; + inProgress + &quot;, x: &quot; + x); } else if (value &lt; flyInTime + stayTime) { starIv.setX(xStay); starIv.setY(yStay); setStarIvSize(mStarIvOriginWid, mStarIvOriginHeight); } else { if (valueAnimator.isRunning()) { float progress = (value - flyInTime - stayTime) / (1.0f * flyOutTime); starIv.setX(xStay + (progress * Math.abs(endX - xStay))); starIv.setY(yStay - (progress * Math.abs(endY - yStay))); setStarIvSize((int) (mStarIvOriginWid * (1 - progress)), (int) (mStarIvOriginHeight * (1 - progress))); } } if (value &gt;= totalTime - 10) { binding.starIv.setVisibility(View.GONE); } } }); animator.start(); // 改变星星ImageView的大小，LayoutParams不能弄错了 private void setStarIvSize(int wid, int height) { RelativeLayout.LayoutParams lp = (RelativeLayout.LayoutParams) binding.starIv.getLayoutParams(); lp.width = wid; lp.height = height; binding.starIv.setLayoutParams(lp); } 如果一个View在LinearLayout里，它的坐标没有那么容易获取。 下面的代码获取到的坐标是[0,0]。1234567imageView.post(new Runnable() { @Override public void run() { int[] location = new int[2]; imageView.getLocationOnScreen(location); }}); 创建自定义过渡动画 - Google自动为布局更新添加动画 - Google 退出App在登录界面，点击返回键即退出整个App。 123456789101112131415private boolean mExitApp = false; @Override public void onBackPressed() { super.onBackPressed(); mExitApp = true; } @Override protected void onDestroy() { super.onDestroy(); if (mExitApp) { System.exit(0); } } crash为了提高程序的健壮性，很多时候并不能过于相信服务器返回的结果。该加判空就判空。如果服务器返回空的数据或者字段，要有对应的措施。 gc超时该异常表示调用超时。 解决方案：一般是系统在gc时，调用对象的finalize超时导致 解决办法：1.检查分析finalize的实现为什么耗时较高，修复它；2.检查日志查看GC是否过于频繁，导致超时，减少内容开销，防止内存泄露。 123456789101112android.content.res.XmlBlock$Parser.finalize() timed out after 10 secondsandroid.content.res.AssetManager.xmlBlockGone(AssetManager.java:500)android.content.res.AssetManager.xmlBlockGone(AssetManager.java:500)android.content.res.XmlBlock.decOpenCountLocked(XmlBlock.java:63)android.content.res.XmlBlock.access$1600(XmlBlock.java:34)android.content.res.XmlBlock$Parser.close(XmlBlock.java:448)android.content.res.XmlBlock$Parser.finalize(XmlBlock.java:454)java.lang.Daemons$FinalizerDaemon.doFinalize(Daemons.java:191)java.lang.Daemons$FinalizerDaemon.run(Daemons.java:174)java.lang.Thread.run(Thread.java:818) RuntimeException: Cannot create an instance of class使用了MVVM的框架，创建viewModel时报错。检查发现忘记复写方法initViewModel。12345@Overridepublic MyViewModel initViewModel() { MyAppViewModelFactory factory = MyAppViewModelFactory.getInstance(getApplication()); return ViewModelProviders.of(this, factory).get(MyViewModel.class);} ANR死循环导致的ANR之前业务逻辑中，有一个随机添加不重复字符串的功能。12345678while (needCheckList.size() &lt; 3) { Random rd = new Random(); String word = wordList.get(rd.nextInt(wordList.size())); if(!needCheckList.contains(word)) { needCheckList.add(word); } // .....}这段代码的效率不高。伪随机数不能保证高效地不重复地取到新的下标。在某些性能较差的手机上，陷入多次循环后有可能导致anr。 anr message 表明此时CPU占用率超过100%。我们使用Collections.shuffle(wordList);来代替伪随机数，也能实现随机取出字符串的效果。提高健壮性。 gradle想在Terminal里使用gradlew命令，还得先在电脑上安装jdk。现在（2019-11-18）想在官网下载个jdk，还得登录oracle账号。网速很慢，去别的地方下载jdk-8u181-windows-x64。 多渠道自动打包假设我们有很多种渠道，每个渠道的manifestPlaceholders的内容都不同。123456productFlavors { xxx { manifestPlaceholders = [XX_ID : &quot;123&quot;, XX_KEY : &quot;key_key&quot;] }} 之前渠道少的时候，可以点击gradle task一个个来打包。现在渠道种类多了（比如二十多个），再一个个点击就很累。想要一键打包或者一行命令打包，有什么成熟好用的多渠道打包方式呢？我们尝试了美团点评的walle，号称是Android Signature V2 Scheme签名下的新一代渠道包打包神器。试着接入walle的姿势可能不对，打包不成功。此时看到有人说不支持多渠道不同的包名和配置manifestPlaceholders，暂时先不使用walle。 已经使用了Bugly，有很多形如assembleXxxRelease的任务。我们可以在终端命令行里执行gradlew命令来打包。Windows环境下就是1gradlew assembleXxxRelease 那么写一个bat脚本，把这几十个渠道包按顺序一个个打包出来。1gradlew assembleXxxRelease &amp;&amp; gradlew assembleYyyRelease &amp;&amp; gradlew assembleZzzRelease这个方法非常“暴力”，仅仅是替代了手动执行的过程。 框架BindingCommand 问题由于历史原因，App使用了一个MVVM框架。layout中可以绑定BindingCommand。不知道是不是开发姿势不对，快速点击某个按钮时，对应的BindingCommand并不能立即响应。连续点击会错过点击事件。123456public BindingCommand myCommand = new BindingCommand(new BindingAction() { @Override public void call() { // my logic }}); 而换用setOnClickListener可以立刻监听到每一个点击事件。为了追求响应速度，在某些地方采用设置监听器的方式了。 界面UIandroid 跑马灯重复抖动的解决方法解决的方法，在跑马灯控件外层，再嵌套一个布局控件。 12345678910111213141516171819&lt;LinearLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;55&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;com.rustfisher.view.MarqueeTextView android:id=&quot;@+id/tv_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;marquee&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:maxWidth=&quot;150dp&quot; android:singleLine=&quot;true&quot; android:text=&quot;&quot; android:textSize=&quot;10sp&quot; /&gt;&lt;/LinearLayout&gt; EditText划词选词弹出菜单et可选，弹出了系统的菜单。 et不可选，弹出了自定义的菜单。12345678registerForContextMenu(mEt);mEt.setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() { @Override public void onCreateContextMenu(final ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) { Log.d(TAG, &quot;onCreateContextMenu: selected: &quot; + mEt.getSelectionStart() + &quot;, &quot; + mEt.getSelectionEnd()); // 都是0 getMenuInflater().inflate(R.menu.et_menu, menu); }}); et可选，弹出了自定义菜单。123456789101112131415161718192021222324252627282930313233mEt.setCustomSelectionActionModeCallback(genActionModeCallback1());private ActionMode.Callback genActionModeCallback1() { return new ActionMode.Callback() { @Override public boolean onCreateActionMode(ActionMode mode, Menu menu) { Log.d(TAG, &quot;onCreateActionMode:&quot; + &quot; selected: &quot; + mEt.getSelectionStart() + &quot;, &quot; + mEt.getSelectionEnd()); return true; } @Override public boolean onPrepareActionMode(ActionMode mode, Menu menu) { Log.d(TAG, &quot;onPrepareActionMode: &quot; + &quot; selected: &quot; + mEt.getSelectionStart() + &quot;, &quot; + mEt.getSelectionEnd()); menu.clear(); mode.getMenuInflater().inflate(R.menu.et_menu, menu); return true; } @Override public boolean onActionItemClicked(ActionMode mode, MenuItem item) { Log.d(TAG, &quot;onActionItemClicked: &quot; + &quot; selected: &quot; + mEt.getSelectionStart() + &quot;, &quot; + mEt.getSelectionEnd()); mode.finish(); return false; } @Override public void onDestroyActionMode(ActionMode mode) { Log.d(TAG, &quot;onDestroyActionMode: &quot; + &quot; selected: &quot; + mEt.getSelectionStart() + &quot;, &quot; + mEt.getSelectionEnd()); } };}1+手机可以用，但小米手机无法弹出自定义菜单。此法不能通用。 竖直的进度条https://stackoverflow.com/questions/3926395/android-set-a-progressbar-to-be-a-vertical-bar-instead-of-horizontal 获取statusbar高度在Activity中获取DecorView。通过DecorView的位置来判断statusBar的高度。Activity别设置成全屏的就好。 123456private void getStatusBarHeight() { Rect rectangle = new Rect(); Window window = getWindow(); window.getDecorView().getWindowVisibleDisplayFrame(rectangle); Log.d(TAG, &quot;getStatusBarHeight: &quot; + rectangle.top);} 让statusbar不占位置，并设置成透明背景。底下的虚拟系统按键（Home，back，menu）不能受影响。12345&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt; drawable - vector assets通过引入svg文件得到的drawable，layout中直接设置src使用drawable。小米4c和红米6A手机屏幕上图像错乱。改变ImageView的大小不起作用。清楚as缓存也不起作用。 如果不在layout中设置，而是在代码中setImageResource则显示正常。 设计界面去花瓣网上找灵感。比如设计列表界面，可以给每个项目增加一个小背景。可以是颜色，可以是背景图。 网络请求设计接口获取数据项目里用OKHttp框架来进行网络请求。返回结果被转化成对象Entity。同一个服务器返回里装有相同结构的A,B,C对象。它们的名字不一样，GsonFormat的时候是分开成3个类的。为了让代码更简洁，把这3个对象进行抽象。一开始是做了一个抽象类，让这3个类继承。但是OKHttp那边会报错。 然后改用了接口的方式。设计的接口里有一些通用方法。在Entity里让那3个类都实现这个接口，然后在方法中返回我们要的数据。 AsyncTask资源分配AsyncTask背后有一个线程池。调用了execute()并不能保证任务立刻被执行。换用Thread。 App设置分屏设置如果不进行设置，默认是允许分屏的。这里我们把分屏给禁止。12android:networkSecurityConfig=&quot;@xml/network_security_config&quot;android:resizeableActivity=&quot;false&quot; 添加在application标签里。1234567&lt;application android:name=&quot;.app.MyApplication&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:networkSecurityConfig=&quot;@xml/network_security_config&quot; android:theme=&quot;@style/AppTheme&quot;&gt; adb系统App把apk放进root后的手机里，当做是系统app。 1234567891011F:\\IE\\MyApp0826\\app\\libs&gt;adb rootF:\\IE\\MyApp0826\\app\\libs&gt;adb remountremount succeededF:\\IE\\MyApp0826\\app\\libs&gt;adb shell mkdir /system/priv-app/MyAppF:\\IE\\MyApp0826\\app\\libs&gt;adb shell chmod 755 /system/priv-app/MyAppF:\\IE\\MyApp0826\\app\\libs&gt;adb shell chmod 644 /system/priv-app/MyApp/MyApp.apkF:\\IE\\MyApp0826\\app\\libs&gt;adb shell chmod 755 /system/priv-app/MyApp/libF:\\IE\\MyApp0826\\app\\libs&gt;adb shell chmod 755 /system/priv-app/MyApp/lib/armF:\\IE\\MyApp0826\\app\\libs&gt;adb shell syncF:\\IE\\MyApp0826\\app\\libs&gt;adb shell reboot 范围内随机数12Random rand = new Random(seed);int random_integer = rand.nextInt(upperbound-lowerbound) + lowerbound; 内存泄漏Handler与单例单例模式加上Handler。有人把handler直接交给单例。长生命周期的一直持有短生命周期的对象，没法回收造成内存泄漏。 viewModel中有一个handler，而handler被单例持有。handler是直接实例化的。123456aHandler = new Handler() { @Override public void handleMessage(@NonNull Message msg) { handleResult(msg); }};handleResult方法中使用了viewModel的数据列表。 这样在新建一个viewModel的时候，单例持有旧的handler，handler持有的还是旧的那个数据列表。内存中就有2份不一样的数据列表。 修复方案：首先不能让单例持有这个handler。其次退出viewModel的时候，把handler中的消息清空。","link":"/2018/09/01/Dev-note/dev-note-app-learn/"},{"title":"Android OkHttp + Retrofit 使用示例","text":"本文链接 OkHttp + Retrofit使用示例。从引入依赖，编写接口，到发起网络请求。 https://github.com/square/okhttp 简单使用引入依赖引入依赖，使用Retrofit2。123implementation 'com.squareup.retrofit2:retrofit:2.1.0'implementation 'com.squareup.retrofit2:converter-gson:2.1.0'implementation 'com.squareup.retrofit2:adapter-rxjava:2.1.0' 查询 @Query例如URL https://base_url/backend-service/config?env=dev，问号后面属于查询内容。不论是GET或POST，都要用@Query这个注解。否则会报异常。 URL填充与拼接单纯URL填充可以用@Path注解。例如下面这个post请求。12@POST(&quot;user-service/user/{uid}/token/refresh&quot;)Call&lt;RefreshTokenResp&gt; refreshToken(@Path(&quot;uid&quot;) String uid, @Query(&quot;token&quot;) String token); GET带有查询的参数12345public interface CfgService { @GET(&quot;backend-service/config&quot;) Call&lt;ServerCfgResp&gt; getServerCfg(@Query(&quot;env&quot;) String env);} POST，带有查询的参数和body123456789public interface UserService { @POST(&quot;user-service/login&quot;) Call&lt;LoginResp&gt; login(@Query(&quot;lenovoST&quot;) String token, @Query(&quot;realm&quot;) String realm, @Body RequestBody body); @POST(&quot;user-service/logout&quot;) Call&lt;CommonEntity&gt; logout(@Query(&quot;token&quot;) String token, @Body RequestBody body);} 调用的时候要创建RequestBody；先调查好后台接受的body类型。1234567Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;system&quot;, &quot;Android&quot;);map.put(&quot;phoneBrand&quot;, Build.BRAND);map.put(&quot;modelNum&quot;, Build.MODEL);Gson gson = new Gson();String bodyJson = gson.toJson(map);RequestBody requestBody = RequestBody.create(MediaType.parse(&quot;application/json&quot;), bodyJson); 初始化OkHttpClient；这里信任所有的SSL证书（正式环境不建议这么做）。12345678910111213141516171819202122232425262728293031private CfgService cfgService; public void initService() { SSLSocketFactory sslSocketFactory = null; try { sslSocketFactory = SSLUtils.getSSLSocketFactory(); } catch (Exception e) { e.printStackTrace(); } OkHttpClient.Builder builder = new OkHttpClient.Builder(); if (sslSocketFactory != null) { Log.d(TAG, &quot;sslSocketFactory != null&quot;); builder.sslSocketFactory(sslSocketFactory); } else { Log.w(TAG, &quot;sslSocketFactory == null&quot;); } builder.hostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; // 强制返回true } }); OkHttpClient lenClient = builder.build(); Retrofit retrofit = new Retrofit.Builder() .baseUrl(ServerCfg.HOST_URL) .client(lenClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); cfgService = retrofit.create(CfgService.class); } 调用网络请求1234567891011mNetworkManager.getUserApi().login(mLenovoToken, ServerCfg.RID, requestBody).enqueue(new Callback&lt;LoginResp&gt;() { @Override public void onResponse(Call&lt;LoginResp&gt; call, final Response&lt;LoginResp&gt; response) { //... } @Override public void onFailure(Call&lt;LoginResp&gt; call, final Throwable t) { //... } }); 信任所有服务器的ssl并不推荐这么做 12345678910111213141516171819202122232425262728293031323334353637public class SSLUtils { /** * @return 信任所有服务器 */ public static SSLSocketFactory getSSLSocketFactory() throws Exception { SSLSocketFactory sslSocketFactory = null; SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); sslContext.init(null, new TrustManager[]{createTrustAllManager()}, new SecureRandom()); sslSocketFactory = sslContext.getSocketFactory(); return sslSocketFactory; } public static X509TrustManager createTrustAllManager() { X509TrustManager tm = null; try { tm = new X509TrustManager() { public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { //do nothing，接受任意客户端证书 } public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { //do nothing，接受任意服务端证书 } public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } }; } catch (Exception e) { } return tm; }} service使用io.reactivex.Observable1234567891011121314import io.reactivex.Observable; // 这个是rx2的包// --- /** * 用户反馈接口 * * @param content 用户输入的反馈内容 */ @POST(&quot;feedbackAction&quot;) Observable&lt;UserFeedback&gt; userFeedback(@Query(&quot;appVersion&quot;) String appVersion, @Query(&quot;phoneModel&quot;) String phoneModel, @Query(&quot;phoneOsVersion&quot;) String osVersion, @Query(&quot;submitContent&quot;) String content); 示例1 - Retrofit2，RxJava2引入依赖12345implementation 'com.squareup.retrofit2:retrofit:2.5.0'implementation 'com.squareup.retrofit2:converter-gson:2.5.0'implementation 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'implementation 'io.reactivex.rxjava2:rxjava:2.2.8' 定义interface1234567891011121314151617181920212223242526272829303132333435363738import java.util.Map;import io.reactivex.Observable;import retrofit2.http.Field;import retrofit2.http.FieldMap;import retrofit2.http.FormUrlEncoded;import retrofit2.http.GET;import retrofit2.http.POST;import retrofit2.http.Query;/** * RustDrone后台接口 * Created on 2019-5-17 */public interface RustDroneCommonService { /** * 用户反馈接口 * * @param content 用户输入的反馈内容 */ @FormUrlEncoded @POST(&quot;feedbackAction&quot;) Observable&lt;FeedbackResp&gt; userFeedback(@Field(&quot;appVersion&quot;) String appVersion, @Field(&quot;phoneModel&quot;) String phoneModel, @Field(&quot;phoneOsVersion&quot;) String osVersion, @Field(&quot;submitContent&quot;) String content, @FieldMap Map&lt;String, String&gt; map); /** * 获取手机验证码 * * @param mobile 手机号 */ @GET(&quot;verifyCode&quot;) Observable&lt;PhoneCodeResp&gt; getPhoneCode(@Query(&quot;mobile&quot;) String mobile, @Query(&quot;oprType&quot;) int type);} 调用接口12345678910111213141516171819202122232425262728293031323334353637383940import io.reactivex.Observer;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.disposables.Disposable;import io.reactivex.schedulers.Schedulers;RustDroneDataCenter.getCenter().getCommonService().userFeedback(BuildConfig.VERSION_NAME, Build.MODEL.replace(&quot; &quot;, &quot;-&quot;), Build.VERSION.RELEASE, fd, ext) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;FeedbackResp&gt;() { @Override public void onSubscribe(Disposable d) {// LL.dn(TAG, &quot;onSubscribe: &quot; + d); } @Override public void onNext(FeedbackResp feedbackResp) { LL.dn(TAG, &quot;onNext: &quot; + feedbackResp); if (feedbackResp.getCode() == 0) { popSubmitSuccessDialog(); } else { LL.e(&quot;上传用户反馈失败&quot;); mPbLayout.setVisibility(View.GONE); popRetryDialog(); } } @Override public void onError(Throwable e) { LL.e(&quot;上传用户反馈失败 code: &quot; + e); mPbLayout.setVisibility(View.GONE); popRetryDialog(); } @Override public void onComplete() { mPbLayout.setVisibility(View.GONE); LL.dn(TAG, &quot;onComplete: 上传结束&quot;); } }); GithubOnAndroid示例代码地址： https://github.com/RustFisher/GithubOnAndroid 添加拦截器定义拦截器12345678// 仅仅是示例，不做任何处理private Interceptor doNothingInterceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Log.d(TAG, &quot;Interceptor1: intercept&quot;); return chain.proceed(chain.request()); }}; 添加拦截器12345678910111213141516171819OkHttpClient okHttpClient = new OkHttpClient.Builder() .readTimeout(10, TimeUnit.SECONDS) .connectTimeout(10, TimeUnit.SECONDS) .addInterceptor(doNothingInterceptor) // 添加拦截器 .addInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Log.d(TAG, &quot;Interceptor2: intercept&quot;); return chain.proceed(chain.request()); } }) .addNetworkInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Log.d(TAG, &quot;NetworkInterceptor1: intercept&quot;); return chain.proceed(chain.request()); } }) .build(); 拦截器中增加header操作chain中的request。 1234567891011// 添加一些公共参数private Interceptor RustDroneInterceptor = new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request().newBuilder() .addHeader(&quot;token&quot;, UserCenter.getToken()) .build(); return chain.proceed(request); }}; 更多请参考： Android OkHttp + Retrofit 使用示例 Android OkHttp + Retrofit 取消请求的方法 Android OkHttp + Retrofit 下载文件与进度监听 Android OkHttp + Retrofit 断点续传","link":"/2018/08/22/Android/Android-OkHttp_Retrofit_use_intro/"},{"title":"「drone」开发记录","text":"斜体文字被切掉了一块TextView.setText的时候在右边加上一个空格。 或者string.xml中添加&amp;#x200A;来占位。 1&lt;string name=&quot;dp_page_ready&quot;&gt;READY&amp;#x200A;&lt;/string&gt; 或者在TextView.setText的时候加上一个空格。 动态给LinearLayout添加子View一列27个自定义view，如果要写到xml里就太麻烦了。在Java代码中新建子View，设置LayoutParams，然后添加到LinearLayout里。 123456789101112131415161718192021222324252627282930313233343536373839404142private void initGrids() { final int bigGridHeightPx = (int) dpToPx(10); final int bigGrid2MarginVerticalPx = (int) dpToPx(3); final int smallGridHeightPx = (int) dpToPx(6); // 这里有27个格点 final int smallGridMarginBotPx = (int) dpToPx(1); LinearLayout linearLayoutLeft1 = findViewById(R.id.dp_page_g_field_left1); LinearLayout linearLayoutLeft2 = findViewById(R.id.dp_page_g_field_left2); mLeftGridList = new ArrayList&lt;&gt;(); GridsHorView g1 = new GridsHorView(this); GridsHorView g2 = new GridsHorView(this); GridsHorView g3 = new GridsHorView(this); LinearLayout.LayoutParams p1 = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, bigGridHeightPx); LinearLayout.LayoutParams p2 = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, bigGridHeightPx); p2.setMargins(0, bigGrid2MarginVerticalPx, 0, bigGrid2MarginVerticalPx); linearLayoutLeft1.addView(g1, p1); linearLayoutLeft1.addView(g2, p2); linearLayoutLeft1.addView(g3, p1); mLeftGridList.addAll(Arrays.asList(g1, g2, g3)); for (int i = 0; i &lt; 27; i++) { GridsHorView smallGrid = new GridsHorView(this); smallGrid.setAlphaValue((int) (255 * (1 - 0.02 * i))); LinearLayout.LayoutParams sp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, smallGridHeightPx); sp.setMargins(0, 0, 0, smallGridMarginBotPx); mLeftGridList.add(smallGrid); linearLayoutLeft2.addView(smallGrid, sp); } for (GridsHorView g : mLeftGridList) { g.setOri(GridsHorView.Ori.RIGHT_TO_LEFT); g.disableMode(); g.setCubeCount(1); } // 初始化右边（P2）的格子...}private float dpToPx(float dp) { return dp * getResources().getDisplayMetrics().density;} 获取当前WiFi的名字需要定位权限。 1234567891011121314public static String getWiFiName(Context context) { String wifiId = &quot;WIFI_NAME_NOT_FOUND&quot;; try { WifiManager wifiMgr = (WifiManager) context.getSystemService(Context.WIFI_SERVICE); WifiInfo info = wifiMgr.getConnectionInfo(); wifiId = info != null ? info.getSSID() : null; } catch (Exception e) { e.printStackTrace(); } if (!TextUtils.isEmpty(wifiId) &amp;&amp; wifiId.startsWith(&quot;\\&quot;&quot;)) { wifiId = wifiId.substring(1); // 删去前面那个引号 } return wifiId;} 这个方法适用于判断WiFi名称的前缀。 检查权限的方法12345678910111213141516protected void checkPermission(String[] permissions, final int reqCode) { List&lt;String&gt; perList = new ArrayList&lt;&gt;(); for (String p : permissions) { if (PackageManager.PERMISSION_GRANTED != ContextCompat.checkSelfPermission(this, p)) { LL.e(&quot;没有权限: &quot; + p); perList.add(p); } } if (!perList.isEmpty()) { String[] per = new String[perList.size()]; for (int i = 0; i &lt; per.length; i++) { per[i] = perList.get(i); } ActivityCompat.requestPermissions(this, per, reqCode); }} 设置Click监听器应用在Activity中，给一堆view设置同一个监听器 123456789101112// 设置点击监听器protected void setOnClickListeners(View.OnClickListener l, View... views) { for (View v : views) { v.setOnClickListener(l); }}protected void setOnClickListeners(View.OnClickListener l, int... resIds) { for (int r : resIds) { findViewById(r).setOnClickListener(l); }} 设置字体先把字体加载好。 1234567891011protected void setTvPangMenAndItalic(int... tvResIds) { for (int i : tvResIds) { ((TextView) findViewById(i)).setTypeface(AppControl.getPangMenTf(), Typeface.ITALIC); }}protected void setTvPangMenAndItalic(TextView... tvs) { for (TextView t : tvs) { t.setTypeface(AppControl.getPangMenTf(), Typeface.ITALIC); }} 收起软键盘12345678void hideSoftKeyboard() { try { InputMethodManager inputMgr = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); inputMgr.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } catch (Exception e) { LL.e(&quot;rustApp&quot;, e); }} 判断网络是否有连接1234567891011121314151617protected boolean isNetworkAvailable(Context context) { ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (connectivity == null) { return false; } else { NetworkInfo[] info = connectivity.getAllNetworkInfo(); if (info != null) { for (NetworkInfo anInfo : info) { if (anInfo.getState() == NetworkInfo.State.CONNECTED) { return true; } } } } return false;} 判断某个App是否安装获取PackageManager通过包名来判断某个App是否安装。但是有的手机在获取PackageManager的时候就能抛出异常。12345678910protected boolean appInstalledOrNot(String uri) { try { PackageManager pm = getPackageManager(); pm.getPackageInfo(uri, PackageManager.GET_ACTIVITIES); return true; } catch (Exception e) { LL.e(&quot;appInstalledOrNot: &quot; + uri, e); } return false;} 总而言之这并不是个很好的办法。 性能优化一些性能优化的处理措施和思考。 给UI线程更多的CPU资源数据库的操作放在子线程中进行。数据库线程也可能会和UI线程争抢CPU的时间片。假设数据库要删除大量数据（比如1万条）。那么我们可以尝试在数据库处理了某个数量（例如1千）的操作后，sleep一下，给UI线程让出CPU时间。但现在一般都是多核手机，具体效果有待考量。 log记录工具把log写到文件里。用RandomAccessFile与MappedByteBuffer写日志到文件中。任务处理放在子线程中，由HandlerThread来管理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250public class LL { public static abstract class Level { public static final String D = &quot;D&quot;; // 普通debug public static final String W = &quot;W&quot;; // 警告 public static final String E = &quot;E&quot;; // 错误 } private static String defTag = &quot;App&quot;; private static boolean showLogcat = true; private static boolean writeFile = true; // 注意申请SD卡读写权限 private static String logFileDir = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;rust&quot; + File.separator + &quot;logs&quot;; private static String fileName; private static List&lt;LogListener&gt; listenerList = new ArrayList&lt;&gt;(); private static HandlerThread handlerThread; private static Handler writerHandler; private static final int LOG_FILE_GROW_SIZE = 1024 * 10; // log文件每次增长的大小 private static long gCurrentLogPos = 0; // log文件当前写到的位置 - 注意要单线程处理 /** * 使用前必须调用此方法进行准备 * * @param context 建议传入applicationContext * @param fileDir 存放log文件的目录 */ public static void prepare(Context context, @NonNull String fileDir, String logFilePrefix) { gCurrentLogPos = 0; if (TextUtils.isEmpty(fileDir)) { if (Environment.getExternalStorageState().equals( Environment.MEDIA_MOUNTED)) { logFileDir = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + &quot;rust&quot; + File.separator + &quot;logs&quot;; } else { logFileDir = context.getFilesDir().getAbsolutePath() + File.separator + &quot;rust&quot; + File.separator + &quot;logs&quot;; } } else { logFileDir = fileDir; } if (null == handlerThread) { handlerThread = new HandlerThread(&quot;LL&quot;); handlerThread.start(); } writerHandler = new Handler(handlerThread.getLooper()); fileName = logFilePrefix + &quot;_&quot; + System.currentTimeMillis() + &quot;.txt&quot;; Log.d(defTag, &quot;[prepare] file: &quot; + fileName); } public static String getLogFileDir() { return logFileDir; } public static String getFileName() { return fileName; } // 退出 public static void quit() { if (writerHandler != null) { writerHandler.removeCallbacksAndMessages(null); } if (handlerThread != null) { handlerThread.quit(); } } public static void setDefTag(String t) { LL.defTag = t; } public static void setWriteFile(boolean w) { LL.writeFile = w; } public static void d(String content) { d(defTag, content, writeFile); } public static void d(String tag, String content) { d(tag, content, writeFile); } public static void dn(String content) { d(defTag, content, false); } // 不写到文件中 public static void dn(String tag, String content) { d(tag, content, false); } public static void d(String tag, String content, boolean write) { if (showLogcat) { Log.d(tag, content); } tellLog(Level.D, tag, content); if (write) { if (writerHandler != null) { writerHandler.post(new WriteRunnable(tag, content)); } } } // log级别 WARN - w public static void w(String content) { w(defTag, content, writeFile); } public static void w(String tag, String content) { w(tag, content, writeFile); } // 不写到文件中 public static void wn(String content) { w(defTag, content, false); } // 不写到文件中 public static void wn(String tag, String content) { w(tag, content, false); } public static void w(String tag, String content, boolean write) { if (showLogcat) { Log.w(tag, content); } tellLog(Level.W, tag, content); if (write) { if (writerHandler != null) { writerHandler.post(new WriteRunnable(tag, content)); } } } public static void e(String content) { e(defTag, content); } public static void e(String tag, String content) { e(tag, content, writeFile); } public static void e(String tag, Exception e) { e(tag, e.getMessage(), writeFile); } // 只打log 不写文件 public static void en(String tag, String content) { e(tag, content, false); } public static void e(String tag, String content, boolean write) { if (showLogcat) { Log.e(tag, content); } tellLog(Level.E, tag, content); if (write) { if (writerHandler != null) { writerHandler.post(new WriteRunnable(tag, content)); } } } private static void tellLog(String level, String tag, String content) { if (null != listenerList) { for (LogListener l : listenerList) { l.onLog(level, tag, content); } } } public static void addListener(LogListener l) { if (null == listenerList) { listenerList = new ArrayList&lt;&gt;(); } listenerList.add(l); } public static void removeListener(LogListener l) { if (null != listenerList) { listenerList.remove(l); } } static class WriteRunnable implements Runnable { String mmTag; String mmContent; WriteRunnable(String tag, String content) { this.mmTag = tag; this.mmContent = content; } @Override public void run() { SimpleDateFormat logTimeFormat = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;, Locale.CHINA); String logContent = logTimeFormat.format(new Date()) + &quot; [&quot; + mmTag + &quot;] &quot; + mmContent + &quot;\\r\\n&quot;; try { File dir = new File(logFileDir); if (!dir.exists()) { boolean mk = dir.mkdirs(); Log.d(defTag, &quot;make dir &quot; + mk); } File eFile = new File(logFileDir + File.separator + fileName); byte[] strBytes = logContent.getBytes(); try { RandomAccessFile randomAccessFile = new RandomAccessFile(eFile, &quot;rw&quot;); MappedByteBuffer mappedByteBuffer; final int inputLen = strBytes.length; if (!eFile.exists()) { boolean nf = eFile.createNewFile(); Log.d(defTag, &quot;new log file &quot; + nf); mappedByteBuffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, gCurrentLogPos, LOG_FILE_GROW_SIZE); } else { mappedByteBuffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, gCurrentLogPos, inputLen); } if (mappedByteBuffer.remaining() &lt; inputLen) { mappedByteBuffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, gCurrentLogPos, LOG_FILE_GROW_SIZE + inputLen);// Log.d(defTag, &quot;run: grow size &quot;); }// Log.d(defTag, &quot;run: gCurrentLogPos: &quot; + gCurrentLogPos + &quot;, pos: &quot; + mappedByteBuffer.position() + &quot;, remaining: &quot; + mappedByteBuffer.remaining()); mappedByteBuffer.put(strBytes); gCurrentLogPos += inputLen; } catch (Exception e) { Log.e(defTag, &quot;WriteRunnable run: &quot;, e); if (!eFile.exists()) { boolean nf = eFile.createNewFile(); Log.d(defTag, &quot;new log file &quot; + nf); } FileOutputStream os = new FileOutputStream(eFile, true); os.write(logContent.getBytes()); os.flush(); os.close(); } } catch (Exception e) { e.printStackTrace(); Log.e(defTag, &quot;写log文件出错: &quot;, e); } } }} 监听器 123public abstract class LogListener { public abstract void onLog(String level, String tag, String content);} 自定义View一些自定义的view，比如一些折线图，条形图。 折线图 ColorAutoLineChart单独一条折线，可自动缩放Y轴高度。使用FloatBuffer来存储数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151public class ColorAutoLineChart extends View { private static final String TAG = &quot;AppColorAutoLineChart&quot;; private float yMax = 1856f; private float yMin = -1024f; // 图表线条在view顶部留出的间距 float viewYStart = 2; float axisTextSize = 7; private int onShowPointsCount = 256; // 当前显示的数据个数 private int cacheMaxPoint = 9000; // 数据存储最大个数 float axisLineWid = 1f; // 坐标轴线条宽度 int dataLineWid = 2; // 数据线颜色 private int dataColor = Color.WHITE; private float xStep = 1.0f; private float viewWidth; private float viewHeight; private float botLeftXOnView = 0; // 图表左下点在view中的x坐标 private float botLeftYOnView = 0; private float originYToBottom = 20; // 图表原点距离view底部的距离 private FloatBuffer dataBuffer; private Paint bgPaint; private Paint linePaint; private Paint wavePaint; Path wavePath = new Path(); // 用来画渐变色 int waveTopColor = Color.parseColor(&quot;#f65212&quot;); public ColorAutoLineChart(Context context) { this(context, null); } public ColorAutoLineChart(Context context, AttributeSet attrs) { this(context, attrs, 0); } public ColorAutoLineChart(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context); } public void addData(int[] data) { for (int i : data) { addData(i); } } public void addData(float data) { dataBuffer.put(data); if (dataBuffer.position() &gt; (dataBuffer.capacity() * 2 / 3)) { float[] bufferArr = dataBuffer.array(); System.arraycopy(bufferArr, dataBuffer.position() - cacheMaxPoint, bufferArr, 0, cacheMaxPoint); dataBuffer.position(cacheMaxPoint);// Log.d(TAG, &quot;把当前数据移动到buffer起始位置 &quot; + dataBuffer); } invalidate(); } private void init(Context context) { dataBuffer = FloatBuffer.allocate(3 * cacheMaxPoint); // 分配3倍的空间 bgPaint = new Paint(Paint.ANTI_ALIAS_FLAG); linePaint = new Paint(Paint.ANTI_ALIAS_FLAG); wavePaint = new Paint(Paint.ANTI_ALIAS_FLAG); bgPaint.setStrokeWidth(axisLineWid); bgPaint.setStyle(Paint.Style.STROKE); linePaint.setStrokeWidth(dataLineWid); linePaint.setStyle(Paint.Style.STROKE); linePaint.setColor(dataColor); botLeftXOnView = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 0, context.getResources().getDisplayMetrics()); originYToBottom = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, context.getResources().getDisplayMetrics()); viewYStart = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, context.getResources().getDisplayMetrics()); axisLineWid = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1, context.getResources().getDisplayMetrics()); axisTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 8, context.getResources().getDisplayMetrics()); } @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); viewWidth = getWidth(); viewHeight = getHeight(); botLeftYOnView = viewHeight - originYToBottom; } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.drawColor(Color.TRANSPARENT); xStep = (viewWidth - botLeftXOnView) / (onShowPointsCount - 1); int dataStartIndexInBuffer = 0; // 数据在buffer中的起始下标 if (dataBuffer.position() &gt; onShowPointsCount) { dataStartIndexInBuffer = dataBuffer.position() - onShowPointsCount; } float[] bufferArr = dataBuffer.array(); float maxData = bufferArr[0]; float minData = bufferArr[0]; for (int i = dataStartIndexInBuffer; i &lt; dataBuffer.position(); i++) { float cur = bufferArr[i]; if (cur &lt; minData) { minData = cur; } else if (cur &gt; maxData) { maxData = cur; } } drawWave(canvas, dataStartIndexInBuffer); } private void drawWave(Canvas canvas, int dataStartIndexInBuffer) { wavePath.reset(); final float yDataRange = yMax - yMin; final float yAxisRangeOnView = botLeftYOnView - viewYStart; final float yDataStep = yAxisRangeOnView / yDataRange; float[] dataArr = dataBuffer.array(); float maxData = dataArr[dataStartIndexInBuffer]; float waveStartX = botLeftXOnView; float waveStartY = getYL(dataArr[dataStartIndexInBuffer], yDataStep); wavePath.moveTo(waveStartX, waveStartY); for (int i = dataStartIndexInBuffer; i &lt; dataBuffer.position() - 1; i++) { float curData = dataArr[i]; float nextData = dataArr[i + 1]; wavePath.lineTo(botLeftXOnView + (i - dataStartIndexInBuffer + 1) * xStep, getYL(nextData, yDataStep)); canvas.drawLine(botLeftXOnView + (i - dataStartIndexInBuffer) * xStep, getYL(curData, yDataStep), botLeftXOnView + (i - dataStartIndexInBuffer + 1) * xStep, getYL(nextData, yDataStep), linePaint); maxData = Math.max(maxData, nextData); } wavePath.lineTo(viewWidth, viewHeight); wavePath.lineTo(botLeftXOnView, viewHeight); wavePath.lineTo(waveStartX, waveStartY); wavePath.close(); wavePaint.setShader(new LinearGradient(0, getYL(maxData, yDataStep), 0, viewHeight, waveTopColor, Color.TRANSPARENT, Shader.TileMode.CLAMP)); canvas.drawPath(wavePath, wavePaint); } private float getYL(final float yData, float yDataStep) { return botLeftYOnView - (yData - yMin) * yDataStep; }} 后台用户行为记录最开始设计后台服务的时候，并没有考虑到太多的记录功能。仅仅记录了用户登录行为。今后应该记录更详细的。例如获取用户信息，时间，客户端类型，userID等等。获取用户信息是否成功，可作为缓存登录的依据。 后台可以记录的用户行为，例如获取用户信息，用户查看飞行记录列表，用户查看飞行记录详情，用户点赞。 WebView设置webview不显示图片的问题。LL后加载https的网页，默认会不加载http的资源。需要设置。 12webSettings.setBlockNetworkImage(false);webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); 方法调用记录调用原因调用某个方法的时候，比如中止某项功能。可以在log上记录一些原因，方便debug。 Glide设定播放gif的次数1234567891011121314151617181920Glide.get(getApplicationContext()).setMemoryCategory(MemoryCategory.NORMAL);Glide.with(this).asGif().listener(new RequestListener&lt;GifDrawable&gt;() { @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;GifDrawable&gt; target, boolean isFirstResource) { return false; } @Override public boolean onResourceReady(GifDrawable resource, Object model, Target&lt;GifDrawable&gt; target, DataSource dataSource, boolean isFirstResource) { resource.setLoopCount(1); return false; }}).load(R.drawable.app_start_up).into(imageView);imageView.setOnApplyWindowInsetsListener(new View.OnApplyWindowInsetsListener() { @Override public WindowInsets onApplyWindowInsets(View v, WindowInsets insets) { MyAppControl.setPhoneStatusBarHeight(insets.getSystemWindowInsetTop()); return insets; }});","link":"/2018/07/29/Dev-note/dev-note-app-drone/"},{"title":"Flutter International 国际化，Localization 本地化， 使用字符串Map","text":"记录一种简单的方式实现字符串的国际化。 这里没有用到Intl包，而是将所需的字符串存放在一个map中。 步骤： MaterialApp中添加本地化代理和语言类型 创建文字资源文件 新建一个类继承LocalizationsDelegate，和文字资源文件联系起来 使用代理获取想要的文字资源 新建项目international_demo，得到一个带按钮示例工程。改造一下MaterialApp。12345678910111213141516171819202122class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), localizationsDelegates: [// 添加区域 // 准备在这里添加我们自己创建的代理 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ // 添加区域 const Locale('en', 'US'), // English const Locale('he', 'IL'), // Hebrew // 可以继续添加我们想要支持的语言类型 ], home: new MyHomePage(title: 'Flutter Demo Home Page'), ); }} 创建资源文件新建localization_src.dart，将字符串存入一个map中。123456789101112131415161718192021222324252627import 'package:flutter/material.dart';class DemoLocalizations { DemoLocalizations(this.locale); final Locale locale; static DemoLocalizations of(BuildContext context) { return Localizations.of&lt;DemoLocalizations&gt;(context, DemoLocalizations); } static Map&lt;String, Map&lt;String, String&gt;&gt; _localizedValues = { 'en': { 'title': 'Hello World', }, 'es': { 'title': 'Hola Mundo', }, 'zh': { 'title': '你好呀', }, }; String get title { return _localizedValues[locale.languageCode]['title']; }}这里仅以title为例，有英语、西班牙语和中文三种。 创建代理新建一个类继承LocalizationsDelegate，复写3个方法。12345678910111213141516171819202122import 'dart:async';import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';import 'package:international_demo/localization_src.dart';class DemoLocalizationsDelegate extends LocalizationsDelegate&lt;DemoLocalizations&gt; { const DemoLocalizationsDelegate(); @override bool isSupported(Locale locale) =&gt; ['en', 'es', 'zh'].contains(locale.languageCode); @override Future&lt;DemoLocalizations&gt; load(Locale locale) { return SynchronousFuture&lt;DemoLocalizations&gt;(DemoLocalizations(locale)); } @override bool shouldReload(DemoLocalizationsDelegate old) =&gt; false;}复写的load方法中，使用了SynchronousFuture。 使用代理回到main.dart。12345678910111213141516171819202122class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), localizationsDelegates: [ DemoLocalizationsDelegate(),// 这是我们新建的代理 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ const Locale('en', 'US'), // English const Locale('he', 'IL'), // Hebrew const Locale('zh', ''), // 新添中文，后面的countryCode暂时不指定 ], home: new MyHomePage(title: 'Flutter Demo Home Page'), ); }} 在_MyHomePageState中调用DemoLocalizations。12DemoLocalizations localizations = DemoLocalizations.of(context);print(localizations); // 打印出 I/flutter (25535): Instance of 'DemoLocalizations'观察logcat，可知我们获得了DemoLocalizations的实例。 获取title1DemoLocalizations.of(context).title 如果需要更多的字符串，需要我们手动在资源文件的map中添加。这里仅以title为例。 参考： 官方文档 https://flutter.io/tutorials/internationalization/","link":"/2018/07/16/Flutter/Flutter-International_localization_with_string_map/"},{"title":"Flutter International 国际化，Localization 本地化， 使用Intl","text":"新建项目，得到一个示例工程。本例中使用intl包来管理文字资源。 项目地址： https://github.com/RustFisher/localization_demo 步骤： 添加依赖项 - intl 创建文字资源文件 生成arb文件 新增和修改arb文件 根据arb生成dart文件 创建localization代理，新建一个类继承LocalizationsDelegate，和文字资源文件联系起来 MaterialApp中添加本地化代理和语言类型 使用文字资源 添加依赖项pubspec.yaml添加依赖项flutter_localizations，然后运行一下flutter packages get。12345678dependencies: flutter: sdk: flutter# 添加下面的依赖项 flutter_localizations: sdk: flutter intl: 0.15.6 intl_translation: 0.16.7 编辑dart文件新建app_strings.dart文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344import 'dart:async';import 'package:intl/intl.dart';import 'package:flutter/widgets.dart';class AppStrings { AppStrings(Locale locale) : _localeName = locale.toString(); final String _localeName; static Future&lt;AppStrings&gt; load(Locale locale) { return initializeMessages(locale.toString()) .then((Object _) { return new AppStrings(locale); }); } static AppStrings of(BuildContext context) { return Localizations.of&lt;AppStrings&gt;(context, AppStrings); } String title() { return Intl.message( 'Localization Demo', name: 'title', desc: '应用标题', locale: _localeName, ); } String click() =&gt; Intl.message( 'Click', name: 'click', desc: '点击', locale: _localeName, ); String helloFromDemo() =&gt; Intl.message( 'Hello~', name: 'helloFromDemo', desc: '一句问候', locale: _localeName, );}此时initializeMessages方法会显示警告，暂时不用管，生成arb文件后再添加引用。 生成arb文件进入项目目录，运行intl的命令。12/e/ws/localization_demo$ flutter pub pub run intl_translation:extract_to_arb --output-dir=lib/l10n lib/app_strings.dart 生成l10n/intl_messages.arb，内容如下。可以看出是JSON格式的文本。123456789101112131415161718192021{ &quot;@@last_modified&quot;: &quot;2018-07-15T22:13:19.218221&quot;, &quot;title&quot;: &quot;Localization Demo&quot;, &quot;@title&quot;: { &quot;description&quot;: &quot;应用标题&quot;, &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: {} }, &quot;click&quot;: &quot;Click&quot;, &quot;@click&quot;: { &quot;description&quot;: &quot;点击&quot;, &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: {} }, &quot;helloFromDemo&quot;: &quot;Hello~&quot;, &quot;@helloFromDemo&quot;: { &quot;description&quot;: &quot;一句问候&quot;, &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: {} }} 新增和修改arb文件前面生成了l10n/intl_messages.arb，我们可以把它当成模板。复制粘贴一下，同目录下得到intl_en.arb和intl_zh.arb。文件名规则可以自己定。以intl_zh.arb为例：123456789101112131415161718192021{ &quot;@@last_modified&quot;: &quot;2018-07-15T22:13:19.218221&quot;, &quot;title&quot;: &quot;国际化示例App&quot;, &quot;@title&quot;: { &quot;description&quot;: &quot;应用标题&quot;, &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: {} }, &quot;click&quot;: &quot;点击&quot;, &quot;@click&quot;: { &quot;description&quot;: &quot;点击&quot;, &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: {} }, &quot;helloFromDemo&quot;: &quot;你好呀~&quot;, &quot;@helloFromDemo&quot;: { &quot;description&quot;: &quot;一句问候&quot;, &quot;type&quot;: &quot;text&quot;, &quot;placeholders&quot;: {} }}这里也可以把intl_messages.arb删掉。本例保留这个文件。 根据arb生成dart文件123456$ flutter pub pub run intl_translation:generate_from_arb --output-dir=lib/l10n \\ --no-use-deferred-loading lib/app_strings.dart lib/l10n/intl_*.arbNo @@locale or _locale field found in intl_en, assuming 'en' based on the file name.No @@locale or _locale field found in intl_messages, assuming 'messages' based on the file name.No @@locale or _locale field found in intl_zh, assuming 'zh' based on the file name. 暂时无视警告。此时在app_strings.dart中添加对l10n/intl_messages.arb的引用。1import 'package:localization_demo/l10n/messages_all.dart';警告消失~ 更新了arb文件后，需要重新生成dart文件。 创建localization代理创建localizations_delegate.dart。新建AppLocalizationsDelegate类继承LocalizationsDelegate，复写方法。泛型指定为前面的AppStrings。123456789101112131415161718import 'dart:async';import 'package:flutter/widgets.dart';import 'package:localization_demo/app_strings.dart';class AppLocalizationsDelegate extends LocalizationsDelegate&lt;AppStrings&gt; { @override Future&lt;AppStrings&gt; load(Locale locale) { return AppStrings.load(locale); } @override bool isSupported(Locale locale) =&gt; ['zh', 'en'].contains(locale.languageCode); // 支持的类型要包含App中注册的类型 @override bool shouldReload(AppLocalizationsDelegate old) =&gt; false;} MaterialApp中添加本地化代理和语言类型123456789101112131415161718192021class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), localizationsDelegates: [ AppLocalizationsDelegate(), // 我们定义的代理 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ // 支持的语言类型 const Locale('en', 'US'), // English const Locale('zh', ''), ], home: new MyHomePage(title: 'Flutter Demo Home Page'), ); }} 使用文字资源获取到AppStrings的实例。12AppStrings appStrings = AppStrings.of(context);print(appStrings); // logcat: I/flutter ( 7478): Instance of 'AppStrings' 注意，在MaterialApp中使用文字资源时，因为context的关系，要使用onGenerateTitle。123onGenerateTitle: (context) { return AppStrings.of(context).title();}, 支持语言的类型代理isSupported方法中的语言类型最好是和App中supportedLocales的一致123456789 @override bool isSupported(Locale locale) =&gt; ['zh', 'en'].contains(locale.languageCode);// App中`supportedLocales` supportedLocales: [ const Locale('en', 'US'), // English const Locale('zh', ''), ],否则可能出现获取不到AppStrings的异常。 参考： https://flutter.io/tutorials/internationalization/","link":"/2018/07/16/Flutter/Flutter-International_localization_with_Intl/"},{"title":"Flutter Drawer 抽屉视图与自定义header","text":"移动开发中，drawerLayout抽屉视图是比较常用的一种控件。一般将用户的头像，用户名等信息在抽屉视图中呈现。drawer中也可以提供一些选项，比如跳转去设置页，跳转去用户资料页面等等。 Flutter提供了Drawer组件；结合ListView等组件，开发者可以快速地制作出抽屉视图。 使用material中的UserAccountsDrawerHeader使用material中的UserAccountsDrawerHeader，设置accountName和currentAccountPicture。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyHomePage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() { return new _MyHomePageState(); }}class _MyHomePageState extends State&lt;MyHomePage&gt; { @override Widget build(BuildContext context) { Widget userHeader = UserAccountsDrawerHeader( accountName: new Text('Tom'), accountEmail: new Text('tom@xxx.com'), currentAccountPicture: new CircleAvatar( backgroundImage: AssetImage('images/pic1.jpg'), radius: 35.0,),); return Scaffold(appBar: AppBar(title: Text(&quot;Home&quot;),), body: new Center(child: new Text('Home page'),), drawer: Drawer( child: ListView( padding: EdgeInsets.zero, children: &lt;Widget&gt;[ userHeader , // 可在这里替换自定义的header ListTile(title: Text('Item 1'), leading: new CircleAvatar(child: new Icon(Icons.school),), onTap: () { Navigator.pop(context); },), ListTile(title: Text('Item 2'), leading: new CircleAvatar(child: new Text('B2'),), onTap: () { Navigator.pop(context); },), ListTile(title: Text('Item 3'), leading: new CircleAvatar( child: new Icon(Icons.list),), onTap: () { Navigator.pop(context); },), ], ), ),); }} 使用UserAccountsDrawerHeader效果如下 UserAccountsDrawerHeader文档请见 https://docs.flutter.io/flutter/material/UserAccountsDrawerHeader-class.html 自定义headerFlutter有DrawerHeader，我们对其进行自定义。 DrawerHeader设置padding为0，充满整个顶部 DrawerHeader的child使用Stack，目的是放置背景图片 在Stack偏左下的位置放置头像和用户名 先用Align确定对齐方式为FractionalOffset.bottomLeft Align的child为Container，并设定一个具体高度 头像与文字的Container仿照ListTile的风格，左边是一个头像，右边是文字；使用Row来分隔头像和文字 文字部分先用Container的margin做出间隔，再放入一个Column来存放Text 文字Column设置水平方向左对齐与竖直方向居中 12345678910111213141516171819202122232425262728293031323334353637Widget header = DrawerHeader( padding: EdgeInsets.zero, /* padding置为0 */ child: new Stack(children: &lt;Widget&gt;[ /* 用stack来放背景图片 */ new Image.asset( 'images/p_h_r_600.png', fit: BoxFit.fill, width: double.infinity,), new Align(/* 先放置对齐 */ alignment: FractionalOffset.bottomLeft, child: Container( height: 70.0, margin: EdgeInsets.only(left: 12.0, bottom: 12.0), child: new Row( mainAxisSize: MainAxisSize.min, /* 宽度只用包住子组件即可 */ crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.start, children: &lt;Widget&gt;[ new CircleAvatar( backgroundImage: AssetImage('images/pic1.jpg'), radius: 35.0,), new Container( margin: EdgeInsets.only(left: 6.0), child: new Column( crossAxisAlignment: CrossAxisAlignment.start, // 水平方向左对齐 mainAxisAlignment: MainAxisAlignment.center, // 竖直方向居中 children: &lt;Widget&gt;[ new Text(&quot;Tom&quot;, style: new TextStyle( fontSize: 20.0, fontWeight: FontWeight.w400, color: Colors.white),), new Text(&quot;What's up&quot;, style: new TextStyle( fontSize: 14.0, color: Colors.white),), ], ), ), ],), ), ), ]),); 自定义header的效果图 在自定义header的过程中，我们组合使用了多种widget； 有层叠的Stack，用于对齐的Align，设定具体尺寸和margin的Container，水平放置的Row以及竖直放置的Column。 这些widget的各有特点，根据具体情况来组合使用。同一个UI效果，做法也不止一种。","link":"/2018/07/03/Flutter/Flutter-Drawer_and_custom_header/"},{"title":"Flutter widget动画效果之CurvedAnimation","text":"在Android中，我们可以用XML来指定动画样式，或者调用View的animate()方法。在Flutter中，widget的动画效果利用animated动画化组件的动画库来实现。 Flutter中，使用AnimationController来控制动画暂停、调整进度、停止和倒退。AnimationController继承自Animation&lt;double&gt;。 在vsync信号发出时，需要一个触发器来通知它，从而在每帧中产生一个0到1的线性差值。 一个Controller可以与多个动画进行关联。 当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，此时发出 VSync 信号。 动画样式示例 - CurvedAnimation与FadeTransition用CurvedAnimation实现一个动画效果。给widget指定动画效果，用Controller来控制动画的播放。下面这个例子是关于FadeTransition的。用一个FloatingActionButton来控制动画播放。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import 'package:flutter/material.dart';void main() =&gt; runApp(new AnimationApp());class AnimationApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Animation', theme: new ThemeData(primarySwatch: Colors.blue), home: new HomePage( title: '动画示例', ), ); }}class HomePage extends StatefulWidget { final String title; HomePage({Key key, this.title}) : super(key: key); @override State&lt;StatefulWidget&gt; createState() =&gt; new _HomePageState();}// 需要Tickerclass _HomePageState extends State&lt;HomePage&gt; with TickerProviderStateMixin { AnimationController controller; CurvedAnimation curveEaseIn, bounceIn, linear, decelerate; bool _animationFlag = true; @override void initState() { super.initState(); controller = new AnimationController( duration: new Duration(milliseconds: 2000), vsync: this); curveEaseIn = new CurvedAnimation(parent: controller, curve: Curves.easeIn); bounceIn = new CurvedAnimation(parent: controller, curve: Curves.bounceIn); linear = new CurvedAnimation(parent: controller, curve: Curves.linear); decelerate = new CurvedAnimation(parent: controller, curve: Curves.decelerate); } @override Widget build(BuildContext context) { buildItemWidget( CurvedAnimation animation, MaterialColor color, String itemText) { return new Column( children: &lt;Widget&gt;[ new FadeTransition( opacity: animation, child: new FlutterLogo( size: 100.0, colors: color, ), ), new Text(itemText) ], ); } return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), floatingActionButton: new FloatingActionButton( onPressed: () { if (_animationFlag) { controller.forward(); } else { controller.reverse(); } _animationFlag = !_animationFlag; }, child: new Icon(Icons.star), ), body: new Center( child: new GridView.extent( maxCrossAxisExtent: 170.0, padding: const EdgeInsets.all(12.0), children: &lt;Widget&gt;[ buildItemWidget(curveEaseIn, Colors.blue, 'Curves.easeIn'), buildItemWidget(bounceIn, Colors.amber, 'Curves.bounceIn'), buildItemWidget(linear, Colors.red, 'Curves.linear'), buildItemWidget(decelerate, Colors.indigo, 'Curves.decelerate'), buildItemWidget( new CurvedAnimation( parent: controller, curve: Curves.elasticIn), Colors.pink, 'Curves.elasticIn'), buildItemWidget( new CurvedAnimation(parent: controller, curve: Curves.ease), Colors.purple, 'Curves.ease'), ], ), ), ); }}","link":"/2018/06/26/Flutter/Flutter-CurvedAnimation/"},{"title":"Flutter 加载网络图片的几种方式","text":"对很多移动应用来说，加载网络图片是很常见的基本功能。Android中常用Glide等图片库。Flutter提供了Image组件来展示不同类型的图片。 加载网络图片有几种方式： Image.network FadeInImage.memoryNetwork 使用cached_network_image中的CachedNetworkImage 使用Image.network加载图片根据URL加载图片，使用Image.network构造器123Image.network( 'https://raw.githubusercontent.com/flutter/website/master/_includes/code/layout/lakes/images/lake.jpg',) Image组件也支持GIF格式的图片使用方法如下，和上面的用法一样123Image.network( 'https://github.com/flutter/plugins/raw/master/packages/video_player/doc/demo_ipod.gif?raw=true',); Image.network的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import 'package:flutter/material.dart';void main() =&gt; runApp(new ImageDemoApp());class ImageDemoApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Image Demo', home: new HomePage(), ); }}class HomePage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _HomePageState();}class _HomePageState extends State&lt;HomePage&gt; { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Web Image Demo Page'),), body: new ListView(children: &lt;Widget&gt;[ Container( margin: EdgeInsets.only(bottom: 12.0), decoration: BoxDecoration(color: Colors.grey), child: Column(children: &lt;Widget&gt;[ Image.network( 'https://raw.githubusercontent.com/flutter/website/master/_includes/code/layout/lakes/images/lake.jpg', ), Text('Image.network') ],), ), Container( margin: EdgeInsets.only(bottom: 12.0), decoration: BoxDecoration(color: Colors.grey), child: Column(children: &lt;Widget&gt;[ Image.network( 'https://github.com/flutter/plugins/raw/master/packages/video_player/doc/demo_ipod.gif?raw=true', ), Text('Image.network Animated Gifs') ],), ), ],), ); }} 有默认占位图和淡入效果在图片加载过程中，给用户展示一张默认的图片，能提高用户体验。使用FadeInImage组件来达到这个功能。FadeInImage能处理内存中，App资源或者网络上的图片。 加载网络图片123456import 'package:transparent_image/transparent_image.dart';FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: 'https://github.com/flutter/website/blob/master/_includes/code/layout/lakes/images/lake.jpg?raw=true',); 示例效果使用FadeInImage.memoryNetwork1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';import 'package:transparent_image/transparent_image.dart';void main() =&gt; runApp(new FadeInImageDemoApp());class FadeInImageDemoApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Image Demo', home: new HomePage(), ); }}class HomePage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _HomePageState();}class _HomePageState extends State&lt;HomePage&gt; { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Fade In Image Demo Page'),), body: Stack( children: &lt;Widget&gt;[ Center(child: CircularProgressIndicator()), Center(child: FadeInImage.memoryNetwork( image: 'https://raw.githubusercontent.com/flutter/website/master/_includes/code/layout/lakes/images/lake.jpg', placeholder: kTransparentImage/* 透明图片 */,)), ], ), ); }} 使用应用内的图片来做占位图使用FadeInImage.assetNetwork 代码12345678910111213class _HomePageState extends State&lt;HomePage&gt; { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Fade In Image Demo Page'),), body: Center(child: FadeInImage.assetNetwork( image: 'https://raw.githubusercontent.com/flutter/website/master/_includes/code/layout/lakes/images/lake.jpg', placeholder: 'images/birds.gif' /* 指定gif */,)), ); }} 使用缓存图片使用cached_network_image包。参见 https://pub.dartlang.org/packages/cached_network_image 。123CachedNetworkImage( imageUrl: 'https://github.com/flutter/website/blob/master/_includes/code/layout/lakes/images/lake.jpg?raw=true',); 添加placeholdercached_network_image的placeholder支持任意组件，比如CircularProgressIndicator1234CachedNetworkImage( placeholder: CircularProgressIndicator(), imageUrl: 'https://github.com/flutter/website/blob/master/_includes/code/layout/lakes/images/lake.jpg?raw=true',); 代码示例123456789101112131415161718import 'package:flutter/material.dart';import 'package:cached_network_image/cached_network_image.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Cached image load', home: Scaffold(appBar: AppBar(title: new Text('Cache Image Load'),), body: Center(child: CachedNetworkImage( placeholder: CircularProgressIndicator(), imageUrl: 'https://github.com/flutter/website/blob/master/_includes/code/layout/lakes/images/lake.jpg?raw=true'),),), ); }}","link":"/2018/06/26/Flutter/Flutter-Load_image_from_network/"},{"title":"Flutter 布局常用的 widgets（Common layout widgets）","text":"简单列举总结一下常用的布局widget。Flutter有丰富的layout组件库。其中有一些是常用库。下面的widget分为两类：标准组件和来自Material Components的特殊组件。只有Material App能够使用Material Components的组件。 标准组件 - Standard widgets Container 给一个组件添加 padding, margins, 边界（borders）, 背景颜色或其它装饰（decorations）。 GridView 将多个widget放在一个可滑动的表格中。 ListView 将多个widget放在一个可滑动的列表中。 Stack 在一个widget上面盖上另一个widget。 Material Components Card 将一些相近的信息装进一个有圆角和阴影的盒子里。 ListTile 一个Row中装载最多3行文字；可选则在前面或尾部添加图标。 ContainerContainer用法比较自由。可以把整个layout放进container里面，然后改变背景颜色或图片。 Container 小结: 添加 padding, margins, 和边界（borders） 能够更好背景颜色和图片 包含一个单独的子widget，这个子widget可以是Row、Column或一个widget树的根widget 测试代码widgetdemo/container_page.dart12345678910111213141516import 'package:flutter/material.dart';import 'package:demo_flutter/widgetdemo/container_page.dart';// 引入自定义的包......void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Container demo 1', theme: new ThemeData(primarySwatch: Colors.brown), home: new ContainerDemoPage(), // 这里换上想要测试的界面 ); }} widgetdemo/container_page.dart代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';/// container示例界面class ContainerDemoPage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _ContainerDemoPageState();}class _ContainerDemoPageState extends State&lt;ContainerDemoPage&gt; { @override Widget build(BuildContext context) { Expanded imageExpanded(String img) { return new Expanded(child: new Container( decoration: new BoxDecoration( border: new Border.all(width: 10.0, color: Colors.black38), borderRadius: const BorderRadius.all( const Radius.circular(8.0))), margin: const EdgeInsets.all(4.0), child: new Image.asset(img), )); } var container = new Container( decoration: new BoxDecoration(color: Colors.black26), child: new Column( children: &lt;Widget&gt;[ new Row(children: &lt;Widget&gt;[ imageExpanded('images/c1.jpg'), imageExpanded('images/c2.jpg'), ],), new Row(children: &lt;Widget&gt;[ imageExpanded('images/d1.jpg'), imageExpanded('images/d2.jpg'), ],), new Row(children: &lt;Widget&gt;[ imageExpanded('images/p1.jpg'), ],) ], ), ); return new Scaffold( appBar: new AppBar(title: new Text('Container Page demo'),), body: new Center( child: container, ), ); }} GridView用GridView来将widget放入一个2维的列表中。GridView提供了2个预装配好的列表，也可以自己建立自定义列表。GridView支持滚动。 GridView 小结: 将多个widget放进一个表格中 当超出渲染范围时，自动提供滚动功能 可自定义格子，也可用下面提供的2种 GridView.count 指定列的数目 GridView.extent 允许指定子项的最大像素宽度 示例1 - 用GridView.extentGridView.extent指定子项占据的最大宽度123456789101112131415161718192021222324252627282930313233import 'package:flutter/material.dart';/// gridView示例界面1class GridDemo1Page extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _GridDemo1PageState();}class _GridDemo1PageState extends State&lt;GridDemo1Page&gt; { @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('Grid Page 1 demo'),), body: new Center( child: buildGrid(), ), ); } List&lt;Container&gt; _buildGridTileList(int count) { return new List&lt;Container&gt;.generate(count, (int index) =&gt; new Container(child: new Image.asset('images/pic${index + 1}.jpg'),)); } Widget buildGrid() { return new GridView.extent( maxCrossAxisExtent: 150.0, padding: const EdgeInsets.all(4.0), mainAxisSpacing: 4.0, crossAxisSpacing: 4.0, children: _buildGridTileList(30),); }} 示例2 - 用GridView.countcrossAxisCount设为2，分成2列。1234567891011Widget buildGrid() { var countGrid = GridView.count( crossAxisCount: 2, mainAxisSpacing: 4.0, crossAxisSpacing: 4.0, padding: const EdgeInsets.all(4.0), childAspectRatio: 1.3, children: _buildGridTileList(30), ); return countGrid;} ListViewListView能以列的形式展示数据。当内容超过渲染范围时，自动提供滚动的功能。 ListView 小结 把子视图装进列表中 水平或竖直都可以 支持滑动 相比于Column，可选配置比较少，但更易用并且支持滑动 和Android中的ListView差别不大 示例1把ListTile当做子项来装载数据。123456789101112131415161718192021222324252627282930import 'package:flutter/material.dart';class ListViewPage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _ListViewPageState();}class _ListViewPageState extends State&lt;ListViewPage&gt; { @override Widget build(BuildContext context) { List&lt;Widget&gt; list = &lt;Widget&gt;[]; for (int i = 0; i &lt; 30; i++) { list.add(new ListTile( title: new Text('title$i', style: _itemTextStyle,), subtitle: new Text('A'), leading: i % 3 == 0 ? new Icon(Icons.theaters, color: Colors.blue,) : new Icon(Icons.restaurant, color: Colors.blue,), )); } return new Scaffold( appBar: new AppBar(title: new Text('ListView Demo'),), body: new Center(child: new ListView(children: list,),), ); }}TextStyle _itemTextStyle = new TextStyle( fontWeight: FontWeight.w500, fontSize: 14.0); 另外可以参考 https://github.com/flutter/flutter/blob/master/examples/flutter_gallery/lib/demo/colors_demo.dart Stack使用Stack在widget之上显示另一些widget，通常用来显示图片。显示的widget可以完全地把底部widget盖住。 Stack 小结: 用来在当前widget上面再盖上一层widget Stack children中的第一个widget放在最下，后面的widget会一层层盖上去 Stack的内容不支持滚动 可以裁剪超出范围的子widget Stack示例1显示一个CircleAvatar12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';class StackPage1 extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _StackPage1State();}class _StackPage1State extends State&lt;StackPage1&gt; { @override Widget build(BuildContext context) { var stack = new Stack( alignment: const Alignment(0.6, 0.6), children: &lt;Widget&gt;[ new CircleAvatar( backgroundImage: new AssetImage('images/android_1.jpg'), radius: 100.0,), new Container(decoration: new BoxDecoration(color: Colors.black45), child: new Text( 'Android Avatar', style: new TextStyle(color: Colors.white70),),), new Container(decoration: new BoxDecoration(color: Colors.transparent), padding: const EdgeInsets.fromLTRB(0.0, 0.0, 100.0, 0.0), child: new CircleAvatar( backgroundImage: new AssetImage('images/p_box1.png'), backgroundColor: Colors.transparent, radius: 10.0,),), ], ); return new Scaffold( appBar: new AppBar(title: new Text('Stack Demo 1'),), body: new Center(child: stack,), ); }} CardCard来自Material组件库，可包含一些数据，通常用ListTile来组装。Card只有一个子widget，可以是column、row、list、grid或其它组合widget。默认情况下，Card把自己的尺寸缩小为0像素。可以用SizedBox来指定card的尺寸。 Flutter中的Card有圆角和阴影效果。修改elevation可改变阴影效果。 elevation取值范围，参考 Elevation and Shadows 若设置的范围外的值，阴影效果会消失。 Card 小结: 实现了Material Design card 用于展示相关的数据 有一个子项（child），可以是column、row、list、grid或其它组合widget 有圆角和阴影效果 不支持滚动 Card示例1将前面的ListView示例修改一下123456789101112131415161718192021222324252627282930313233343536import 'package:flutter/material.dart';class ListViewPage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _ListViewPageState();}class _ListViewPageState extends State&lt;ListViewPage&gt; { @override Widget build(BuildContext context) { List&lt;Widget&gt; list = &lt;Widget&gt;[]; for (int i = 0; i &lt; 30; i++) { list.add(new Card(child: new Column( children: &lt;Widget&gt;[ new Image.asset( 'images/pic${i + 1}.jpg',), new ListTile( title: new Text('title$i', style: _itemTextStyle,), subtitle: new Text('A'), leading: i % 3 == 0 ? new Icon(Icons.theaters, color: Colors.blue,) : new Icon(Icons.restaurant, color: Colors.blue,), ), ], ),)); } return new Scaffold( appBar: new AppBar(title: new Text('ListView Demo'),), body: new Center(child: new ListView(children: list,),), ); }}TextStyle _itemTextStyle = new TextStyle( fontWeight: FontWeight.w500, fontSize: 14.0); ListTile来自Material组件库的横向组件。可自定义3行文字及其可选的头尾图标。此控件常与Card或ListView一起用。 ListTile 小结: 可定制3行带图标的文字 相比于Row，配置更少，但更易用 加一个主界面放置一些按钮，点击跳转到相应的界面。使用Navigator.of(context).pushNamed(routeName)来跳转。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';import 'package:demo_flutter/widgetdemo/container_page.dart';import 'package:demo_flutter/widgetdemo/grid_page.dart';import 'package:demo_flutter/widgetdemo/listview_demo.dart';import 'package:demo_flutter/widgetdemo/stack_page1.dart';import 'package:demo_flutter/widgetdemo/button_page.dart';const String CONTAINER_DEMO_PAGE = '/a';void main() { runApp(new MaterialApp( home: new HomePage(), routes: { CONTAINER_DEMO_PAGE: (BuildContext context) =&gt; new ContainerDemoPage(), '/b': (BuildContext context) =&gt; new GridDemo1Page(), '/c': (BuildContext context) =&gt; new ListViewPage(), '/d': (BuildContext context) =&gt; new StackPage1(), '/e': (BuildContext context) =&gt; new ButtonPage(), }, ));}class HomePage extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() =&gt; new _HomePageState();}class _HomePageState extends State&lt;HomePage&gt; { @override Widget build(BuildContext context) { getGestureDetector(String routeName, String content) { return new GestureDetector ( onTap: () { Navigator.of(context).pushNamed(routeName); }, child: new Container ( padding: EdgeInsets.all(20.0), child: new Center(child: new Text (content),)), ); } return new Scaffold( appBar: new AppBar(title: new Text('Home'),), body: new Column(children: &lt;Widget&gt;[ getGestureDetector(CONTAINER_DEMO_PAGE, 'Container Demo'), getGestureDetector('/b', 'Grid Demo 1'), getGestureDetector('/c', 'ListView Demo'), getGestureDetector('/d', 'Stack Demo'), getGestureDetector('/e', 'Button Page'), ],), ); }}","link":"/2018/06/26/Flutter/Flutter-Layout_common_widgets/"},{"title":"Flutter工程常见问题集合","text":"在学习使用flutter的过程中，遇到一些工程上的问题。比如flutter的配置，IDE的设置等等。 flutter doctor 需要jdk1.8需要jdk1.8；如果装的是jdk9及以后的版本，flutter doctor会一直提示你需要升级android SDK https://flutter.io/flutter-for-android/#views flutter升级遇到网络错误 - Got socket errorwin7双击打开flutter_console.bat，尝试用flutter upgrade升级时，遇到错误。12345678E:\\sdk_flutter\\flutter&gt;flutter upgradeChecking Dart SDK version...Downloading Dart SDK from Flutter engine 09d05a38912a3c1a906e95099cac9a7e14fae85f...Unzipping Dart SDK...Updating flutter tool...Got socket error trying to find package mockito at https://pub.dartlang.org.Error: Unable to 'pub upgrade' flutter tool. Retrying in five seconds...报错：连接不上https://pub.dartlang.org 用梯子和不用梯子都会报这个错误。查阅官网https://flutter.io/get-started/install/ 官网说中国用户请参考https://github.com/flutter/flutter/wiki/Using-Flutter-in-China 参考文章建议设置2个环境变量12export PUB_HOSTED_URL=[https://pub.flutter-io.cn](https://pub.flutter-io.cn/) export FLUTTER_STORAGE_BASE_URL=[https://storage.flutter-io.cn](https://storage.flutter-io.cn/)我用的是win7，在环境变量 -&gt; 用户变量中添加了这2个变量12FLUTTER_STORAGE_BASE_URL https://storage.flutter-io.cnPUB_HOSTED_URL https://pub.flutter-io.cn 再重新执行flutter upgrade即可 使用flutter_console.bat时，应该以管理员身份运行 Android Studio 3.0.1 的flutter项目找不到设备 - no connected device尝试运行flutter项目时，出现提示框 此时注意到as顶部工具栏的右边少了设备框【Flutter Device Selection】 红圈的位置本应该显示当前连接的设备，但是在代码写错一次后，这一栏就消失了。 错误排查尝试清缓存并重启as，那一栏仍然未出现 flutter已经升级到当前最新版本。在git-bash中运行flutter doctor，并没有发现什么问题。12345678$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[√] Flutter (Channel beta, v0.5.1, on Microsoft Windows [Version 6.1.7601], locale zh-CN)[√] Android toolchain - develop for Android devices (Android SDK 27.0.3)[√] Android Studio (version 3.0)[√] Connected devices (1 available)• No issues found!由此猜测是Android Studio的问题。新建一个flutter工程，观察到设备框又正常了 那么原来工程里面为何总是说找不到设备？ 仔细回想了一下，参考flutter教程时，添加了一个images目录，并且修改了pubspec.yaml文件。检查发现assets的缩进弄错了。把缩进改成2个空格后，设备框就出现了。123# To add assets to your application, add an assets section, like this:assets: - images/lake.jpg由此可见，as对pubspec.yaml文件十分敏感。 Flutter 示例工程flutter_gallery遇到的网络问题beta分支的flutter_gallery把资源文件都放在了 https://flutter.googlesource.com/gallery-assets/ 这个用浏览器是可以打开的，但是as运行的时候会报 fatal: not a git repository ； 参考 https://github.com/flutter/flutter/issues/13763 ，决定把channel切换到master 切换到master channel后，把flutter中的bin目录整个删掉；运行flutter doctor重新下载一次dart的SDK。可运行master中的demo。 Android Studio找不到Flutter SDK运行了flutter upgrade后，打开as发现找不到SDK了。开发环境是win7，进行检查： 环境变量是正常的 使用cmd运行flutter doctor正常 as能跑普通的安卓工程 检查flutter sdk git 仓库的情况，发现有些文件被修改了。使用git将其更新。运行flutter doctor重新编译SDK。打开as发现问题解决。","link":"/2018/06/24/Flutter/Flutter-project_common_questions/"},{"title":"Android Intent 传递数据大小限制","text":"在sendBroadcast，startActivity时，我们会用到Intent。Intent可以携带一些数据，比如基本类型数据int、Boolean，或是String，或是序列化对象，Parcelable与Serializable。 Intent传递数据时，如果数据太大，可能会出现异常。比如App闪退，或是Intent发送不成功，logcat报错等等。 这就牵涉到一个问题：Intent 传递数据大小限制。 Intent到底能够携带多少数据呢？ 使用Intent传送数据时，可能会出现异常在Intent中传入一个Parcelable对象；例如传入一个bitmap对象。 代码参考： https://github.com/AnRFDev/android-Basic4123Bitmap b1 = Bitmap.createScaledBitmap(srcBmp, dstWid, dstHeight, false);Intent intent = new Intent(MSG_INTENT);intent.putExtra(K_PIC, b1);选择bitmap的原因是，Bitmap实现了Parcelable接口，并且可以通过getByteCount()得知所占内存大小。 sendBroadcast时，报出如下信息123456789101112131415V/ActivityManager: Broadcast: Intent { act=intent_bi flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{27aeaaf5 31217:com.rustfisher.basic4/u0a113}E/JavaBinder: !!! FAILED BINDER TRANSACTION !!!W/BroadcastQueue: Failure sending broadcast Intent { act=intent_bi flg=0x10 (has extras) } android.os.TransactionTooLargeException at android.os.BinderProxy.transactNative(Native Method) at android.os.BinderProxy.transact(Binder.java:504) at android.app.ApplicationThreadProxy.scheduleRegisteredReceiver(ApplicationThreadNative.java:1170) at com.android.server.am.BroadcastQueue.performReceiveLocked(BroadcastQueue.java:576) at com.android.server.am.BroadcastQueue.deliverToRegisteredReceiverLocked(BroadcastQueue.java:848) at com.android.server.am.BroadcastQueue.processNextBroadcast(BroadcastQueue.java:917) at com.android.server.am.BroadcastQueue$BroadcastHandler.handleMessage(BroadcastQueue.java:254) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.os.HandlerThread.run(HandlerThread.java:61) at com.android.server.ServiceThread.run(ServiceThread.java:46) 查看异常类TransactionTooLargeException，它继承了RemoteException12345678910package android.os;public class TransactionTooLargeException extends RemoteException { public TransactionTooLargeException() { super(); } public TransactionTooLargeException(String msg) { super(msg); }} 从报错信息FAILED BINDER TRANSACTION可以看出，binder传送数据失败了。追踪到Binder，它的transactNative方法报出RemoteException12public native boolean transactNative(int code, Parcel data, Parcel reply, int flags) throws RemoteException;抛出的异常与Binder有关。 Intent携带信息的大小受Binder限制Intent携带信息的大小其实是受Binder限制。本文标题也可以改为“Binder传递数据大小限制”。 数据以Parcel对象的形式存放在Binder传递缓存中。如果数据或返回值比传递buffer大，则此次传递调用失败并抛出TransactionTooLargeException异常。 Binder传递缓存有一个限定大小，通常是1Mb。但同一个进程中所有的传输共享缓存空间。 多个地方在进行传输时，即时它们各自传输的数据不超出大小限制，TransactionTooLargeException异常也可能会被抛出。 在使用Intent传递数据时，1Mb并不是安全上限。因为Binder中可能正在处理其它的传输工作。不同的机型和系统版本，这个上限值也可能会不同。 在其它地方，例如onSaveInstanceState(@NonNull Bundle outState)，也可能会遇到与Binder有关的类似问题。 为什么Binder要限制传输数据的大小个人推测，作为一种IPC的方式，Binder并不是为传输大量数据而设计。 传输大量数据，可以考虑URL之类的方法。 参考 https://stackoverflow.com/questions/8434423/android-remote-method-data-limit https://developer.android.com/reference/android/os/TransactionTooLargeException","link":"/2018/06/01/Android/Android-Intent_extra_size_limit/"},{"title":"Android NDK Makefile相关与示例","text":"Android.mk与Application.mkAndroid Studio 3之前，需要编写Android.mk和Application.mk文件。 使用jdk8或jdk7中提供的javah来生成头文件。 build.gradle设定jni以下是某模块的build.gradle文件1234567android { // .... sourceSets.main { jni.srcDirs = [] // 禁止自动执行ndk-build jniLibs.srcDirs = ['src/main/libs'] // 设定成so文件生成的目录 }} 指定模块的名字在Android.mk文件中指定模块的名字1LOCAL_MODULE := modname编译得到libmodname.so文件 加载库文件123static { System.loadLibrary(&quot;modname&quot;);} 利用$(TARGET_ARCH_ABI)判断目标架构类别Android Studio 3之前，需要编写Android.mk和Application.mk文件。使用jdk8或jdk7。 一个典型Application.mk1234APP_ABI := arm64-v8a armeabi-v7aAPP_PLATFORM := android-19APP_STL := gnustl_staticAPP_CPPFLAGS += -std=c++11指定了2种架构 在Android.mk中，可以用$(TARGET_ARCH_ABI)判断目标架构类别；例如jni目录中有如下的文件1234567891011jni|-- Android.mk|-- Application.mk|-- something.cpp|-- include| |-- something.h|-- lib| |-- arm64-v8a| | `-- libcustom.a| `-- armeabi-v7a| `-- libcustom.a Android.mk中判断当前编译的目标架构而加载库文件libcustom.a1LOCAL_LDFLAGS := $(LOCAL_PATH)/lib/$(TARGET_ARCH_ABI)/libcustom.a 引用OpenCV模块假设已经下载好opencv-3.2.0SDK，Android.mk中引用123456OPENCVROOT:=$(LOCAL_PATH)/../../../../../opencv-3.2.0-android-sdk/OpenCV-android-sdkOPENCV_CAMERA_MODULES:=offOPENCV_INSTALL_MODULES:=onOPENCV_LIB_TYPE:=STATICinclude ${OPENCVROOT}/sdk/native/jni/OpenCV.mk使用相对路径找到sdk，引入OpenCV的mk文件 Android NDK 通用 makefile 与相关配置Android.mk12345678910LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := waveExtractTARGET_ARCH_ABI := allLOCAL_SRC_FILES := src/wave_display.c src/FFT.cLOCAL_LDLIBS+= -L$(SYSROOT)/usr/lib -lloginclude $(BUILD_SHARED_LIBRARY) Application.mk1234567APP_PLATFORM := android-19APP_MODULES := waveExtractAPP_ABI := armeabi-v7a arm64-v8aAPP_STL := stlport_staticAPP_CPPFLAGS += -fexceptions# for using c++ features,you need to enable these in your MakefileAPP_CPP_FEATURES += exceptions rtti build.gradle123456789101112131415161718192021222324252627282930313233343536373839apply plugin: 'com.android.library'android { compileSdkVersion 28 defaultConfig { minSdkVersion 19 targetSdkVersion 28 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } sourceSets { main { jni.srcDirs = [] jniLibs.srcDirs = ['src/main/libs'] } }}dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:28.+' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'}","link":"/2018/05/21/Android/NDK-Makefile_example/"},{"title":"Activity中获取View的宽高","text":"有些时候我们需要获取到View的宽高信息。在onCreate和onResume中尝试view.getWidth()或是view.getHeiht()时，我们会发现获取到的是0。Activity视图在创建完成后，各个子view并不一定被加载完成。获取宽高正确的方法有哪些呢？ 方法1 - 在Activity的onWindowFocusChanged获取宽高123456@Overridepublic void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); // 在这里我们可以获取到View的真实宽高 Log.d(TAG, &quot;onWindowFocusChanged: mBtn1.getWidth == &quot; + mBtn1.getWidth());} 方法2 - 使用ViewTreeObserver的OnGlobalLayoutListener回调获取View的ViewTreeObserver，添加回调12345678910ViewTreeObserver vto = mBtn1.getViewTreeObserver();vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { int height = mBtn1.getHeight(); int width = mBtn1.getWidth(); Log.d(TAG, &quot;onGlobalLayout: mBtn1 &quot; + width + &quot;, &quot; + height); mBtn1.getViewTreeObserver().removeOnGlobalLayoutListener(this); }}); 方法3 - 使用View.post(Runnable action)方法例如我们在onCreate中post一个Runnable123456789101112131415161718 @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mBtn1 = findViewById(R.id.btn1); Log.d(TAG, &quot;mBtn1 post runnable&quot;); mBtn1.post(new Runnable() { @Override public void run() { Log.d(TAG, &quot;mBtn1: &quot; + mBtn1.getWidth() + &quot;, &quot; + mBtn1.getHeight()); } }); }/* log06-19 11:54:17.865 28009-28009/com.rustfisher.basic4 D/rustApp: mBtn1 post runnable06-19 11:54:17.867 28009-28009/com.rustfisher.basic4 D/rustApp: [act2] onResume06-19 11:54:17.899 28009-28009/com.rustfisher.basic4 D/rustApp: mBtn1: 355, 144*/可以获取到view的宽高。从log的时间上可以看出，在view加载完毕后，执行的Runnable。 应用 - 动态调整ImageView的宽高获取到view的宽高后，我们可以动态地调整ImageView的高度。假设图片宽高为704 * 440。xml中设置scaleType为fitXY。已知ImageView的宽度是固定的，我们可以调整高度。 1234&lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot;/&gt; 根据图片真实大小来重设ImageView的高度。123456789101112131415@Overridepublic void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); resetIntroIvParams();}private void resetIntroIvParams() { int height = mIntroIv.getHeight(); // 704 * 440 int wid = mIntroIv.getWidth(); if (height &gt; 0 &amp;&amp; wid &gt; 0) { ViewGroup.LayoutParams layoutParams = mIntroIv.getLayoutParams(); layoutParams.height = (int) (wid * 440.0 / 704.0); mIntroIv.setLayoutParams(layoutParams); }}","link":"/2018/04/19/Android/Android-Activity_View_get_size/"},{"title":"Android 使用 MediaExtractor 和 MediaMuxer 解析和封装 mp4 文件","text":"本文目的：使用 MediaExtractor 和 MediaMuxer 解析和封装 mp4 文件 简介MP4或称MPEG-4第14部分（英语：MPEG-4 Part 14）是一种标准的数字多媒体容器格式。 MP4中的音频格式通常为AAC(audio/mp4a-latm) MediaExtractorMediaExtractor 可用于分离多媒体容器中视频track和音频track setDataSource() 设置数据源，数据源可以是本地文件地址，也可以是网络地址 getTrackFormat(int index) 来获取各个track的MediaFormat，通过MediaFormat来获取track的详细信息，如：MimeType、分辨率、采样频率、帧率等等 selectTrack(int index) 通过下标选择指定的通道 readSampleData(ByteBuffer buffer, int offset) 获取当前编码好的数据并存在指定好偏移量的buffer中 MediaMuxerMediaMuxer 可用于混合基本码流。将所有的信道的信息合成一个视频。目前输出格式支持MP4，Webm，3GP。从Android Nougat开始支持向MP4中混入B-frames。 提取并输出MP4文件中的视频部分从一个MP4文件中提取出视频，得到不含音频的MP4文件。 实现流程，首先是使用MediaExtractor提取，然后使用MediaMuxer输出MP4文件。 MediaExtractor设置数据源，找到并选择视频轨道的格式和下标 MediaMuxer设置输出格式为MUXER_OUTPUT_MPEG_4，添加前面选定的格式，调用start()启动 MediaExtractor读取帧数据，不停地将帧数据和相关信息传入MediaMuxer 最后停止并释放MediaMuxer和MediaExtractor最好放在子线程中操作。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 提取视频 * * @param sourceVideoPath 原始视频文件 * @throws Exception 出错 */public static void extractVideo(String sourceVideoPath, String outVideoPath) throws Exception { MediaExtractor sourceMediaExtractor = new MediaExtractor(); sourceMediaExtractor.setDataSource(sourceVideoPath); int numTracks = sourceMediaExtractor.getTrackCount(); int sourceVideoTrackIndex = -1; // 原始视频文件视频轨道参数 for (int i = 0; i &lt; numTracks; ++i) { MediaFormat format = sourceMediaExtractor.getTrackFormat(i); String mime = format.getString(MediaFormat.KEY_MIME); Log.d(TAG, &quot;MediaFormat: &quot; + mime); if (mime.startsWith(&quot;video/&quot;)) { sourceMediaExtractor.selectTrack(i); sourceVideoTrackIndex = i; Log.d(TAG, &quot;selectTrack index=&quot; + i + &quot;; format: &quot; + mime); break; } } MediaMuxer outputMediaMuxer = new MediaMuxer(outVideoPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4); outputMediaMuxer.addTrack(sourceMediaExtractor.getTrackFormat(sourceVideoTrackIndex)); outputMediaMuxer.start(); ByteBuffer inputBuffer = ByteBuffer.allocate(1024 * 1024 * 2); // 分配的内存要尽量大一些 MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); int sampleSize; while ((sampleSize = sourceMediaExtractor.readSampleData(inputBuffer, 0)) &gt;= 0) { long presentationTimeUs = sourceMediaExtractor.getSampleTime(); info.offset = 0; info.size = sampleSize; info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME; info.presentationTimeUs = presentationTimeUs; outputMediaMuxer.writeSampleData(sourceVideoTrackIndex, inputBuffer, info); sourceMediaExtractor.advance(); } outputMediaMuxer.stop(); outputMediaMuxer.release(); // 停止并释放 MediaMuxer sourceMediaExtractor.release(); sourceMediaExtractor = null; // 释放 MediaExtractor} 如果上面的ByteBuffer分配的空间太小，readSampleData(inputBuffer, 0)可能会出现IllegalArgumentException异常。 提取MP4文件中的音频部分，获取音频文件基于Java MP4 Parser提取出AAC文件的方法Java MP4 Parser - https://github.com/sannies/mp4parserJava实现读、写和创建MP4容器。但是和编解码音视频有区别。这里主要是提取与再合成。 下载isoparser-1.1.22.jar并添加进工程中；尝试过gradle直接导入，但不成功 找到视频文件中所有的音轨，将它们提取出来写入新的文件中1234567891011121314151617public void extractAudioFromMP4(String outAudioPath, String sourceMP4Path) throws IOException { Movie movie = MovieCreator.build(sourceMP4Path); List&lt;Track&gt; audioTracks = new ArrayList&lt;&gt;(); for (Track t : movie.getTracks()) { if (t.getHandler().equals(&quot;soun&quot;)) { audioTracks.add(t); } } Movie result = new Movie(); if (audioTracks.size() &gt; 0) { result.addTrack(new AppendTrack(audioTracks.toArray(new Track[audioTracks.size()]))); } Container out = new DefaultMp4Builder().build(result); FileChannel fc = new RandomAccessFile(outAudioPath, &quot;rw&quot;).getChannel(); out.writeContainer(fc); fc.close();}在红米手机上测试成功。从MP4文件（时长约2分20秒）中提取出的AAC文件可在手机上直接播放。 将AAC音轨换到另一个MP4文件MediaExtractor可以直接从提取AAC文件或MP4文件中提取ACC音轨，MediaMuxer来写入新的MP4文件。 提供音频的文件可以是MP4文件，也可以是AAC文件；另一个提供视频，混合输出新的MP4文件。 生成的视频的长度由提供视频的文件决定。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @param outputVideoFilePath 输出视频文件路径 * @param videoProviderPath 提供视频的MP4文件 时长以此为准 * @param audioProviderPath 提供音频的文件 * @throws Exception 运行异常 例如读写文件异常 */public static void replaceAudioForMP4File(String outputVideoFilePath, String videoProviderPath, String audioProviderPath) throws Exception { MediaMuxer mediaMuxer = new MediaMuxer(outputVideoFilePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4); // 视频 MediaExtractor MediaExtractor mVideoExtractor = new MediaExtractor(); mVideoExtractor.setDataSource(videoProviderPath); int videoTrackIndex = -1; for (int i = 0; i &lt; mVideoExtractor.getTrackCount(); i++) { MediaFormat format = mVideoExtractor.getTrackFormat(i); if (format.getString(MediaFormat.KEY_MIME).startsWith(&quot;video/&quot;)) { mVideoExtractor.selectTrack(i); videoTrackIndex = mediaMuxer.addTrack(format); Log.d(TAG, &quot;Video: format:&quot; + format); break; } } // 音频 MediaExtractor MediaExtractor audioExtractor = new MediaExtractor(); audioExtractor.setDataSource(audioProviderPath); int audioTrackIndex = -1; for (int i = 0; i &lt; audioExtractor.getTrackCount(); i++) { MediaFormat format = audioExtractor.getTrackFormat(i); if (format.getString(MediaFormat.KEY_MIME).startsWith(&quot;audio/&quot;)) { audioExtractor.selectTrack(i); audioTrackIndex = mediaMuxer.addTrack(format); Log.d(TAG, &quot;Audio: format:&quot; + format); break; } } mediaMuxer.start(); // 添加完所有轨道后start long videoEndPreTimeUs = 0; // 封装视频track if (-1 != videoTrackIndex) { MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); info.presentationTimeUs = 0; ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); int sampleSize; while ((sampleSize = mVideoExtractor.readSampleData(buffer, 0)) &gt;= 0) { info.offset = 0; info.size = sampleSize; info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME; info.presentationTimeUs = mVideoExtractor.getSampleTime(); videoEndPreTimeUs = info.presentationTimeUs; mediaMuxer.writeSampleData(videoTrackIndex, buffer, info); mVideoExtractor.advance(); } } Log.d(TAG, &quot;视频 videoEndPreTimeUs &quot; + videoEndPreTimeUs); // 封装音频track if (-1 != audioTrackIndex) { MediaCodec.BufferInfo info = new MediaCodec.BufferInfo(); info.presentationTimeUs = 0; ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); int sampleSize; while ((sampleSize = audioExtractor.readSampleData(buffer, 0)) &gt;= 0 &amp;&amp; audioExtractor.getSampleTime() &lt;= videoEndPreTimeUs) { info.offset = 0; info.size = sampleSize; info.flags = MediaCodec.BUFFER_FLAG_SYNC_FRAME; info.presentationTimeUs = audioExtractor.getSampleTime(); mediaMuxer.writeSampleData(audioTrackIndex, buffer, info); audioExtractor.advance(); } } mVideoExtractor.release(); // 释放MediaExtractor audioExtractor.release(); mediaMuxer.stop(); mediaMuxer.release(); // 释放MediaMuxer} 12Video: format:{csd-1=java.nio.ByteArrayBuffer[position=0,limit=9,capacity=9], mime=video/avc, frame-rate=30, height=1080, width=1920, max-input-size=1572864, isDMCMMExtractor=1, durationUs=12425577, csd-0=java.nio.ByteArrayBuffer[position=0,limit=20,capacity=20]}Audio: format:{max-input-size=5532, aac-profile=2, mime=audio/mp4a-latm, durationUs=340101875, csd-0=java.nio.ByteArrayBuffer[position=0,limit=2,capacity=2], channel-count=2, sample-rate=44100} MP3转换为AAC使用 AndroidAudioConverterAndroidAudioConverter - https://github.com/adrielcafe/AndroidAudioConverter 基于FFmpeg的第三方库。支持格式有AAC, MP3, M4A, WMA, WAV 和 FLAC 使用方法： app/build.gradle123456789repositories { maven { url &quot;https://jitpack.io&quot; }}dependencies { compile 'com.github.adrielcafe:AndroidAudioConverter:0.0.8'} 申请读写外部存储权限12&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;在Application类中加载库1234567891011121314151617public class MuxerApp extends Application { @Override public void onCreate() { super.onCreate(); AndroidAudioConverter.load(this, new ILoadCallback() { @Override public void onSuccess() { // Great! } @Override public void onFailure(Exception error) { // FFmpeg is not supported by device } }); }}使用转换功能1234567891011121314151617181920212223242526final String sourceMP3Path = SOURCE_PATH + File.separator + &quot;music1.mp3&quot;;Log.d(TAG, &quot;转换开始 &quot; + sourceMP3Path);File srcFile = new File(sourceMP3Path);IConvertCallback callback = new IConvertCallback() { @Override public void onSuccess(File convertedFile) { Log.d(TAG, &quot;onSuccess: &quot; + convertedFile); } @Override public void onFailure(Exception error) { Log.e(TAG, &quot;onFailure: &quot;, error); }};AndroidAudioConverter.with(getApplicationContext()) // Your current audio file .setFile(srcFile) // Your desired audio format .setFormat(AudioFormat.AAC) // An callback to know when conversion is finished .setCallback(callback) // Start conversion .convert(); 在三星Note4上测试，转换13MB的MP3文件用了大约3分18秒。 参考 MediaExtractor - Android Developer MediaMuxer - Android Developer Java MP4 Parser Android音视频相关文章Android tutorial 2020","link":"/2018/03/01/Android/Android-MediaMuxer_MediaExtractor_mp4/"},{"title":"Android 模拟用户点击","text":"Android模拟用户点击。在自动化测试中可使用的工具。可以利用adb命令，也可以使用Android SDK中的monkeyrunner工具。 win7-64 gitbash 使用adb命令主要使用input命令123456usage: input ... input text &lt;string&gt; input keyevent &lt;key code number or name&gt; input tap &lt;x&gt; &lt;y&gt; input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;keyevent指的是android对应的keycode，比如home键的keycode=3，back键的keycode=4 tap是touch屏幕的事件，只需给出x、y坐标即可 swipe模拟滑动的事件，给出起点和终点的坐标即可 12345# 模拟点击位置 (100,100)adb shell input tap 100 100# 模拟滑动 从(650, 250)到(200,300)adb shell input swipe 650 250 200 300 编写一个bat脚本，模拟用户滑动1234567891011@echo offecho --------- Mock start ----------:tag_startecho running...adb shell input swipe 650 250 200 666@ping 127.0.0.1 -n 8 &gt;nulgoto tag_startecho --------- Mock finish ---------pause 死循环发送滑动命令，延时语句1@ping 127.0.0.1 -n 8 &gt;nul monkeyrunner环境配置，配置好Java与Android SDK的环境变量。手机连接到电脑。系统变量中加入ANDROID_SWT，此例中路径为G:\\SDK\\tools\\lib\\x86_64 修改后的脚本rustmonkeyrunner.bat，Windows环境下需要在gitbash或CMD里运行 来自unable-to-access-jarfile-framework-monkeyrunner-25-3-2-jar1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@echo offrem Copyright (C) 2010 The Android Open Source Projectremrem Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);rem you may not use this file except in compliance with the License.rem You may obtain a copy of the License atremrem http://www.apache.org/licenses/LICENSE-2.0remrem Unless required by applicable law or agreed to in writing, softwarerem distributed under the License is distributed on an &quot;AS IS&quot; BASIS,rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.rem See the License for the specific language governing permissions andrem limitations under the License.rem don't modify the caller's environmentsetlocalrem Set up prog to be the path of this script, including following symlinks,rem and set up progdir to be the fully-qualified pathname of its directory.set prog=%~f0rem Change current directory and drive to where the script is, to avoidrem issues with directories containing whitespaces.cd /d %~dp0rem Check we have a valid Java.exe in the path.set java_exe=call ..\\lib\\find_java.batif not defined java_exe goto :EOFfor /f %%a in (&quot;%APP_HOME%\\lib\\monkeyrunner-25.3.2.jar&quot;) do set jarfile=%%~nxaset frameworkdir=.set libdir=if exist %frameworkdir%\\%jarfile% goto JarFileOk set frameworkdir=..\\libif exist %frameworkdir%\\%jarfile% goto JarFileOk set frameworkdir=..\\framework:JarFileOkset jarpath=%frameworkdir%\\%jarfile%if not defined ANDROID_SWT goto QueryArch set swt_path=%ANDROID_SWT% goto SwtDone:QueryArch for /f &quot;delims=&quot; %%a in ('%frameworkdir%\\..\\bin\\archquery') do set swt_path=%frameworkdir%\\%%a:SwtDoneif exist &quot;%swt_path%&quot; goto SetPath echo SWT folder '%swt_path%' does not exist. echo Please set ANDROID_SWT to point to the folder containing swt.jar for your platform. exit /B:SetPathcall &quot;%java_exe%&quot; -Xmx512m &quot;-Djava.ext.dirs=%frameworkdir%;%swt_path%&quot; -Dcom.android.monkeyrunner.bindir=..\\..\\platform-tools -jar %jarpath% %* 运行脚本1234Administrator@rust-PC ~$ /cygdrive/g/SDK/tools/bin/rustmonkeyrunner.batJython 2.5.3 (2.5:c56500f08d34+, Aug 13 2012, 14:54:35)[Java HotSpot(TM) 64-Bit Server VM (Oracle Corporation)] on java1.8.0_77 首次运行时import模块迟迟没有反应1&gt;&gt;&gt; from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImage 尝试运行脚本an_test2.py 123456789101112131415161718192021222324252627282930import osprint(&quot;importing module...&quot;)from com.android.monkeyrunner import MonkeyRunner, MonkeyDevice, MonkeyImageprint(&quot;waiting for connection...&quot;)device = MonkeyRunner.waitForConnection()print(&quot;device found!&quot;)s_wid = int(device.getProperty(&quot;display.width&quot;)) # 获取屏幕宽度像素s_height = int(device.getProperty(&quot;display.height&quot;)) # 获取屏幕高度像素print(&quot;build.version.sdk &quot; + str(device.getProperty(&quot;build.version.sdk&quot;)))print(&quot;display.width &quot; + str(s_wid))print(&quot;display.height &quot; + str(s_height))drag_point_left_x = 20drag_point_right_x = s_wid - 20drag_point_y = s_height / 2for i in range(0, 10): print(&quot;current loop is &quot; + str(i)) device.drag((drag_point_right_x, drag_point_y), (drag_point_left_x, drag_point_y), 1.0, 50) print(&quot;waiting...&quot;) MonkeyRunner.sleep(1) print(&quot;continue&quot;) device.drag((drag_point_left_x, drag_point_y), (drag_point_right_x, drag_point_y), 0.5, 3) MonkeyRunner.sleep(3)print(&quot;-------- finish --------&quot;) 命令行直接执行，可以看到执行结果和相应的报错信息12345678910111213C:\\Users\\Administrator&gt;G:\\SDK\\tools\\bin\\rustmonkeyrunner.bat H:\\fisher_p\\py_ws\\an_test2.pyimporting module...waiting for connection...device found!build.version.sdk 23display.width 1440display.height 2560current loop is 0waiting...continuecurrent loop is 1# .....-------- finish --------测试中发现，脚本可以运行在系统app。若当前打开的是第三方app，会直接报错，获取不到相应信息 参考 monkeyrunner 获取系统信息 Android MonkeyDevice - Google","link":"/2018/02/05/Android/adb_mock_touch_and_monkeyrunner/"},{"title":"Android MediaCodec 编解码","text":"Android MediaCodec 使用方式使用MediaCodec进行编解码。输入H.264格式的数据，输出帧数据并发送给监听器。 H.264的配置创建并配置codec。配置codec时，若手动创建MediaFormat对象的话，一定要记得设置”csd-0”和”csd-1”这两个参数。“csd-0”和”csd-1”这两个参数一定要和接收到的帧对应上。 输入数据给codec输入数据时，如果对输入数据进行排队，需要检查排队队列的情况。例如一帧数据暂用1M内存，1秒30帧，排队队列有可能会暂用30M的内存。当内存暂用过高，我们需要采取一定的措施来减小内存占用。codec硬解码时会受到手机硬件的影响。若手机性能不佳，编解码的速度有可能慢于原始数据输入。不得已的情况我们可以将排队中的旧数据抛弃，输入新数据。 解码器性能对视频实时性要求高的场景，codec没有可用的输入缓冲区，mCodec.dequeueInputBuffer返回-1。为了实时性，这里会强制释放掉输入输出缓冲区mCodec.flush()。 问题1 - MediaCodec输入数据和输出数据数量之间有没有特定的关系对于MediaCodec，输入数据和输出数据数量之间有没有特定的关系？假设输入10帧的数据，可以得到多少次输出？ 实测发现，不能百分百保证输入输出次数是相等的。例如vivo x6 plus，输入30帧，能得到28帧结果。或者300次输入，得到298次输出。 异常1 - dequeueInputBuffer(0)一直返回-1某些手机长时间编解码后，可能会出现尝试获取codec输入缓冲区时下标一直返回-1。例如vivo x6 plus，运行约20分钟后，mCodec.dequeueInputBuffer(0)一直返回-1。 处理方法：如果一直返回-1，同步方式下尝试调用codec.flush()方法，异步方式下尝试codec.flush()后再调用codec.start()方法。 有一些手机解码速度太慢，有可能会经常返回-1。不要频繁调用codec.flush()，以免显示不正常。 代码示例 - 同步方式进行编解码这一个例子使用同步方式进行编解码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/** * 解码器 */public class CodecDecoder { private static final String TAG = &quot;CodecDecoder&quot;; private static final String MIME_TYPE = &quot;video/avc&quot;; private static final String CSD0 = &quot;csd-0&quot;; private static final String CSD1 = &quot;csd-1&quot;; private static final int TIME_INTERNAL = 1; private static final int DECODER_TIME_INTERNAL = 1; private MediaCodec mCodec; private long mCount = 0; // 媒体解码器MediaCodec用的 // 送入编解码器前的缓冲队列 // 需要实时监控这个队列所暂用的内存情况 在这里堵塞的话很容易引起OOM private Queue&lt;byte[]&gt; data = null; private DecoderThread decoderThread; private CodecListener listener; // 自定义的监听器 当解码得到帧数据时通过它发送出去 public CodecDecoder() { data = new ConcurrentLinkedQueue&lt;&gt;(); } public boolean isCodecCreated() { return mCodec!=null; } public boolean createCodec(CodecListener listener, byte[] spsBuffer, byte[] ppsBuffer, int width, int height) { this.listener = listener; try { mCodec = MediaCodec.createDecoderByType(Constants.MIME_TYPE); MediaFormat mediaFormat = createVideoFormat(spsBuffer, ppsBuffer, width, height); mCodec.configure(mediaFormat, null, null, 0); mCodec.start(); Log.d(TAG, &quot;decoderThread mediaFormat in:&quot; + mediaFormat); decoderThread = new DecoderThread(); decoderThread.start(); return true; } catch (Exception e) { e.printStackTrace(); Log.e(TAG, &quot;MediaCodec create error:&quot; + e.getMessage()); return false; } } private MediaFormat createVideoFormat(byte[] spsBuffer, byte[] ppsBuffer, int width, int height) { MediaFormat mediaFormat; mediaFormat = MediaFormat.createVideoFormat(MIME_TYPE, width, height); mediaFormat.setByteBuffer(CSD0, ByteBuffer.wrap(spsBuffer)); mediaFormat.setByteBuffer(CSD1, ByteBuffer.wrap(ppsBuffer)); mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible); return mediaFormat; } private long lastInQueueTime = 0; // 输入H.264帧数据 这里会监控排队情况 public void addData(byte[] dataBuffer) { final long timeDiff = System.currentTimeMillis() - lastInQueueTime; if (timeDiff &gt; 1) { lastInQueueTime = System.currentTimeMillis(); int queueSize = data.size(); // ConcurrentLinkedQueue查询长度时会遍历一次 在数据量巨大的情况下尽量少用这个方法 if (queueSize &gt; 30) { data.clear(); LogInFile.getLogger().e(&quot;frame queue 帧数据队列超出上限，自动清除数据 &quot; + queueSize); } data.add(dataBuffer.clone()); Log.e(TAG, &quot;frame queue 添加一帧数据&quot;); } else { LogInFile.getLogger().e(&quot;frame queue 添加速度太快,跳过此帧. timeDiff=&quot; + timeDiff); } } public void destroyCodec() { if (mCodec != null) { try { mCount = 0; if(data!=null) { data.clear(); data = null; } if(decoderThread!=null) { decoderThread.stopThread(); decoderThread = null; } mCodec.release(); mCodec = null; } catch (Exception e) { e.printStackTrace(); Log.d(TAG, &quot;destroyCodec exception:&quot; + e.toString()); } } } private class DecoderThread extends Thread { private final int INPUT_BUFFER_FULL_COUNT_MAX = 50; private boolean isRunning; private int inputBufferFullCount = 0; // 输入缓冲区满了多少次 public void stopThread() { isRunning = false; } @Override public void run() { setName(&quot;CodecDecoder_DecoderThread-&quot; + getId()); isRunning = true; while (isRunning) { try { if (data != null &amp;&amp; !data.isEmpty()) { int inputBufferIndex = mCodec.dequeueInputBuffer(0); if (inputBufferIndex &gt;= 0) { byte[] buf = data.poll(); ByteBuffer inputBuffer = mCodec.getInputBuffer(inputBufferIndex); if (null != inputBuffer) { inputBuffer.clear(); inputBuffer.put(buf, 0, buf.length); mCodec.queueInputBuffer(inputBufferIndex, 0, buf.length, mCount * TIME_INTERNAL, 0); mCount++; } inputBufferFullCount = 0; // 还有缓冲区可以用的时候重置计数 } else { inputBufferFullCount++; LogInFile.getLogger().e(TAG, &quot;decoderThread inputBuffer full. inputBufferFullCount=&quot; + inputBufferFullCount); if (inputBufferFullCount &gt; INPUT_BUFFER_FULL_COUNT_MAX) { mCount = 0; mCodec.flush(); // 在这里清除所有缓冲区 LogInFile.getLogger().e(TAG, &quot;mCodec.flush()...&quot;); } } } // Get output buffer index MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo(); int outputBufferIndex = mCodec.dequeueOutputBuffer(bufferInfo, 0); while (outputBufferIndex &gt;= 0) { final int index = outputBufferIndex; Log.d(TAG, &quot;releaseOutputBuffer &quot; + Thread.currentThread().toString()); final ByteBuffer outputBuffer = byteBufferClone(mCodec.getOutputBuffer(index)); Image image = mCodec.getOutputImage(index); if (null != image) { // 获取NV21格式的数据 final byte[] nv21 = ImageUtil.getDataFromImage(image, FaceDetectUtil.COLOR_FormatNV21); final int imageWid = image.getWidth(); final int imageHei = image.getHeight(); // 这里选择创建新的线程去发送数据 - 这是可优化的地方 new Thread(new Runnable() { @Override public void run() { listener.onDataDecoded(outputBuffer, mCodec.getOutputFormat().getInteger(MediaFormat.KEY_COLOR_FORMAT), nv21, imageWid, imageHei); } }).start(); } else { listener.onDataDecoded(outputBuffer, mCodec.getOutputFormat().getInteger(MediaFormat.KEY_COLOR_FORMAT), new byte[]{0}, 0, 0); } try { mCodec.releaseOutputBuffer(index, false); } catch (IllegalStateException ex) { android.util.Log.e(TAG, &quot;releaseOutputBuffer ERROR&quot;, ex); } outputBufferIndex = mCodec.dequeueOutputBuffer(bufferInfo, 0); } } catch (Exception e) { e.printStackTrace(); Log.e(TAG, &quot;decoderThread exception:&quot; + e.getMessage()); } try { Thread.sleep(DECODER_TIME_INTERNAL); } catch (InterruptedException e) { e.printStackTrace(); } } } } // deep clone byteBuffer private static ByteBuffer byteBufferClone(ByteBuffer buffer) { if (buffer.remaining() == 0) return ByteBuffer.wrap(new byte[]{0}); ByteBuffer clone = ByteBuffer.allocate(buffer.remaining()); if (buffer.hasArray()) { System.arraycopy(buffer.array(), buffer.arrayOffset() + buffer.position(), clone.array(), 0, buffer.remaining()); } else { clone.put(buffer.duplicate()); clone.flip(); } return clone; }} 代码示例 - 工具函数一些工具函数。比如从image中取出NV21格式的数据。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private byte[] getDataFromImage(Image image) { return getDataFromImage(image, COLOR_FormatNV21);}/** * 将Image根据colorFormat类型的byte数据 */private byte[] getDataFromImage(Image image, int colorFormat) { if (colorFormat != COLOR_FormatI420 &amp;&amp; colorFormat != COLOR_FormatNV21) { throw new IllegalArgumentException(&quot;only support COLOR_FormatI420 &quot; + &quot;and COLOR_FormatNV21&quot;); } if (!isImageFormatSupported(image)) { throw new RuntimeException(&quot;can't convert Image to byte array, format &quot; + image.getFormat()); } Rect crop = image.getCropRect(); int format = image.getFormat(); int width = crop.width(); int height = crop.height(); Image.Plane[] planes = image.getPlanes(); byte[] data = new byte[width * height * ImageFormat.getBitsPerPixel(format) / 8]; byte[] rowData = new byte[planes[0].getRowStride()]; int channelOffset = 0; int outputStride = 1; for (int i = 0; i &lt; planes.length; i++) { switch (i) { case 0: channelOffset = 0; outputStride = 1; break; case 1: if (colorFormat == COLOR_FormatI420) { channelOffset = width * height; outputStride = 1; } else if (colorFormat == COLOR_FormatNV21) { channelOffset = width * height + 1; outputStride = 2; } break; case 2: if (colorFormat == COLOR_FormatI420) { channelOffset = (int) (width * height * 1.25); outputStride = 1; } else if (colorFormat == COLOR_FormatNV21) { channelOffset = width * height; outputStride = 2; } break; } ByteBuffer buffer = planes[i].getBuffer(); int rowStride = planes[i].getRowStride(); int pixelStride = planes[i].getPixelStride(); int shift = (i == 0) ? 0 : 1; int w = width &gt;&gt; shift; int h = height &gt;&gt; shift; buffer.position(rowStride * (crop.top &gt;&gt; shift) + pixelStride * (crop.left &gt;&gt; shift)); for (int row = 0; row &lt; h; row++) { int length; if (pixelStride == 1 &amp;&amp; outputStride == 1) { length = w; buffer.get(data, channelOffset, length); channelOffset += length; } else { length = (w - 1) * pixelStride + 1; buffer.get(rowData, 0, length); for (int col = 0; col &lt; w; col++) { data[channelOffset] = rowData[col * pixelStride]; channelOffset += outputStride; } } if (row &lt; h - 1) { buffer.position(buffer.position() + rowStride - length); } } } return data;}/** * 是否是支持的数据类型 */private static boolean isImageFormatSupported(Image image) { int format = image.getFormat(); switch (format) { case ImageFormat.YUV_420_888: case ImageFormat.NV21: case ImageFormat.YV12: return true; } return false;}“csd-0”和”csd-1”是什么，对于H264视频的话，它对应的是sps和pps，对于AAC音频的话，对应的是ADTS，做音视频开发的人应该都知道，它一般存在于编码器生成的IDR帧之中。 得到的mediaFormat1mediaFormat in:{height=720, width=1280, csd-1=java.nio.ByteArrayBuffer[position=0,limit=7,capacity=7], mime=video/avc, csd-0=java.nio.ByteArrayBuffer[position=0,limit=13,capacity=13], color-format=2135033992} 存储图片的方法Image类在Android API21及以后功能十分强大。 1234567891011121314151617181920212223242526private static void dumpFile(String fileName, byte[] data) { FileOutputStream outStream; try { outStream = new FileOutputStream(fileName); } catch (IOException ioe) { throw new RuntimeException(&quot;Unable to create output file &quot; + fileName, ioe); } try { outStream.write(data); outStream.close(); } catch (IOException ioe) { throw new RuntimeException(&quot;failed writing data to file &quot; + fileName, ioe); }}private void compressToJpeg(String fileName, Image image) { FileOutputStream outStream; try { outStream = new FileOutputStream(fileName); } catch (IOException ioe) { throw new RuntimeException(&quot;Unable to create output file &quot; + fileName, ioe); } Rect rect = image.getCropRect(); YuvImage yuvImage = new YuvImage(getDataFromImage(image, COLOR_FormatNV21), ImageFormat.NV21, rect.width(), rect.height(), null); yuvImage.compressToJpeg(rect, 100, outStream);} NV21转bitmap的方法直接存入文件12345// in try catchFileOutputStream fos = new FileOutputStream(Environment.getExternalStorageDirectory() + &quot;/imagename.jpg&quot;);YuvImage yuvImage = new YuvImage(nv21bytearray, ImageFormat.NV21, width, height, null);yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, fos);fos.close(); 获得Bitmap对象的方法，这个方法耗时耗内存NV21 -&gt; yuvImage -&gt; jpeg -&gt; bitmap1234567// in try catchYuvImage yuvImage = new YuvImage(nv21bytearray, ImageFormat.NV21, width, height, null);ByteArrayOutputStream os = new ByteArrayOutputStream();yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, os);byte[] jpegByteArray = os.toByteArray();Bitmap bitmap = BitmapFactory.decodeByteArray(jpegByteArray, 0, jpegByteArray.length);os.close(); 参考 https://stackoverflow.com/questions/32276522/convert-nv21-byte-array-into-bitmap-readable-format codec选择YUV420格式输出OutputBuffer的问题假设codec选择的格式是COLOR_FormatYUV420Flexible1mediaFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Flexible);解码后，得到的格式是COLOR_QCOM_FormatYUV420SemiPlanar32m // 0x7FA30C041mCodec.getOutputFormat().getInteger(MediaFormat.KEY_COLOR_FORMAT)解码出来的ByteBuffer oBuffer = mCodec.getOutputBuffer(index);包含元素个数为1413120；记为nv21Codec而通过mCodec.getOutputImage(index)得到的image对象获取到的nv21数组元素个数为1382400；记为nv21，这些是我们想要的数据 对比这2个数组我们发现，前面的y部分是相同的。nv21前921600个元素是y数据，后460800个元素是uv数据。nv21Codec前921600个元素是y数据，之后的20480个字节都是0，再接下来的460800个元素是uv数据。最后的10240个字节是0 nv21和nv21Codec的uv部分存储顺序是相反的。 参考资料 Android: MediaCodec视频文件硬件解码,高效率得到YUV格式帧,快速保存JPEG图片(不使用OpenGL)(附Demo) Android: Image类浅析(结合YUV_420_888) Android MediaCodec stuff 雷霄骅(leixiaohua1020)的专栏 [总结]FFMPEG视音频编解码零基础学习方法 - 雷霄骅 Bilibili/ijkplayer - Github Android音视频相关文章请参考 https://rustfisher.com/tags/Android-Media/","link":"/2017/12/20/Android/Android-MediaCodec_use_demo/"},{"title":"PyQt QFileDialog 文件选择弹窗","text":"弹出文件选择框。可以自定义选择框的标题，默认位置，目标文件后缀 选择框弹出后，会阻塞UI线程。 PyQt5文件选择框的例子这里只选择一个bat文件。如果默认目录不存在，则查找当前目录1234567891011def _click_tu_choose_file_path_btn1(self): default_path = 'C:\\MY' if not os.path.exists(default_path): default_path = os.getcwd() dlg = QFileDialog(None, &quot;choose_bat_file&quot;, default_path, 'All Files(*.bat)') dlg.setFileMode(QFileDialog.AnyFile) if dlg.exec_(): selected_name = dlg.selectedFiles()[0] if selected_name: self.ma.tu_filePathTv1.setText(self.tr(selected_name))","link":"/2017/11/23/PyQt_note/PyQt-QFileDialog_use/"},{"title":"Python logging 基本用法","text":"本文记录logging模块的用法 创建文件logger.py 123456789101112131415import loggingLOG_FILE = 'app_history.log'logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(filename)s[line:%(lineno)d] %(levelname)s %(message)s', # datefmt='%Y_%m_%d_%H:%M:%S', filename=LOG_FILE, filemode='a')console = logging.StreamHandler()console.setLevel(logging.INFO)formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')console.setFormatter(formatter)logging.getLogger(LOG_FILE).addHandler(console) 调用1logger.logging.info(&quot;%-13s connected: %r&quot; % (ip_address, connected)) %(asctime)s 表示这个位置上是字符串形式的当前时间datefmt='%Y_%m_%d_%H:%M:%S' 指定了时间格式；我们也可以不指定时间格式 查看写出的log文件12017-11-23 13:39:35,295 - xxx.py[line:122] INFO [MainWindow] --------- App Starts ---------","link":"/2017/11/21/Python/Python-logging-use/"},{"title":"PyQt5 安装商业版","text":"对于Windows7上的Python2，需要如下工具： visual studio sip Qt(SDK) 如果电脑上已经装有了PyQt4，建议再装一份Python。与原来的分开。 win7安装社区版Visual Studio使用Visual Studio是为了它的编译工具和相关库。安装时选上Windows SDK。 对于VS2017来说，使用的是这个工具 “D:\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat”开始-所有程序-Visual Studio 2017-Visual Studio Tools vs安装路径 D:\\Microsoft Visual Studio环境变量12D:\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.11.25503\\bin\\Hostx64\\x64;D:\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.11.25503\\lib; Python2.7安装sipwin7 64位系统，但Python2.7是32位 下载sip源码包（例如sip-4.19.3），解压到任意位置。进入sip源码包，执行1python configure.py这里Python2.7安装在D:\\python27；于是sip位置在D:\\python27\\Lib\\site-packages\\sip-4.19.3打开vs的命令行，进入sip在Python中的目录，执行12nmakenmake install win7安装Qt5到Qt官网下载安装包。为了照顾32位的Python2.7，这里选择Qt 5.6.3 for Windows 32-bit (VS 2015, 869 MB) 添加到环境变量中1D:\\Qt\\Qt5\\5.6.3\\msvc2015\\bin;D:\\Qt\\Qt5\\Tools\\QtCreator\\bin win7编译安装商业版PyQt5Python2.7 123python configure.py --disable QtNfcnmakenmake install 参考PyQt5的README12345COMMERCIAL VERSIONIf you have the Commercial version of PyQt5 then you should also have alicense file that you downloaded separately. The license file must be copiedto the &quot;sip&quot; directory before starting to build PyQt5.我们把买来的license文件复制到sip目录下。 在E:\\ws\\doc\\PyQtCommercial\\PyQt5_commercial-5.9中，把付费后得到的pyqt-commercial.sip复制到sip目录下 使用vs2017的命令行工具！ python configure.py出现错误1Error: Use the --qmake argument to explicitly specify a working Qt qmake.网上说是因为没有配置好Qt SDK的原因可参考 PyQt setup for Qt 4.7.4解决错误后，会提示是否接受license。根据提示输入yes。 执行python configure.py --disable QtNfc1234Querying qmake about your Qt installation...Determining the details of your Qt installation...This is the commercial version of PyQt 5.9 (licensed under the PyQt CommercialLicense) for Python 2.7.13 on win32. nmake报错 cannot open file “msvcprt.lib”1fatal error LNK1104: cannot open file “msvcprt.lib” 把lib路径添加到环境变量 D:\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.11.25503\\lib; nmake报错 QtNfc.dll : fatal error LNK1169: one or more multiply defined symbols found123456789release\\QtNfc.dll : fatal error LNK1169: 找到一个或多个多重定义的符号NMAKE : fatal error U1077: “&quot;D:\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.11.25503\\bin\\HostX86\\x86\\link.EXE&quot;”: 返回代码“0x491”Stop.NMAKE : fatal error U1077: “&quot;D:\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.11.25503\\bin\\HostX86\\x86\\nmake.exe&quot;”: 返回代码“0x2”Stop.NMAKE : fatal error U1077: “cd”: 返回代码“0x2”Stop. 网上有相关的建议，把QtNfc“取消”掉，其实就是不编译QtNfc。 E:\\ws\\doc\\PyQtCommercial\\PyQt5_commercial-5.9&gt;python configure.py --disable QtNfc http://python.6.x6.nabble.com/error-building-QtNfc-td5185657.html nmake 需要一段时间。电脑比较差的话，大概要1个小时。nmake install 耗时约5分钟 试运行PyQt5导入PyQt5模块试一试123from PyQt5.QtCore import QTranslatorfrom PyQt5.QtGui import *from PyQt5.QtWidgets import * 对于Python2.7 PyQt5，使用pyinstaller来打包成exe文件1pyinstaller ui_main.py得到相应的文件目录 运行exe弹窗报错Qt platform plugin12this application failed to start because it could not find or load the Qt platform plugin &quot;windows&quot; in &quot;&quot;Reinstalling the application may fix this problem. 报错原因是找不到 Qt platform plugin在Qt5，在安装目录下可找到 D:\\Qt\\Qt5\\Tools\\QtCreator\\bin\\plugins\\platforms对于Python3，安装了GPL的PyQt5，可以找到 D:\\python35\\Lib\\site-packages\\PyQt5\\Qt\\plugins\\platforms 处理方法：不打包成一个单一的exe文件，使用pyinstaller ui_main.py生成文件目录在dist中，与exe文件同级的目录PyQt5/qt/plugins中，有platforms目录把platforms文件夹复制到与exe文件同级的位置即可 参考How to install PyQt5 on Windows for Python 2? 编译安装PyQt5的过程 安装sip的建议","link":"/2017/10/25/PyQt_note/PyQt-Install_licensed_PyQt/"},{"title":"find的使用","text":"比如删除～结尾的文件1find . -name &quot;*~&quot; -type f -print -exec rm -rf {} \\; 删除文件名有特定字符的文件1find . -name &quot;*abcd*&quot; -exec rm -f {} \\; 修改执行命令和文件类型，安装目录下所有apk文件1find . -name &quot;*.apk&quot; -type f -print -exec adb install {} \\; 找到所有的json文件并且删除1find . -name &quot;*.json&quot; -exec rm {} \\; 删除指定目录，比如删除所有的git目录1find . -type d -iname &quot;.git&quot; -exec rm -rf {} \\; 找到当前目录下所有的apk并安装1find . -name &quot;*.apk&quot; -exec adb install {} \\;","link":"/2017/10/10/Linux/find-use/"},{"title":"PyQt 适配不同屏幕分辨率","text":"在宽高为1366*768下设计开发的界面，到了2860*1620屏幕下会显示不正常。因为像素密度不同，2860*1620屏幕显示出来的控件很小。 适配方法 - 根据当前屏幕调整控件大小和位置初始化时获取到当前屏幕的宽高像素值。与原像素值相比求出比例self.ratio_wid，self.ratio_height。 找出所有的QWidget self.findChildren(QWidget)，遍历来改变大小和位置。 123456789101112131415161718192021222324252627282930313233343536from PyQt4.QtGui import QMainWindow, QApplication, QWidgetclass ReMainWindow(QMainWindow): def __init__(self, parent=None): # ........... self.app = QApplication.instance() # Calculate the ratio. Design screen is [1366, 768] screen_resolution = self.app.desktop().screenGeometry() self.hw_ratio = 768 / 1366 # height / width self.ratio_wid = screen_resolution.width() / 1366 if self.ratio_wid &lt; 1: self.ratio_wid = 1 self.ratio_height = screen_resolution.height() / 768 if self.ratio_height &lt; 1: self.ratio_height = 1 def _init_ui_size(self): &quot;&quot;&quot; Travel all the widgets and resize according to the ratio &quot;&quot;&quot; self._resize_with_ratio(self) for q_widget in self.findChildren(QWidget): # print q_widget.objectName() self._resize_with_ratio(q_widget) self._move_with_ratio(q_widget) # Don't deal with the text browser # for q_widget in self.findChildren(QAbstractScrollArea): # print q_widget.objectName() # self._resize_with_ratio(q_widget) # self._move_with_ratio(q_widget) def _resize_with_ratio(self, input_ui): input_ui.resize(input_ui.width() * self.ratio_wid, input_ui.height() * self.ratio_height) def _move_with_ratio(self, input_ui): input_ui.move(input_ui.x() * self.ratio_wid, input_ui.y() * self.ratio_height) 实践发现，不需要对QTextBrowser所属的QAbstractScrollArea处理。","link":"/2017/09/26/PyQt_note/PyQt-Adjust_screen_resolution/"},{"title":"PyQt 语言国际化","text":"PyQt4 语言国际化使用pylupdate4将界面的py文件转成ts文件。 进入py文件所在目录，执行转换命令。1/d/python27/Lib/site-packages/PyQt4/pylupdate4 ui_main.py -ts zh_CN.ts 得到zh_CN.ts文件。这个文件本质上是xml文件。当界面的py文件修改时，运行pylupdate4生成ts不会破坏原ts的翻译。 用Qt语言家（Linguist）打开zh_CN.ts文件。可以对相应的字符串进行翻译。点击“发布”可获得zh_CN.qm文件。这就是qt的语言资源文件，是一个二进制文件。 创建app时，先加载语言资源文件zh_CN.qm123456789101112if __name__ == '__main__': configs.init_configs() # 确定语言配置 app = QApplication(sys.argv) trans = QTranslator() # Setup locale, we need .qm files if configs.g_locale_type == configs.LOCALE_ZH_CH: trans.load(&quot;res/locale/zh_CN&quot;) # No need suffix .qm app.installTranslator(trans) main_d = FAMainWindow() main_d.show() sys.exit(app.exec_()) App运行中切换语言在程序运行时，我们可以选择当前显示的语言。不需要重新启动程序即可完成切换。 准备语言资源文件以英文和简体中文为例，想要切换语言，需要这2种语言包12$ /d/python27/Lib/site-packages/PyQt4/pylupdate4 ui_main.py -ts zh_CN.ts$ /d/python27/Lib/site-packages/PyQt4/pylupdate4 ui_main.py -ts en.ts借助Qt语言家发布得到en.qm和zh_CN.qm这2个文件，放在res/locale目录里 在UI上设置触发切换语言界面上需要按钮或菜单栏的action；需要持有QTranslator； 12345678910111213141516171819202122232425262728 self.trans = QTranslator() # 初始化时获取 QTranslator self._init_trans() # 添加了action来触发切换动作 self.connect(self.ma.actionEnglish, SIGNAL(&quot;triggered()&quot;), self._trigger_english) self.ma.action_ZhCN.triggered.connect(self._trigger_zh_cn)def _init_trans(self): ctx.read_locale_config() # 自定义的方法，用来读取json文件中的配置 if ctx.g_locale_type == ctx.LOCALE_ZH_CH: self._trigger_zh_cn() elif ctx.g_locale_type == ctx.LOCALE_EN: self._trigger_english()def _trigger_english(self): print &quot;[MainWindow] Change to English&quot; self.trans.load(&quot;res/locale/en&quot;) _app = QApplication.instance() # 获取app实例 _app.installTranslator(self.trans) self.ma.retranslateUi(self) ctx.change_to_en() # 将新的配置更新入json文件中def _trigger_zh_cn(self): print &quot;[MainWindow] Change to zh_CN&quot; self.trans.load(&quot;res/locale/zh_CN&quot;) _app = QApplication.instance() _app.installTranslator(self.trans) self.ma.retranslateUi(self) ctx.change_to_zh_cn()","link":"/2017/09/20/PyQt_note/PyQt-Locale/"},{"title":"PyQt 拖入","text":"PyQt支持拖入功能。比如拖入文件或者一段文本。 拖入文本定义了一个label继承自QLabel，初始化时设置允许拖入。 参见pyqt5-drag-and-drop1234567891011121314151617from PyQt5 import QtCorefrom PyQt5.QtWidgets import QMainWindow, QApplication, QListWidget, QAbstractItemViewclass CustomLabel(QLabel): def __init__(self, title, parent): super().__init__(title, parent) self.setAcceptDrops(True) def dragEnterEvent(self, e): if e.mimeData().hasFormat('text/plain'): e.accept() else: e.ignore() def dropEvent(self, e): self.setText(e.mimeData().text())直接调用这个类，将它添加到界面上去。 拖入文件，读取文件路径这里继承了QLabel。Ui_MainWindow是用designer画出来的界面。 12345678910111213141516171819202122232425262728293031from PyQt5 import QtCorefrom PyQt5.QtWidgets import QMainWindow, QApplication, QListWidget, QAbstractItemViewclass LabMainWindow(QMainWindow): def __init__(self): super(LabMainWindow, self).__init__() self.ma = Ui_MainWindow() self.ma.setupUi(self) self.drag_in_widget = DragInWidget(&quot;Drag in&quot;, self) def _init_ui(self): self.drag_in_widget.move(0, 0)class DragInWidget(QLabel): def __init__(self, title, parent): super().__init__(title, parent) self.setAcceptDrops(True) def dragEnterEvent(self, e): if e.mimeData().hasUrls(): e.accept() else: e.ignore() def dropEvent(self, e): for url in e.mimeData().urls(): path = url.toLocalFile() if os.path.isfile(path): print(path) QtWidgets.QFrame监听拖入事件监听到有效拖动事件后，利用QtCore.pyqtSignal把信息传递出去 1234567891011121314151617181920212223from PyQt5 import QtCorefrom PyQt5.QtWidgets import QMainWindow, QApplication, QListWidget, QAbstractItemViewclass DragInWidget(QtWidgets.QFrame): &quot;&quot;&quot; Drag files to this widget &quot;&quot;&quot; s_content = QtCore.pyqtSignal(str) # emit file path def __init__(self, parent): super(DragInWidget, self).__init__(parent) self.setAcceptDrops(True) def dragEnterEvent(self, e): if e.mimeData().hasUrls(): e.accept() else: e.ignore() def dropEvent(self, e): for url in e.mimeData().urls(): path = url.toLocalFile() if os.path.isfile(path): self.s_content.emit(path) print(path) 这个Frame可以覆盖在其他控件上面时，会拦截操作 QListWidget拖入事件向QListWidget拖入文件，获取文件路径 123456789101112131415161718192021222324from PyQt5 import QtCorefrom PyQt5.QtWidgets import QMainWindow, QApplication, QListWidget, QAbstractItemViewclass DragInWidget(QListWidget): &quot;&quot;&quot; Drag files to this widget &quot;&quot;&quot; s_content = QtCore.pyqtSignal(str) # emit file path def __init__(self, parent): super(DragInWidget, self).__init__(parent) self.setAcceptDrops(True) self.setDragDropMode(QAbstractItemView.InternalMove) def dragEnterEvent(self, e): if e.mimeData().hasUrls(): e.accept() else: e.ignore() def dropEvent(self, e): for url in e.mimeData().urls(): path = url.toLocalFile() if os.path.isfile(path): self.s_content.emit(path) print(path)","link":"/2017/09/19/PyQt_note/PyQt-Drag_and_drop/"},{"title":"PyQt 打包","text":"py2exePyQt4 中打包成EXE文件将某个GUI程序打包成EXE文件。 Python2.7，在PyCharm中直接执行这个文件。 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-from distutils.core import setupimport py2exeimport sysimport main_window_re# this allows to run it with a simple double click.sys.argv.append('py2exe')py2exe_options = { &quot;includes&quot;: [&quot;sip&quot;], &quot;dll_excludes&quot;: [&quot;MSVCP90.dll&quot;, ], &quot;compressed&quot;: 1, &quot;optimize&quot;: 2, &quot;ascii&quot;: 0, &quot;bundle_files&quot;: 1,}setup( name='Reliability_test', version=main_window_re.VERSION_NAME, windows=['main_window_re.py', ], zipfile=None, options={'py2exe': py2exe_options}) 尝试过3.6和3.5版本，py2exe都不能正常工作。 pyinstallerhttps://github.com/pyinstaller/pyinstaller/wiki/FAQ 由于电脑上安装了多个版本的Python，环境变量制定了Python2。这里使用3.5版本的pyinstaller来打包。注意--paths指定了路径。环境变量中并没有设置这个路径。我们指定去找PyQt5的依赖dll。 123-p DIR, --paths DIR A path to search for imports (like using PYTHONPATH). Multiple paths are allowed, separated by ';', or use this option multiple times 路径最好是加上引号，比如这里指定Qt5和PyQt5的路径1pyinstaller -p &quot;D:\\Qt\\Qt5\\5.6.3\\msvc2015\\bin&quot; -p &quot;D:\\Python27_qt5\\Lib\\site-packages\\PyQt5&quot; main_lab.py 1234567891011$ /d/python35/Scripts/pyinstaller --paths /d/python35/Lib/site-packages/PyQt5/Qt/bin --onefile main_lab.py106 INFO: PyInstaller: 3.2.1106 INFO: Python: 3.5.4rc1106 INFO: Platform: Windows-7-6.1.7601-SP1108 INFO: wrote E:\\ws\\eslab\\lab\\main_lab.spec109 INFO: UPX is not available.110 INFO: Extending PYTHONPATH with paths['E:\\\\ws\\\\eslab\\\\lab', 'D:\\\\python35\\\\Lib\\\\site-packages\\\\PyQt5\\\\Qt\\\\bin', 'E:\\\\ws\\\\eslab\\\\lab']...... 生成单个窗口EXE文件。1$ /d/python35/Scripts/pyinstaller --paths /d/python35/Lib/site-packages/PyQt5/Qt/bin -F -w main_lab.py 生成exe文件后，报了一个找不到lab模块的错误。这个模块刚好就是我们主界面所在的模块。将引用的模块名lab删掉。重新生成exe文件。12345from lab.file_utils import FileUtilsfrom lab.mainwindow import Ui_MainWindow####################################from file_utils import FileUtilsfrom mainwindow import Ui_MainWindow 运行exe找不到模块报错使用默认方式打包，得到exe与文件目录1pyinstaller main_lab.py将dist中的目录复制到另一台电脑，点击运行exe文件；提示找不到模块在主ui文件中，添加路径1234import sysimport ossys.path.append(os.getcwd()) # Prepare path 找不到模块，一般会报 ImportError: No module named 'xxx' 错误此时一般是找不到我们自己写的模块。12from my_package.ui_main import Ui_MainWindow # 显示指定了my_package 打包得到的exe会找不到这个包from my_widget import DragInWidget # 不显示指定package 否则打包得到的exe会找不到包而无法运行","link":"/2017/09/18/PyQt_note/PyQt-Pack_app/"},{"title":"Python 获取当前路径的方法","text":"本文链接 Python2.7 中获取路径的各种方法sys.path模块搜索路径的字符串列表。由环境变量PYTHONPATH初始化得到。sys.path[0]是调用Python解释器的当前脚本所在的目录。 sys.argv一个传给Python脚本的指令参数列表。sys.argv[0]是脚本的名字（由系统决定是否是全名）假设显示调用python指令，如python demo.py，会得到绝对路径；若直接执行脚本，如./demo.py，会得到相对路径。 os.getcwd()获取当前工作路径。在这里是绝对路径。https://docs.python.org/2/library/os.html#os.getcwd __file__获得模块所在的路径，可能得到相对路径。如果显示执行Python，会得到绝对路径。若按相对路径来直接执行脚本./pyws/path_demo.py，会得到相对路径。为了获取绝对路径，可调用os.path.abspath() os.path 中的一些方法os.path.split(path)将路径名称分成头和尾一对。尾部永远不会带有斜杠。如果输入的路径以斜杠结尾，那么得到的空的尾部。如果输入路径没有斜杠，那么头部位为空。如果输入路径为空，那么得到的头和尾都是空。https://docs.python.org/2/library/os.path.html#os.path.split os.path.realpath(path)返回特定文件名的绝对路径。https://docs.python.org/2/library/os.path.html#os.path.realpath 代码示例环境 Win7, Python2.7以/e/pyws/path_demo.py为例12345678910111213#!/usr/bin/env pythonimport osimport sysif __name__ == '__main__': print &quot;sys.path[0] =&quot;, sys.path[0] print &quot;sys.argv[0] =&quot;, sys.argv[0] print &quot;__file__ =&quot;, __file__ print &quot;os.path.abspath(__file__) =&quot;, os.path.abspath(__file__) print &quot;os.path.realpath(__file__) = &quot;, os.path.realpath(__file__) print &quot;os.path.dirname(os.path.realpath(__file__)) =&quot;, os.path.dirname(os.path.realpath(__file__)) print &quot;os.path.split(os.path.realpath(__file__)) =&quot;, os.path.split(os.path.realpath(__file__)) print &quot;os.getcwd() =&quot;, os.getcwd() 在/d中运行，输出为123456789$ python /e/pyws/path_demo.pysys.path[0] = E:\\pywssys.argv[0] = E:/pyws/path_demo.py__file__ = E:/pyws/path_demo.pyos.path.abspath(__file__) = E:\\pyws\\path_demo.pyos.path.realpath(__file__) = E:\\pyws\\path_demo.pyos.path.dirname(os.path.realpath(__file__)) = E:\\pywsos.path.split(os.path.realpath(__file__)) = ('E:\\\\pyws', 'path_demo.py')os.getcwd() = D:\\ 在e盘中用命令行直接执行脚本123456789$ ./pyws/path_demo.pysys.path[0] = E:\\pywssys.argv[0] = ./pyws/path_demo.py__file__ = ./pyws/path_demo.pyos.path.abspath(__file__) = E:\\pyws\\path_demo.pyos.path.realpath(__file__) = E:\\pyws\\path_demo.pyos.path.dirname(os.path.realpath(__file__)) = E:\\pywsos.path.split(os.path.realpath(__file__)) = ('E:\\\\pyws', 'path_demo.py')os.getcwd() = E:\\","link":"/2017/07/31/Python/Python-get-path/"},{"title":"PyQt 线程类 QThread","text":"PyQt中的线程类 QtCore.QThread，使用时继承QThread类 启动界面的线程暂称为UI线程。界面执行命令时都在自己的UI线程中。如果在UI线程中执行网络连接和数据库操作等耗时的操作，界面会被卡住，Windows下有可能会出现“无响应”的警告。阻塞UI线程会降低用户体验和应用稳定性。因此我们可以把耗时操作放在线程中去执行。 QThread代表一个线程，我们可以复写run函数来执行我们要的操作。QThread可以使用QtCore.pyqtSignal来与界面交互和传输数据。 PyQt4 QThread 代码示例 Python2.7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: utf-8 -*-import sysfrom PyQt4 import QtCorefrom PyQt4.QtCore import QCoreApplicationfrom PyQt4.QtGui import QWidget, QPushButton, QApplication, QTextBrowserclass TimeThread(QtCore.QThread): signal_time = QtCore.pyqtSignal(str, int) # 信号 def __init__(self, parent=None): super(TimeThread, self).__init__(parent) self.working = True self.num = 0 def start_timer(self): self.num = 0 self.start() def run(self): while self.working: print &quot;Working&quot;, self.thread() self.signal_time.emit(&quot;Running time:&quot;, self.num) # 发送信号 self.num += 1 self.sleep(1)class TimeDialog(QWidget): def __init__(self): super(TimeDialog, self).__init__() self.timer_tv = QTextBrowser(self) self.init_ui() self.timer_t = TimeThread() self.timer_t.signal_time.connect(self.update_timer_tv) def init_ui(self): self.resize(300, 200) self.setWindowTitle('TimeDialog') self.timer_tv.setText(&quot;Wait&quot;) self.timer_tv.setGeometry(QtCore.QRect(10, 145, 198, 26)) self.timer_tv.move(0, 15) btn1 = QPushButton('Quit', self) btn1.setToolTip('Click to quit') btn1.resize(btn1.sizeHint()) btn1.move(200, 150) btn1.clicked.connect(QCoreApplication.instance().quit) start_btn = QPushButton('Start', self) start_btn.setToolTip(&quot;Click to start&quot;) start_btn.move(50, 150) self.connect(start_btn, QtCore.SIGNAL(&quot;clicked()&quot;), self.click_start_btn) def click_start_btn(self): self.timer_t.start_timer() def update_timer_tv(self, text, number): self.timer_tv.setText(self.tr(text + &quot; &quot; + str(number)))if __name__ == '__main__': app = QApplication(sys.argv) time_dialog = TimeDialog() time_dialog.show() sys.exit(app.exec_()) QThread中使用的信号signal_time = QtCore.pyqtSignal(str, int) 指定了参数str和int发送信号self.signal_time.emit(&quot;Running time:&quot;, self.num) 外部接收信号self.timer_t.signal_time.connect(self.update_timer_tv)信号连接到方法update_timer_tv(self, text, number)，注意信号与方法的参数要一一对应 使用中我们可以定义多种不同的信号QtCore.pyqtSignal 启动线程，调用start()","link":"/2017/07/11/PyQt_note/PyQt-QThread/"},{"title":"Python 调用adb命令","text":"使用Python通过subprocess调用adb命令。 subprocess包主要功能是执行外部命令（相对Python而言）。和shell类似。 换言之除了adb命令外，利用subprocess可以执行其他的命令，比如ls，cd等等。 subprocess 可参考： https://docs.python.org/2/library/subprocess.html 在电脑上装好adb工具，配置好adb的环境变量，先确保shell中可以调用adb命令。 代码示例 Python2.7 类 Adb，封装了一些adb的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport subprocessclass Adb(object): &quot;&quot;&quot; Provides some adb methods &quot;&quot;&quot; @staticmethod def adb_devices(): &quot;&quot;&quot; Do adb devices :return The first connected device ID &quot;&quot;&quot; cmd = &quot;adb devices&quot; c_line = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0] if c_line.find(&quot;List of devices attached&quot;) &lt; 0: # adb is not working return None return c_line.split(&quot;\\t&quot;)[0].split(&quot;\\r\\n&quot;)[-1] # This line may have different format @staticmethod def pull_sd_dcim(device, target_dir='E:/files'): &quot;&quot;&quot; Pull DCIM files from device &quot;&quot;&quot; print &quot;Pulling files&quot; des_path = os.path.join(target_dir, device) if not os.path.exists(des_path): os.makedirs(des_path) print des_path cmd = &quot;adb pull /sdcard/DCIM/ &quot; + des_path result = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate() print result print &quot;Finish!&quot; return des_path @staticmethod def some_adb_cmd(): p = subprocess.Popen('adb shell cd sdcard&amp;&amp;ls&amp;&amp;cd ../sys&amp;&amp;ls', stdout=subprocess.PIPE, stderr=subprocess.PIPE) return_code = p.poll() while return_code is None: line = p.stdout.readline() return_code = p.poll() line = line.strip() if line: print line print &quot;Done&quot; some_adb_cmd方法执行一连串的命令。各个命令之间用&amp;&amp;连接。接着是一个死循环，将执行结果打印出来。 subprocess 说明creationflags=CREATE_NEW_CONSOLE在执行指令时弹出一个新的cmd窗口 可以执行指定的bat脚本 12345678910from _subprocess import CREATE_NEW_CONSOLEfrom subprocess import Popen def _click_new_cmd_window_btn(self): self.log.info(&quot;click_new_cmd_window_btn&quot;) Popen('cmd', creationflags=CREATE_NEW_CONSOLE) def _click_exe_bat_btn1(self): self.log.info(&quot;run bat&quot;) Popen('C:\\MYDIR\\_debug.bat', creationflags=CREATE_NEW_CONSOLE)","link":"/2017/07/05/Python/Python-adb-use/"},{"title":"Python 查看目录中的文件","text":"一些关于文件的操作例如，实现查看目录内容的功能。类似Linux下的tree命令。统计目录下指定后缀文件的行数。 功能是将目录下所有的文件路径存入list中。可以加入后缀判断功能，搜索指定的后缀名文件。主要利用递归的方法来检索文件。 仿造 tree 功能示例代码 Python2.7 列出目录下所有文件递归法123456789101112131415161718192021import osdef tree_dir(path, c_path='', is_root=True): &quot;&quot;&quot; Get file list under path. Like 'tree' :param path Root dir :param c_path Child dir :param is_root Current is root dir &quot;&quot;&quot; res = [] if not os.path.exists(path): return res for f in os.listdir(path): if os.path.isfile(os.path.join(path, f)): if is_root: res.append(f) else: res.append(os.path.join(c_path, f)) else: res.extend(tree_dir(os.path.join(path, f), f, is_root=False)) return res 下面是加入后缀判断的方法。在找到文件后，判断一下是否符合后缀要求。不符合要求的文件就跳过。1234567891011121314151617181920212223def tree_dir_sur(path, c_path='', is_root=True, suffix=''): &quot;&quot;&quot; Get file list under path. Like 'tree' :param path Root dir :param c_path Child dir :param is_root Current is root dir :param suffix Suffix of file &quot;&quot;&quot; res = [] if not os.path.exists(path) or not os.path.isdir(path): return res for f in os.listdir(path): if os.path.isfile(os.path.join(path, f)) and str(f).endswith(suffix): if is_root: res.append(f) else: res.append(os.path.join(c_path, f)) else: res.extend(tree_dir_sur(os.path.join(path, f), f, is_root=False, suffix=suffix)) return resif __name__ == &quot;__main__&quot;: for p in tree_dir_sur(os.path.join('E:\\ws', 'rnote', 'Python_note'), suffix='md'): print p 统计目录下指定后缀文件的行数仅适用os中的方法，仅检索目录中固定位置的文件 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import osdef count_by_categories(path): &quot;&quot;&quot; Find all target files and count the lines &quot;&quot;&quot; if not os.path.exists(path): return c_l_dict = dict() # e.g. {category: lines} category_list = [cate for cate in os.listdir(path) if os.path.isdir(os.path.join(path, cate)) and not cate.startswith('.')] for category_dir in category_list: line_count = _sum_total_line(os.path.join(path, category_dir), '.md') if line_count &gt; 0: c_l_dict[category_dir] = line_count return c_l_dictdef _sum_total_line(path, endswith='.md'): &quot;&quot;&quot; Get the total lines of target files &quot;&quot;&quot; if not os.path.exists(path) or not os.path.isdir(path): return 0 total_lines = 0 for f in os.listdir(path): if f.endswith(endswith): with open(os.path.join(path, f)) as cur_f: total_lines += len(cur_f.readlines()) return total_linesif __name__ == '__main__': note_dir = 'E:/ws/rnote' ca_l_dict = count_by_categories(note_dir) all_lines = 0 for k in ca_l_dict.keys(): all_lines += ca_l_dict[k] print 'all lines:', str(all_lines) print ca_l_dict 以笔记文件夹为例，分别统计分类目录下文件的总行数，测试输出12all lines: 25433{'flash_compile_git_note': 334, 'Linux_note': 387, 'Algorithm_note': 3637, 'Comprehensive': 216, 'advice': 137, 'Java_note': 3013, 'Android_note': 11552, 'DesignPattern': 2646, 'Python_note': 787, 'kotlin': 184, 'cpp_note': 279, 'PyQt_note': 439, 'reading': 686, 'backend': 1136}","link":"/2017/07/01/Python/Python-scan-file/"},{"title":"Android AsyncTask 使用与分析","text":"本文简单介绍Android中的AsyncTask，并从源码角度分析它的流程和特点。 AsyncTask有助于使用UI线程。这个类能让你不主动使用多线程或Handler，在UI线程进行后台操作并发布结果。是一个在不用多线程和Handler的情况下的帮助类。AsyncTask适用于短时间的操作（最多几秒）。如需长时间的线程操作，建议使用多线程包java.util.concurrent中的API，比如Executor，ThreadPoolExecutor 和 FutureTask AsyncTask任务的构成： 3种泛型：Params， Progress 和 Result 4个步骤：onPreExecute, doInBackground, onProgressUpdate 和 onPostExecute Google文档 用法简介虚构一个计算任务1234567891011121314151617181920212223242526272829303132333435363738394041424344 /** * 虚拟的计算任务 */ private class CalculationTask extends AsyncTask&lt;Float, Integer, Float&gt; { protected Float doInBackground(Float... inputs) { Log.d(TAG, &quot;doInBackground thread ID = &quot; + Thread.currentThread().getId()); long step = 0; float result = 0; for (float f : inputs) { // 假设这里有一些耗时的操作 result += f; } while (step &lt; 5) { result += step; step++; publishProgress((int) step); } return result; } protected void onProgressUpdate(Integer... progress) { Log.d(TAG, &quot;onProgressUpdate thread ID = &quot; + Thread.currentThread().getId()); Log.d(TAG, &quot;onProgressUpdate: &quot; + progress[0]); } protected void onPostExecute(Float result) { Log.d(TAG, &quot;onPostExecute thread ID = &quot; + Thread.currentThread().getId()); Log.d(TAG, &quot;任务执行完毕&quot;); } } // 执行任务 new CalculationTask().execute(1.2f, 2.3f, 6.3f);/*logcatMain thread ID = 1doInBackground thread ID = 8089onProgressUpdate thread ID = 1onProgressUpdate: 1...onProgressUpdate thread ID = 1onProgressUpdate: 5onPostExecute thread ID = 1任务执行完毕*/ AsyncTask 使用的的泛型AsyncTask使用的3种泛型 Params 送去执行的类型 Progress 后台计算的进度类型 Result 后台计算的结果 不用的泛型可以用Void表示。例如1private class MyTask extends AsyncTask&lt;Void, Void, Void&gt; { ... } 异步任务的4个步骤异步任务执行时经过4个步骤 onPreExecute() UI线程在任务开始前调用这个方法。此方法常用来设置任务，比如在屏幕上显示一个进度条。 doInBackground(Params...) onPreExecute()执行完毕后立即在后台线程中执行。这一步用来执行耗时的后台计算。这个方法接受异步任务的参数，返回最后的任务结果。这一步可以调用publishProgress(Progress...)通知出去一个或多个进度。这些进度值会被onProgressUpdate(Progress...)在UI线程收到。 onProgressUpdate(Progress...) 调用publishProgress(Progress...)后会在UI线程中执行。用来显示执行中任务的UI。 onPostExecute(Result) 后台任务执行完毕时被调用。最终结果会被传入这个方法。 取消任务调用cancel(boolean)可随时取消任务。取消任务后isCancelled()会返回true。调用这个方法后，后台任务doInBackground(Object[])执行完毕后会调用onCancelled(Object)而不再是onPostExecute(Object)。为保证任务能被及时地取消，在doInBackground(Object[])中应该经常检查isCancelled()返回值 线程规则 Threading rules一些线程规则 异步任务必须从UI线程启动 必须在UI线程实例化AsyncTask类 必须在UI线程调用execute(Params...) 不要手动调用onPreExecute(), onPostExecute(Result), doInBackground(Params...), onProgressUpdate(Progress...) 同一个异步任务实例只能被执行一次。重复执行同一个异步任务实例会抛出异常（IllegalStateException）。 源码简析需要解决的问题：AsyncTask是如何调用后台线程完成任务的？线程是如何调度的？ AsyncTask使用Executor，利用WorkerRunnable和FutureTask来执行后台任务123456private final WorkerRunnable&lt;Params, Result&gt; mWorker; // 实现了 Callableprivate final FutureTask&lt;Result&gt; mFuture;private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; { Params[] mParams;} 使用Handler来进行线程调度。内部定义了一个类InternalHandler。 从execute(Params... params)方法切入先看方法execute(Params... params)，使用默认执行器，并传入参数调用xecuteOnExecutor(Executor exec, Params... params)1234@MainThread // 指定在主线程执行public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params);} 先判断当前状态，如果状态不是Status.PENDING，则抛出异常。否则进入Status.RUNNING状态，执行onPreExecute()，再由执行器启动任务。1234567891011121314151617181920@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: // 同一个任务实例只能够执行一次 throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); // 开始进入后台线程执行任务 return this;} mWorker带着传进来的参数，mFuture实例化时已经将mWorker注入。参看构造函数1234567891011121314151617181920212223242526272829public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 在后台线程进行自定义的操作 这里面可以调用publishProgress方法 Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); // 发送最终结果 } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { // 依赖 mWorker @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } };} publishProgress方法通过主线程的Handler向外通知进度1234567@WorkerThreadprotected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); }} 后台任务执行完毕，postResult发送最终结果12345678910111213141516private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); // 会走到finish方法 return result;}private void finish(Result result) { if (isCancelled()) { onCancelled(result); // 如果任务已经被取消了 } else { onPostExecute(result); // 通知任务执行完毕 } mStatus = Status.FINISHED;} 关于默认执行器 sDefaultExecutor 和线程池源码中构建了一个线程池和一个自定义的执行器SerialExecutor。靠它们来执行后台任务。 参考源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class AsyncTask&lt;Params, Progress, Result&gt; { private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); // 核心线程至少2个，最多4个 private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE_SECONDS = 30; public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); } }; private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); public static final Executor THREAD_POOL_EXECUTOR; // 实际执行者 static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } // 默认执行器的类 private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } }}","link":"/2017/06/22/Android/Android-AsyncTask_use_and_RTFSC/"},{"title":"Android IntentService 分析和用法","text":"IntentService的分析和用法，实用性介绍。 IntentService 简介 IntentService继承自Service，可用startService启动，也需要在AndroidManifest.xml中注册 IntentService在一个单独的worker线程中处理任务 任务完成后，会自动停止 可多次启动同一个IntentService，它们会自一个接一个地排队处理 IntentService 与 Service耗时任务可以不用在Service中手动开启线程。当操作完成时，我们不用手动停止IntentService，它会自动判定停止。 IntentService 自动停止参考IntentService源码：12345678910111213141516171819202122232425262728293031private volatile ServiceHandler mServiceHandler;private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); // 传入startID }}@Overridepublic void onCreate() { super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);}@Overridepublic void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; // 这个是停止服务的依据 msg.obj = intent; mServiceHandler.sendMessage(msg);}利用ServiceHandler来控制生命周期。onCreate方法中开启了一个HandlerThread来处理请求。在onStart中获取到startId。在ServiceHandler中每次处理完一个命令都会调用stopSelf(int startId)方法来停止服务。IntentService直到命令队列中的所有命令被执行完后才会停止服务。 用法示例新建一个模拟计算的后台服务CalIntentService继承IntentService1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 模拟计算的后台服务 * Created by Rust on 2017/6/9. */public class CalIntentService extends IntentService { private static final String TAG = &quot;rustApp&quot;; private int mStartId = 0; /** * 一定要一个无参构造器 */ public CalIntentService() { this(&quot;cal_intent_service_name&quot;); } /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public CalIntentService(String name) { super(name); } @Override public void onStart(@Nullable Intent intent, int startId) { super.onStart(intent, startId); mStartId = startId; Log.d(TAG, &quot;[CalIntentService] onStart, startId=&quot; + mStartId); // 复写这个方法来看startId } @Override public void onDestroy() { super.onDestroy(); // 观察生命周期 Log.d(TAG, &quot;[CalIntentService] onDestroy. StartId=&quot; + mStartId); } @Override protected void onHandleIntent(@Nullable Intent intent) { if (null != intent) { String name = intent.getStringExtra(&quot;name&quot;); String msg = intent.getStringExtra(&quot;msg&quot;); Log.d(TAG, &quot;[CalIntentService] 收到 name:&quot; + name + &quot;, msg:&quot; + msg + &quot;, at &quot; + Thread.currentThread().toString()); } try { Thread.sleep(1000); // 模拟耗时操作 } catch (InterruptedException e) { e.printStackTrace(); } Log.d(TAG, &quot;[CalIntentService] 计算结束. mStartId=&quot; + mStartId); }} AndroidManifest中注册这个服务。目前只允许本App使用123&lt;service android:name=&quot;com.rustfisher.service.CalIntentService&quot; android:exported=&quot;false&quot; /&gt; Activity中启动这个服务123456789btn2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent calIntent = new Intent(getApplicationContext(), CalIntentService.class); calIntent.putExtra(&quot;name&quot;, &quot;Rust&quot;); calIntent.putExtra(&quot;msg&quot;, &quot;Click event: &quot; + mClickCount++); startService(calIntent); }}); 在手机上运行，快速点击几次按钮，启动IntentService，logcat输出12345678910111213[CalIntentService] onStart, startId=1[CalIntentService] 收到 name:Rust, msg:Click event: 0, at Thread[IntentService[cal_intent_service_name],5,main][CalIntentService] onStart, startId=2[CalIntentService] onStart, startId=3[CalIntentService] onStart, startId=4[CalIntentService] 计算结束. 最新StartId=4[CalIntentService] 收到 name:Rust, msg:Click event: 1, at Thread[IntentService[cal_intent_service_name],5,main][CalIntentService] 计算结束. 最新StartId=4[CalIntentService] 收到 name:Rust, msg:Click event: 2, at Thread[IntentService[cal_intent_service_name],5,main][CalIntentService] 计算结束. 最新StartId=4[CalIntentService] 收到 name:Rust, msg:Click event: 3, at Thread[IntentService[cal_intent_service_name],5,main][CalIntentService] 计算结束. 最新StartId=4[CalIntentService] onDestroy. StartId=4 可以看出，先执行onStart，然后排队执行onHandleIntent。任务全部结束后自行停止。","link":"/2017/06/09/Android/Android-IntentService-intro1/"},{"title":"Android Handler，Looper 与 MessageQueue 使用与分析","text":"Handler 简介一个Handler允许发送和处理Message，通过关联线程的 MessageQueue 执行 Runnable 对象。每个Handler实例都和一个单独的线程及其消息队列绑定。可以将一个任务切换到Handler所在的线程中去执行。一个用法就是子线程通过Handler更新UI。 Handler主要有2种用法： 做出计划，在未来某个时间点执行消息和Runnable 线程调度，在其他线程规划并执行任务 要使用好Handler，需要了解与其相关的 MessageQueue， Message和Looper；不能孤立的看Handler。Handler就像一个操作者（或者像一个对开发者开放的窗口），利用MessageQueue和Looper来实现任务调度和处理。 Handler持有 Looper 的实例，直接持有looper的消息队列。 属性与构造器Handler类中持有的实例，持有looper，messageQueue等等。123final Looper mLooper; // Handler持有Looper实例final MessageQueue mQueue; // Handler持有消息队列final Callback mCallback; 在Handler的构造器中，我们可以看到Handler获取了Looper的消息队列。12345678910111213public Handler(Callback callback, boolean async) { // 处理异常 mLooper = Looper.myLooper(); // 处理特殊情况... mQueue = mLooper.mQueue; // 获取的是Looper的消息队列}public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; // 获取的是Looper的消息队列 mCallback = callback; mAsynchronous = async;} Handler的使用方法Handler发送和处理消息的几个方法 void handleMessage( Message msg):处理消息的方法，该方法通常被重写。 final boolean hasMessage(int what):检查消息队列中是否包含有what属性为指定值的消息 final boolean hasMessage(int what ,Object object) :检查消息队列中是否包含有what好object属性指定值的消息 sendEmptyMessage(int what):发送空消息 final Boolean send EmptyMessageDelayed(int what ,long delayMillis):指定多少毫秒发送空消息 final boolean sendMessage(Message msg):立即发送消息 final boolean sendMessageDelayed(Message msg,long delayMillis):多少秒之后发送消息 Handler.sendEmptyMessage(int what) 流程解析获取一个Message实例，并立即将Message实例添加到消息队列中去。简要流程如下：123456789101112131415161718// 立刻发送一个empty消息sendEmptyMessage(int what) // 发送延迟为0的empty消息 这个方法里通过Message.obtain()获取一个Message实例sendEmptyMessageDelayed(what, 0) // 计算消息的计划执行时间，进入下一阶段sendMessageDelayed(Message msg, long delayMillis)// 在这里判断队列是否为null 若为null则直接返回falsesendMessageAtTime(Message msg, long uptimeMillis)// 将消息添加到队列中enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)// 接下来是MessageQueue添加消息// MessageQueue.javaboolean enqueueMessage(Message msg, long when)可以看到，最后是把message添加到了messageQueue中。 Handler 取消任务要取消任务时，调用下面这个方法removeCallbacksAndMessages(Object token)123public final void removeCallbacksAndMessages(Object token) { mQueue.removeCallbacksAndMessages(this, token);}通过调用Message.recycleUnchecked()方法，取消掉与此Handler相关联的Message。 相关的消息队列会执行取消指令1void removeCallbacksAndMessages(Handler h, Object object) 消息驱动与HandlerAndroid是消息驱动的，实现消息驱动有几个要素 消息的表示：Message 消息队列：MessageQueue 消息循环，用于循环取出消息进行处理：Looper 消息处理，消息循环从消息队列中取出消息后要对消息进行处理：Handler 初始化消息队列在Looper构造器中即创建了一个MessageQueue，Looper持有消息队列的实例。 发送消息通过Looper.prepare初始化好消息队列后就可以调用Looper.loop进入消息循环了，然后我们就可以向消息队列发送消息，消息循环就会取出消息进行处理，在看消息处理之前，先看一下消息是怎么被添加到消息队列的。 消息循环Java层的消息都保存在了Java层MessageQueue的成员mMessages中，Native层的消息都保存在了Native Looper的mMessageEnvelopes中，这就可以说有两个消息队列，而且都是按时间排列的。 Message 和 MessageQueue 简介与Handler工作的几个组件Looper、MessageQueue各自的作用： 1.Handler：它把消息发送给Looper管理的MessageQueue,并负责处理Looper分给它的消息 2.MessageQueue：管理Message，由Looper管理 3.Looper：每个线程只有一个Looper，比如UI线程中，系统会默认的初始化一个Looper对象，它负责管理MessageQueue，不断的从MessageQueue中取消息，并将相对应的消息分给Handler处理。 MessageMessage 属于被传递，被使用的角色。Message 是包含描述和任意数据对象的“消息”，能被发送给Handler。Message包含2个int属性和一个额外的对象。虽然构造器是公开的，但获取实例最好的办法是调用Message.obtain()或Handler.obtainMessage()。这样可以从他们的可回收对象池中获取到消息实例。一般来说，每个Message实例持有一个Handler。 Message部分属性值1234567/*package*/ Handler target; // 指定的Handler/*package*/ Runnable callback;// 可以组成链表// sometimes we store linked lists of these things/*package*/ Message next;从这里也不难看出，每个Message都持有Handler实例。如果Handler持有Activity的引用，Activity onDestroy后Message却仍然在队列中，因为Handler与Activity的强关联，会造成Activity无法被GC回收，导致内存泄露。因此在Activity onDestroy 时，与Activity关联的Handler应清除它的队列由Activity产生的任务，避免内存泄露。 重置自身的方法，将属性全部重置12public void recycle()void recycleUnchecked() 获取Message实例的常用方法，得到的实例与传入的Handler绑定1234567891011/** * Same as {@link #obtain()}, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned. * @param h Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member. * @return A Message object from the global pool. */public static Message obtain(Handler h) { Message m = obtain(); m.target = h; return m;} 将消息发送给Handler1234567/** * Sends this Message to the Handler specified by {@link #getTarget}. * Throws a null pointer exception if this field has not been set. */public void sendToTarget() { target.sendMessage(this); // target 就是与消息绑定的Handler}调用这个方法后，Handler会将消息添加进它的消息队列MessageQueue中。 MessageQueue持有一列可以被Looper分发的Message。一般来说由Handler将Message添加到MessageQueue中。获取当前线程的MessageQueue方法是Looper.myQueue()。通过Looper.getMainLooper()获取到主线程的looper。 Looper 简介Looper与MessageQueue紧密关联。在一个线程中运行的消息循环。线程默认情况下是没有与之管理的消息循环的。要创建一个消息循环，在线程中调用prepare，然后调用loop。即开始处理消息，直到循环停止。大多数情况下通过Handler来与消息循环互动。 Handler与Looper在线程中交互的典型例子1234567891011121314class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); // 为当前线程准备一个Looper // 创建Handler实例，Handler会获取当前线程的Looper // 如果实例化Handler时当前线程没有Looper，会报异常 RuntimeException mHandler = new Handler() { public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); // Looper开始运行 }} 调用了Looper.loop()之后，looper开始运行。当looper的messageQueue中没有消息时，相关的线程处于什么状态呢？查看looper的源码，看到loop方法里面有一个死循环。queue.next()方法是可能会阻塞线程的。如果从queue中获取到null，则表明此消息队列正在退出。此时looper的死循环也会被返回。123456for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; }调用looper的quit方法，实际上调用了mQueue.quit(false)。消息队列退出后，looper的loop死循环也被退出了。 进入MessageQueue的next方法去看，发现里面也有一个死循环。没有消息时，这个死循环会阻塞在nativePollOnce这个方法。123456Message next() { // ... for (;;) { // ... nativePollOnce(ptr, nextPollTimeoutMillis); // 处理message对象 我们知道Thread有New（新建，未运行），RUNNABLE（正常运行），BLOCKED，WAITING（线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll），TIMED_WAITING，TERMINATED（已经执行完毕）这几种状态。消息队列中没有消息，在nativePollOnce方法中“等待”。相关线程则处于RUNNABLE状态。 参考：https://stackoverflow.com/questions/38818642/android-what-is-message-queue-native-poll-once-in-android Looper中的属性Looper持有MessageQueue；唯一的主线程Looper sMainLooper；Looper当前线程 mThread；存储Looper的sThreadLocal123456// sThreadLocal.get() will return null unless you've called prepare().static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static Looper sMainLooper; // guarded by Looper.classfinal MessageQueue mQueue; // Handler会获取这个消息队列实例（参考Handler构造器）final Thread mThread; // Looper当前线程 ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。 Looper 方法准备方法，将当前线程初始化为Looper。退出时要调用quit12345678910public static void prepare() { prepare(true);}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); // Looper实例存入了sThreadLocal} prepare方法新建 Looper 并存入 sThreadLocal sThreadLocal.set(new Looper(quitAllowed))ThreadLocal&lt;T&gt;类12345678910111213141516171819public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);}public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; } return setInitialValue();} 当要获取Looper对象时，从sThreadLocal获取1234// 获取与当前线程关联的Looper，返回可以为nullpublic static @Nullable Looper myLooper() { return sThreadLocal.get();} 在当前线程运行一个消息队列。结束后要调用退出方法quit()1public static void loop() 准备主线程Looper。Android环境会创建主线程Looper，开发者不应该自己调用这个方法。UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。123456789public static void prepareMainLooper() { prepare(false); // 这里表示了主线程Looper不能由开发者来退出 synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); }} 获取主线程的Looper。我们开发者想操作主线程时，可调用此方法1public static Looper getMainLooper() 同一个Thread的不同Handler与UI线程对应的MainLooper，可以关联多个Handler。多个Handler之间的计划任务不会互相影响。比如有2个关联了UI线程的handler。123456789101112131415Handler mMainHandler1;Handler mMainHandler2;private void initUtils() { mMainHandler1 = new Handler(Looper.getMainLooper()); mMainHandler2 = new Handler(Looper.getMainLooper()); Log.d(TAG, &quot;mMainHandler1 post 任务&quot;); mMainHandler1.postDelayed(new Runnable() { @Override public void run() { Log.d(TAG, &quot;mMainHandler1的演示任务已执行&quot;); } }, 1500); mMainHandler2.removeCallbacksAndMessages(null);}mMainHandler2取消它的任务并不会影响mMainHandler1。","link":"/2017/06/07/Android/Android-Handler_src_note/"},{"title":"Python 操作 MySQL","text":"本文链接Python 操作 MySQL 开发环境与配置 win_x64 Ubuntu14.04 Python3.x pip安装pymysql模块直接使用pip安装 pip install pymysqlwin64上直接在cmd中执行 连接本地数据库使用模块pymysql连接数据库本地数据库相关配置请参阅： https://rustfisher.com/2019/02/26/Database/MySQL-install_and_config_Mac/ https://rustfisher.com/2017/02/25/Database/MySQL-install_and_config_Windows/ 123456789101112131415161718#!/usr/bin/python# coding=utf-8import pymysql# 连接本地数据库conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='yourpwd', db='samp_db1', charset='utf8')cursor = conn.cursor()cursor.execute('select * from bigstu')for row in cursor.fetchall(): print(row)# 查cursor.execute('select id, name from bigstu where age &gt; 22')for res in cursor.fetchall(): print(str(res[0]) + &quot;, &quot; + res[1])cursor.close()print('-- end --') 输出：1234567(1, '张三', '男', 24, datetime.date(2017, 3, 29), '13666665555')(6, '小刚', '男', 23, datetime.date(2017, 3, 11), '778899888')(8, '小霞', '女', 20, datetime.date(2017, 3, 13), '13712345678')(12, '小智', '男', 21, datetime.date(2017, 3, 7), '13787654321')1, 张三6, 小刚-- end -- 可以直接执行sql语句。获得的结果是元组。 sql相似条件查询 1SELECT * FROM anindex.subject_basic_table where season_id having '2018'; 增插入数据插入一条数据，接上面的代码 1234insertSql = &quot;insert into bigstu (name, sex, age, mobile) values ('%s','%s',%d,'%s') &quot;xiuji = ('秀吉', '男', 15, '13400001111')cursor.execute(insertSql % xiuji)conn.commit() # 别忘了提交 添加列在mobile后面添加一列cash12addCo = &quot;alter table bigstu add cash int after mobile&quot;cursor.execute(addCo) 如果要设置默认值12addCo = &quot;alter table bigstu add cash int default 0 after mobile&quot;cursor.execute(addCo) 删删除数据删除 name=秀吉 的数据12deleteSql = &quot;delete from bigstu where name = '%s'&quot;cursor.execute(deleteSql % '秀吉') 删除列删除cash列12dropCo = &quot;alter table bigstu drop cash&quot;cursor.execute(dropCo) 改修改数据更新符合条件的数据 1234updateSql = &quot;update bigstu set sex = '%s' where name = '%s'&quot;updateXiuji = ('秀吉', '秀吉') # 秀吉的性别是秀吉cursor.execute(updateSql % updateXiuji)conn.commit() 事物处理给某个记录的cash增加1234567891011table = &quot;bigstu&quot;addCash = &quot;update &quot; + table + &quot; set cash = cash + '%d' where name = '%s'&quot;lucky = (1000, &quot;秀吉&quot;)try: cursor.execute(addCash % lucky)except Exception as e: conn.rollback() print(&quot;加钱失败了&quot;)else: conn.commit() 直接执行SQL语句，十分方便 代码片段给数据库添加列从json中读取需要添加的列名，获取当前2个表中所有的列名整理得出需要插入的列名，然后将列插入到相应的表中 1234567891011121314151617181920212223242526272829303132333435363738import pymysqlimport jsonimport osimport secureUtilsmapping_keys = json.load(open(&quot;key_mapping_db.json&quot;, &quot;r&quot;))db_keys = [] # json中所有的keyfor k in mapping_keys.values(): db_keys.append(k)conn = pymysql.connect(host='localhost', port=3306, user='root', passwd='*****', db='db_name', charset='utf8')cursor = conn.cursor()table_main = &quot;table_main&quot;main_table_keys = [] # 主表的列名cursor.execute(&quot;show columns from &quot; + table_main)for row in cursor.fetchall(): main_table_keys.append(row[0])staff_table_keys = []cursor.execute(&quot;show columns from table_second&quot;)for row in cursor.fetchall(): staff_table_keys.append(row[0])need_to_insert_keys = []for k in db_keys: if k not in staff_table_keys and k not in main_table_keys and k not in need_to_insert_keys: need_to_insert_keys.append(k)print(&quot;need to insert &quot; + str(len(need_to_insert_keys)))print(need_to_insert_keys)for kn in need_to_insert_keys: print(&quot;add key to db &quot; + kn) cursor.execute(&quot;alter table staff_table add &quot; + kn +&quot; text&quot;)conn.close() 将字段字符改变这里将main_table_keys中的所有字段改为utf812345# change column character set to utf8for co in main_table_keys: change_sql = &quot;alter table &quot; + table_main + &quot; modify &quot; + co + &quot; text character set utf8&quot; print(change_sql) cursor.execute(change_sql)","link":"/2017/05/25/Python/Python-mysql_use/"},{"title":"Python3 Dictionary与JSON","text":"JSON与Dictionary简介 Python3 PyCharm CE JSON简介JSON(JavaScript Object Notation)是一种轻量级的数据交换格式。它是一种文本格式。它的结构主要由键值对来构成。一个键（key）对应一个值（value）。最外围用大括号{ }包围起来。例如1234{ &quot;firstName&quot;: &quot;Rust&quot;, &quot;lastName&quot;: &quot;Fisher&quot;} 大括号括起来的叫做对象结构。 JSON里也可以放数组。用中括号[ ]括起来。叫做数组结构。12345678910111213{ &quot;desc&quot;:&quot;这个是一个简单的例子&quot;, &quot;userInfo&quot;:{ &quot;firstName&quot;:&quot;Rust&quot;, &quot;lastName&quot;:&quot;Fisher&quot; }, &quot;books&quot;:[ &quot;Python入门&quot;, &quot;Python进阶&quot;, &quot;数据分析&quot;, &quot;可视化&quot; ]} 对象结构和数组结构可以同时存在，只要满足键值对的要求即可。 最外层也可以是中括号括起来的，里面存放着多个对象。123456789101112131415[ { &quot;firstName&quot;: &quot;Tom&quot;, &quot;lastName&quot;: &quot;Hanks&quot;, &quot;movies&quot;: [&quot;Cast Away&quot;] }, { &quot;userInfo&quot;: { &quot;firstName&quot;: &quot;Rust&quot;, &quot;lastName&quot;: &quot;Fisher&quot; }, &quot;books&quot;: [&quot;Python入门&quot;, &quot;Python进阶&quot;], &quot;desc&quot;: &quot;可以直接添加一个key-value进去&quot; }] Python的Dictionary（字典）简介Dictionary（以下简称为dict或字典）是一种键值对数据结构。有点像Java里的Map和Set。 初始化一个dict可以直接用大括号。里面写上key和value。12345678910def use_dict(): user_info = {'firstName': 'Rust', 'lastName': 'Fisher'} books = ['Python入门'] books.append('Python进阶') result = {'userInfo': user_info, 'books': books} result['desc'] = '可以直接添加一个key-value进去' print(result)# 运行结果# {'userInfo': {'firstName': 'Rust', 'lastName': 'Fisher'}, 'books': ['Python入门', 'Python进阶'], 'desc': '可以直接添加一个key-value进去'}可以看到，dict和JSON有些类似。都是键值对，都有数组结构。从Python语法上来看，dict操作起来也比较简单。找到确定的key后，可以直接赋值。 Dictionary 转为JSONPython中的dict是一种键值对的数据结构。JSON是一种轻量级的数据交换格式，它是一种文本格式。它们都是以键值对为基础。那么它们应该能相互转换。 将dict转为JSON，这里利用json包里提供的dumps方法。 dumps方法将传入的dict转换成JSON格式的文本。 引入json包1import json 我们写出了第一个dict转JSON的方法1234def to_json1(input_dict): print('input:', input_dict) jsonTxt = json.dumps(input_dict) print(jsonTxt) 输出：12input: {'userInfo': {'firstName': 'Rust', 'lastName': 'Fisher'}, 'books': ['Python入门', 'Python进阶'], 'desc': '可以直接添加一个key-value进去'}{&quot;userInfo&quot;: {&quot;firstName&quot;: &quot;Rust&quot;, &quot;lastName&quot;: &quot;Fisher&quot;}, &quot;books&quot;: [&quot;Python\\u5165\\u95e8&quot;, &quot;Python\\u8fdb\\u9636&quot;], &quot;desc&quot;: &quot;\\u53ef\\u4ee5\\u76f4\\u63a5\\u6dfb\\u52a0\\u4e00\\u4e2akey-value\\u8fdb\\u53bb&quot;} 中文字符都变成了字母和数字符号。这有点出乎我们意料。 涉及到中文字符的时候，需要dumps方法里指定ensure_ascii=False 1234def to_json2(input_dict): print('input:', input_dict) jsonTxt = json.dumps(input_dict, ensure_ascii=False) print(jsonTxt) 输出:12input: {'userInfo': {'firstName': 'Rust', 'lastName': 'Fisher'}, 'books': ['Python入门', 'Python进阶'], 'desc': '可以直接添加一个key-value进去'}{&quot;userInfo&quot;: {&quot;firstName&quot;: &quot;Rust&quot;, &quot;lastName&quot;: &quot;Fisher&quot;}, &quot;books&quot;: [&quot;Python入门&quot;, &quot;Python进阶&quot;], &quot;desc&quot;: &quot;可以直接添加一个key-value进去&quot;}这样中文字符就ok了。 list转为JSONlist中存储着多个dict。可以直接把list转为JSON。 接上面的代码 1234567def list_json_demo(): tom_hanks = {'firstName': 'Tom', 'lastName': 'Hanks', 'movies': ['Cast Away']} info = use_dict() list = [tom_hanks, info] jsonTxt = json.dumps(list, ensure_ascii=False) print(jsonTxt) return jsonTxt 输出的JSON部分：1[{&quot;firstName&quot;: &quot;Tom&quot;, &quot;lastName&quot;: &quot;Hanks&quot;, &quot;movies&quot;: [&quot;Cast Away&quot;]}, {&quot;userInfo&quot;: {&quot;firstName&quot;: &quot;Rust&quot;, &quot;lastName&quot;: &quot;Fisher&quot;}, &quot;books&quot;: [&quot;Python入门&quot;, &quot;Python进阶&quot;], &quot;desc&quot;: &quot;可以直接添加一个key-value进去&quot;}] 读取JSON文本用json.loads方法将输入的JSON文本转为对象。 123def json_to_dict1(jsonTxt): obj1 = json.loads(jsonTxt) print(obj1) 得到的对象可能是数组或者是dict。 读取JSON文件先打开文件，用json.load方法，读取JSON内容123with open(json_file_path) as json_file: json_content = json.load(json_file) # 读取出来的是dict # ...","link":"/2017/05/05/Python/Python-dictionary-JSON-file/"},{"title":"pip 相关","text":"Ubuntu 14.04 pip 使用国内镜像源使用pip install 的时候总是出现read timeout 之类的错误 使用国内镜像 https://pypi.tuna.tsinghua.edu.cn/simple例如我要安装 scrapy1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple scrapy 添加源的配置 Linux下，修改 ~/.pip/pip.conf (没有就创建一个)， 修改 index-url至tuna，内容如下：12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple pip install 出错1234567891011121314151617181920212223$ pip install pycairoCollecting pycairo Downloading https://files.pythonhosted.org/packages/e8/9d/c8be300fc6b1298559d37a071c3833b0b251e0fff334d2e4c408d5789162/pycairo-1.19.1.tar.gz (205kB) 100% |████████████████████████████████| 215kB 644kB/s Installing collected packages: pycairo Running setup.py install for pycairo ... error Complete output from command /Users/rustfisher/Desktop/intGo/studySR/venv/bin/python -u -c &quot;import setuptools, tokenize;__file__='/private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-jhvl5plj/pycairo/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\\r\\n', '\\n');f.close();exec(compile(code, __file__, 'exec'))&quot; install --record /private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-record-dqg8zbp0/install-record.txt --single-version-externally-managed --compile --install-headers /Users/rustfisher/Desktop/intGo/studySR/venv/include/site/python3.7/pycairo: running install running build running build_py creating build creating build/lib.macosx-10.9-x86_64-3.7 creating build/lib.macosx-10.9-x86_64-3.7/cairo copying cairo/__init__.py -&gt; build/lib.macosx-10.9-x86_64-3.7/cairo copying cairo/__init__.pyi -&gt; build/lib.macosx-10.9-x86_64-3.7/cairo copying cairo/py.typed -&gt; build/lib.macosx-10.9-x86_64-3.7/cairo running build_ext [Errno 20] Not a directory: 'pkg-config' ----------------------------------------Command &quot;/Users/rustfisher/Desktop/intGo/studySR/venv/bin/python -u -c &quot;import setuptools, tokenize;__file__='/private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-jhvl5plj/pycairo/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\\r\\n', '\\n');f.close();exec(compile(code, __file__, 'exec'))&quot; install --record /private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-record-dqg8zbp0/install-record.txt --single-version-externally-managed --compile --install-headers /Users/rustfisher/Desktop/intGo/studySR/venv/include/site/python3.7/pycairo&quot; failed with error code 1 in /private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-jhvl5plj/pycairo/You are using pip version 10.0.1, however version 20.2.2 is available.You should consider upgrading via the 'pip install --upgrade pip' command. 用brew安装pkg-config12345 $ brew install pkg-config==&gt; Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/pkg-config-0.29.2_3.mojave.bottle.tar.g######################################################################## 100.0%==&gt; Pouring pkg-config-0.29.2_3.mojave.bottle.tar.gz🍺 /usr/local/Cellar/pkg-config/0.29.2_3: 11 files, 623.6KB 然后再运行pip install pycairo。出现错误 Collecting pycairo Using cached pycairo-1.19.1.tar.gz (205 kB)Using legacy setup.py install for pycairo, since package ‘wheel’ is not installed.Installing collected packages: pycairo Running setup.py install for pycairo … error ERROR: Command errored out with exit status 1: command: /Library/Frameworks/Python.framework/Versions/3.7/bin/python3.7 -u -c ‘import sys, setuptools, tokenize; sys.argv[0] = ‘“‘“‘/private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-_fvz20yx/pycairo/setup.py’”‘“‘; file=’”‘“‘/private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-_fvz20yx/pycairo/setup.py’”‘“‘;f=getattr(tokenize, ‘“‘“‘open’”‘“‘, open)(file);code=f.read().replace(‘“‘“‘\\r\\n’”‘“‘, ‘“‘“‘\\n’”‘“‘);f.close();exec(compile(code, file, ‘“‘“‘exec’”‘“‘))’ install –record /private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-record-0xkj4in4/install-record.txt –single-version-externally-managed –compile –install-headers /Library/Frameworks/Python.framework/Versions/3.7/include/python3.7m/pycairo cwd: /private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-_fvz20yx/pycairo/ Complete output (15 lines): running install running build running build_py creating build creating build/lib.macosx-10.9-x86_64-3.7 creating build/lib.macosx-10.9-x86_64-3.7/cairo copying cairo/init.py -&gt; build/lib.macosx-10.9-x86_64-3.7/cairo copying cairo/init.pyi -&gt; build/lib.macosx-10.9-x86_64-3.7/cairo copying cairo/py.typed -&gt; build/lib.macosx-10.9-x86_64-3.7/cairo running build_ext Package cairo was not found in the pkg-config search path. Perhaps you should add the directory containing `cairo.pc’ to the PKG_CONFIG_PATH environment variable No package ‘cairo’ found Command &apos;[&apos;pkg-config&apos;, &apos;--print-errors&apos;, &apos;--exists&apos;, &apos;cairo &gt;= 1.13.1&apos;]&apos; returned non-zero exit status 1. ---------------------------------------- ERROR: Command errored out with exit status 1: /Library/Frameworks/Python.framework/Versions/3.7/bin/python3.7 -u -c ‘import sys, setuptools, tokenize; sys.argv[0] = ‘“‘“‘/private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-_fvz20yx/pycairo/setup.py’”‘“‘; file=’”‘“‘/private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-install-_fvz20yx/pycairo/setup.py’”‘“‘;f=getattr(tokenize, ‘“‘“‘open’”‘“‘, open)(file);code=f.read().replace(‘“‘“‘\\r\\n’”‘“‘, ‘“‘“‘\\n’”‘“‘);f.close();exec(compile(code, file, ‘“‘“‘exec’”‘“‘))’ install –record /private/var/folders/ds/b1cvbdm97dz7bynp0xzr3f7c0000gn/T/pip-record-0xkj4in4/install-record.txt –single-version-externally-managed –compile –install-headers /Library/Frameworks/Python.framework/Versions/3.7/include/python3.7m/pycairo Check the logs for full command output. 执行brew install cairo pkg-config freetype harfbuzz，把这几个包安装一下。然后再pip install pycairo，安装成功。","link":"/2017/04/29/Python/Python-pip-solution/"},{"title":"适配器模式 Adapter Pattern - Java实现","text":"定义将一个类的接口变换成客户端锁期待的另一种接口，从而使原本因接口不匹配而无法工作在一起的两个类能够在一起工作。也叫作变压器模式，亦称包装模式，但包装模式不止一个。简单而言，适配器模式就是把一个接口或类转换成其他的接口或类。 应用优点： 可以让没有任何关系的类在一起运行 增加了类的透明性 提高了类的复用度 灵活度好 注意事项：在详细阶段不要考虑适配器模式，它主要是用来解决正在服役的项目问题 代码示例向已运行的系统添加新增的用户类型文件目录如下123456789101112adapter/├── sadapter // 新增的适配器代码│ ├── SecondUserAdapter.java│ ├── SecondUserAddress.java│ └── SecondUser.java├── stable // 已经在运行的代码，不可变│ ├── FirstUser.java│ └── IFirstUser.java├── TestAdapter.java // 测试代码└── updated // 第三方提供的接口，不可变 ├── ISecondUserAddress.java └── ISecondUser.java 首先看已经在运行的部分 （stable）12345678910111213141516public interface IFirstUser { void printInfo();}public class FirstUser implements IFirstUser { private String username; public FirstUser(String username) { this.username = username; } @Override public void printInfo() { System.out.println(this.username); }} 再看按需求添加的部分 （updated）123456public interface ISecondUser { void printUsername();}public interface ISecondUserAddress { void printAddress();} 为此新建的适配器 （sadapter）分别新建2个类来实现接口123456789101112131415161718192021222324252627public class SecondUser implements ISecondUser { private String username; public SecondUser(String name) { this.username = name; } @Override public void printUsername() { System.out.print(username + &quot; &quot;); }}public class SecondUserAddress implements ISecondUserAddress { private String addr; public SecondUserAddress(String address) { this.addr = address; } @Override public void printAddress() { System.out.print(this.addr); }} 适配器持有这两个接口的引用，并实现原有的接口12345678910111213141516public class SecondUserAdapter implements IFirstUser { private ISecondUser iSecondUser; private ISecondUserAddress iSecondUserAddress; public SecondUserAdapter(ISecondUser iSecondUser, ISecondUserAddress iSecondUserAddress) { this.iSecondUser = iSecondUser; this.iSecondUserAddress = iSecondUserAddress; } @Override public void printInfo() { iSecondUser.printUsername(); iSecondUserAddress.printAddress(); }} 适配器构建完毕，测试代码12345IFirstUser user1 = new FirstUser(&quot;User1&quot;);user1.printInfo();SecondUserAdapter userAdapter = new SecondUserAdapter(new SecondUser(&quot;SUser2&quot;),new SecondUserAddress(&quot;5 street&quot;));userAdapter.printInfo();output12User1SUser2 5 street最吸引人的地方就是适配器实现了原有的接口。需求变化时，可尽量少的改动已有代码。 参考：《设计模式之禅》 秦小波","link":"/2017/03/26/DesignPattern/Adapter-Pattern/"},{"title":"Android NDK 读写文件","text":"开发环境与工具： win7_x64，Android Studio 2.2.3, Cygwin 使用NDK，就进入了Linux的世界。理解了这一点，很多事情就好办了。需要熟悉C语言操作文件的方式。 准备事项申请权限申请SD卡的读写权限12&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; 6.0开始需要动态申请权限。 使用Linux中的文件绝对路径手机sd卡中存放着文件。目录为 /sdcard/hello.txt和/sdcard/egdir/csv/eg_data.csv。 读写示例文件目录1234jni/|-- Android.mk|-- com_rustfisher_ndkalgo_RWFile.h`-- RWFile.c Java文件RWFile.java 里面写了多个native方法。 123456789101112131415161718192021222324252627public class RWFile { static { System.loadLibrary(&quot;NDKMan&quot;); } public String readIn() { return nativeRead(); } public String writeToFile(String msg) { return nativeWrite(msg); } public String readSDFile(String fileName) { return nativeReadSDFile(fileName); } private native String nativeRead(); /** * @param fileName e.g. FolderName/textFile.txt */ private native String nativeReadSDFile(String fileName); private native String nativeWrite(String msg);} RWFile.c编译出.h文件后，里面的方法名。可以看出编译后的方法名和原来的native方法是一一对应的。1234void join(char *s1, char *s2,char *result) // 拼接char的函数Java_com_rustfisher_ndkalgo_RWFile_nativeRead // 读取固定文件的内容Java_com_rustfisher_ndkalgo_RWFile_nativeReadSDFile // 根据文件名读取文件内容Java_com_rustfisher_ndkalgo_RWFile_nativeWrite // 将内容写入文件 C文件C文件是我们具体实现功能的地方。RWFile.c代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;com_rustfisher_ndkalgo_RWFile.h&quot;const char *sdcardDir = &quot;/sdcard/&quot;;void join(char *s1, char *s2,char *result) { result = (char *) malloc(strlen(s1)+strlen(s2)+1);// +1 for the zero-terminator if (result == NULL) { return; } strcpy(result, s1); strcat(result, s2);}JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkalgo_RWFile_nativeRead(JNIEnv *env, jobject jObj) { FILE* file = fopen(&quot;/sdcard/hello.txt&quot;,&quot;r+&quot;); char myStr[128]; if (file != NULL) { char* readInPtr = fgets(myStr, 128, file); fclose(file); if (NULL != readInPtr) { return (*env)-&gt;NewStringUTF(env, myStr); } return (*env)-&gt;NewStringUTF(env, &quot;JNI read file fail!&quot;); } return (*env)-&gt;NewStringUTF(env, &quot;JNI read file fail!&quot;);}JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkalgo_RWFile_nativeReadSDFile(JNIEnv *env, jobject jObj, jstring fileName) { char *fileNamePtr = (*env)-&gt;GetStringUTFChars(env, fileName, 0); char * result; join(sdcardDir,fileNamePtr,result); FILE* file = fopen(result,&quot;r+&quot;); if (file != NULL) { char myStr[128]; char* readInPtr = fgets(myStr, 128, file); fclose(file); if (NULL != readInPtr) { return (*env)-&gt;NewStringUTF(env, myStr); } return (*env)-&gt;NewStringUTF(env, &quot;JNI read fail - NULL == readInPtr&quot;); } return (*env)-&gt;NewStringUTF(env, &quot;JNI read file fail! - file is NULL &quot;);}JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkalgo_RWFile_nativeWrite(JNIEnv *env, jobject jObj, jstring msg) { FILE* file = fopen(&quot;/sdcard/hello.txt&quot;,&quot;w+&quot;); const char *nativeMsg = (*env)-&gt;GetStringUTFChars(env, msg, 0); if (file != NULL) { fputs(nativeMsg, file); fflush(file); fclose(file); } return (*env)-&gt;NewStringUTF(env, &quot;Write finished.&quot;);} 需关注的函数要特别关心函数的返回值，返回值往往代表着调用的结果。 打开文件 fopenFILE * fopen(const char * path,const char * mode);mode模式选择，例如&quot;r&quot; r(read): 读 w(write): 写 a(append): 追加 t(text): 文本文件，可省略不写 b(banary): 二进制文件 +: 读和写 凡用“r”打开一个文件时，该文件必须已经存在，且只能从该文件读出。 用“w”打开的文件只能向该文件写入。若打开的文件不存在，则以指定的文件名建立该文件，若打开的文件已经存在，则将该文件删去，重建一个新文件。这个方法保证目标文件里写入的只有我们要的数据。 若要向一个已存在的文件追加新的信息，只能用“a”方式打开文件。但此时该文件必须是存在的，否则将会出错。 在打开一个文件时，如果出错，fopen将返回一个空指针值NULL。在程序中可以用这一信息来判别是否完成打开文件的工作，并作相应的处理。 如果成功的打开一个文件, fopen()函数返回文件指针, 否则返回空指针 从文件中读取数据 fgetschar *fgets(char *s, int n, FILE *stream);从文件指针stream中读取n-1个字符，存到以s为起始地址的空间里，直到读完一行，如果成功则返回s的指针，否则返回NULL。 NDK中生成jstring的函数 (*env)-&gt;NewStringUTF(env, char *);(*env)-&gt;NewStringUTF(env, char *);如果传入的char*是一个空值，在一些平台上会报错。比如红米手机会直接崩溃，而魅族手机能得到一个空的String。","link":"/2017/03/16/Android/NDK-read_write_file/"},{"title":"MySQL 增删查改","text":"环境： win7_x64， Navicat for MySQL 本文链接 操作数据库前面已经将MySQL服务跑起来了。 Mac安装MySQL Windows安装MySQL 现在我们以root身份进行MySQL操作进入MySQL1C:\\Users\\Administrator&gt;mysql -uroot -p 新建数据库12mysql&gt; create database samp_db1 character set gbk;Query OK, 1 row affected (0.00 sec) 数据库字符编码指定为 gbk 选择要操作的数据库已经登录后可以直接选择数据库 12mysql&gt; use samp_db1;Database changed 创建数据表以建立person_t数据表为例12345678mysql&gt; create table person_t ( -&gt; id int unsigned not null auto_increment primary key, -&gt; name char(14) not null, -&gt; sex char(4) not null, -&gt; age tinyint unsigned not null, -&gt; tell char(13) null default &quot;-&quot; -&gt; );Query OK, 0 rows affected (0.22 sec)打开Navicat for MySQL，可以看到我们新建的表 输入这么长的文本很容易出错，我们可以直接先写好SQL语句，再导进来 新建文件create_student_table.sql，输入SQL语句 1234567create table student (id int unsigned not null auto_increment primary key,name char(14) not null,sex char(4) not null,age tinyint unsigned not null,tell char(13) null default &quot;-&quot;); 直接执行SQL文件，操作samp_db1数据库123C:\\Users\\Administrator&gt;mysql -D samp_db1 -u root -p &lt; H:\\create_student_table.sqlEnter password: **** 操作数据库选定要操作的数据库use samp_db1; 增 - 插入数据insert [into] 表名 [(列名1, 列名2, 列名3, …)] values (值1, 值2, 值3, …); 12mysql&gt; insert into student values(null,&quot;张三&quot;,&quot;男&quot;,23,&quot;13666665555&quot;);mysql&gt; insert into student (name,sex,age) values(&quot;李四&quot;,&quot;女&quot;,20); 查 - 查询表中的数据select 列名称 from 表名称 [查询条件]; 多插入了一些数据后 1234567891011mysql&gt; select name, age from student;+-------+-----+| name | age |+-------+-----+| 张三 | 23 || 李四 | 20 || Tom | 13 || Jerry | 12 || 王五 | 32 |+-------+-----+5 rows in set (0.00 sec) 使用通配符*来查询1234567891011mysql&gt; select * from student;+----+-------+-----+-----+-------------+| id | name | sex | age | tell |+----+-------+-----+-----+-------------+| 1 | 张三 | 男 | 23 | 13666665555 || 2 | 李四 | 女 | 20 | - || 3 | Tom | 男 | 13 | 13111115555 || 4 | Jerry | 男 | 12 | 2333333 || 5 | 王五 | 男 | 32 | 666666666 |+----+-------+-----+-----+-------------+5 rows in set (0.00 sec) 特定条件查询where 关键词用于指定查询条件, 用法形式为: select 列名称 from 表名称 where 条件; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 查询所有性别为女的记录mysql&gt; select * from student where sex=&quot;女&quot;;+----+------+-----+-----+------+| id | name | sex | age | tell |+----+------+-----+-----+------+| 2 | 李四 | 女 | 20 | - |+----+------+-----+-----+------+1 row in set (0.04 sec)// age大于20的记录mysql&gt; select * from student where age&gt;20;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 1 | 张三 | 男 | 23 | 13666665555 || 5 | 王五 | 男 | 32 | 666666666 |+----+------+-----+-----+-------------+2 rows in set (0.00 sec)// age小于等于20的记录mysql&gt; select * from student where age&lt;=20;+----+-------+-----+-----+-------------+| id | name | sex | age | tell |+----+-------+-----+-----+-------------+| 2 | 李四 | 女 | 20 | - || 3 | Tom | 男 | 13 | 13111115555 || 4 | Jerry | 男 | 12 | 2333333 |+----+-------+-----+-----+-------------+3 rows in set (0.00 sec)// age小于等于20并且id大于等于3的记录mysql&gt; select * from student where age&lt;=20 and id &gt;=3;+----+-------+-----+-----+-------------+| id | name | sex | age | tell |+----+-------+-----+-----+-------------+| 3 | Tom | 男 | 13 | 13111115555 || 4 | Jerry | 男 | 12 | 2333333 |+----+-------+-----+-----+-------------+2 rows in set (0.03 sec)// 按名字特征查询mysql&gt; select * from student where name like &quot;%三%&quot;;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 1 | 张三 | 男 | 23 | 13666665555 |+----+------+-----+-----+-------------+1 row in set (0.00 sec)mysql&gt; select * from student where name like &quot;%o%&quot;;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 3 | Tom | 男 | 13 | 13111115555 |+----+------+-----+-----+-------------+1 row in set (0.00 sec)// tell 以5结尾的记录mysql&gt; select * from student where tell like &quot;%5&quot;;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 1 | 张三 | 男 | 23 | 13666665555 || 3 | Tom | 男 | 13 | 13111115555 |+----+------+-----+-----+-------------+2 rows in set (0.00 sec)mysql&gt; select * from student where tell like &quot;131%&quot;;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 3 | Tom | 男 | 13 | 13111115555 |+----+------+-----+-----+-------------+1 row in set (0.00 sec) 按条件查询非常的灵活，运用得当会节省运行时间 改 - 修改表中的数据基本的使用形式为: update 表名称 set 列名称=新值 where 更新条件; 我们终于拿到了李四的联系方式，将数据库中的tell更新 1234567891011mysql&gt; update student set tell=&quot;13900001111&quot; where name=&quot;李四&quot;;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student where name=&quot;李四&quot;;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 2 | 李四 | 女 | 20 | 13900001111 |+----+------+-----+-----+-------------+1 row in set (0.00 sec) 过了一年，大家都长了一岁，修改表中的age值 123456789101112131415mysql&gt; update student set age=age+1;Query OK, 5 rows affected (0.05 sec)Rows matched: 5 Changed: 5 Warnings: 0mysql&gt; select * from student;+----+-------+-----+-----+-------------+| id | name | sex | age | tell |+----+-------+-----+-----+-------------+| 1 | 张三 | 男 | 24 | 13666665555 || 2 | 李四 | 女 | 21 | 13900001111 || 3 | Tom | 男 | 14 | 13111115555 || 4 | Jerry | 男 | 13 | 2333333 || 5 | 王五 | 男 | 33 | 666666666 |+----+-------+-----+-----+-------------+5 rows in set (0.00 sec) 修改多个信息，Jerry有了中文名“赵六”，换了tell 123456789101112131415mysql&gt; update student set name=&quot;赵六&quot;,tell=&quot;10001-1001&quot; where name=&quot;Jerry&quot;;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 1 | 张三 | 男 | 24 | 13666665555 || 2 | 李四 | 女 | 21 | 13900001111 || 3 | Tom | 男 | 14 | 13111115555 || 4 | 赵六 | 男 | 13 | 10001-1001 || 5 | 王五 | 男 | 33 | 666666666 |+----+------+-----+-----+-------------+5 rows in set (0.00 sec) 删 - 删除表中的数据基本用法为: delete from 表名称 where 删除条件; 年龄太小不能入学 123456789101112mysql&gt; delete from student where age &lt; 18;Query OK, 2 rows affected (0.04 sec)mysql&gt; select * from student;+----+------+-----+-----+-------------+| id | name | sex | age | tell |+----+------+-----+-----+-------------+| 1 | 张三 | 男 | 24 | 13666665555 || 2 | 李四 | 女 | 21 | 13900001111 || 5 | 王五 | 男 | 33 | 666666666 |+----+------+-----+-----+-------------+3 rows in set (0.00 sec) 修改现有的表alter table 语句用于修改现有表 添加列alter table 表名 add 列名 列数据类型 [after 插入位置]; 在表的最后添加address列mysql&gt; alter table student add address char(70); 在名为 age 的列后插入列 birthdaymysql&gt; alter table student add birthday date after age; 此时的表12345678mysql&gt; select * from student;+----+------+-----+-----+----------+-------------+---------+| id | name | sex | age | birthday | tell | address |+----+------+-----+-----+----------+-------------+---------+| 1 | 张三 | 男 | 24 | NULL | 13666665555 | NULL || 2 | 李四 | 女 | 21 | NULL | 13900001111 | NULL || 5 | 王五 | 男 | 33 | NULL | 666666666 | NULL |+----+------+-----+-----+----------+-------------+---------+ 列的名字不能是mysql的关键字，比如不能是index 修改列基本形式: alter table 表名 change 列名称 列新名称 新数据类型; 将tell列名修改为mobilealter table student change tell mobile char(13) default &quot;-&quot;; 修改name列的类型为char(11) not null 123mysql&gt; alter table student change name name char(11) not null;Query OK, 3 rows affected (0.54 sec)Records: 3 Duplicates: 0 Warnings: 0 删除列alter table 表名 drop 列名称; 删除address列 alter table student drop address; 重命名表alter table 表名 rename 新表名; 重命名表student -&gt; bigstu alter table student rename bigstu; 删除整张表drop table 表名;删掉前面我们创建的person_t12mysql&gt; drop table person_t;Query OK, 0 rows affected (0.12 sec) 删除整个数据库drop database 数据库名; 新建一个数据库samp_4_delete，再删除它12345mysql&gt; create database samp_4_delete;Query OK, 1 row affected (0.00 sec)mysql&gt; drop database samp_4_delete;Query OK, 0 rows affected (0.01 sec) 复制schema没有特定的复制命令。思路是新建一个目标schema，然后把原数据库中的表全部复制到新建的库中去。 参考： https://stackoverflow.com/questions/67093/how-do-i-quickly-rename-a-mysql-database-change-schema-name","link":"/2017/02/25/Database/MySQL-use_add_del_check_update/"},{"title":"MySQL Windows 安装与简单配置","text":"记录一些操作。 win7_x64 下安装配置MySQL下载下载了绿色免安装版本，目录为E:\\mysql-5.7.17-winx64 配置新建data目录 E:\\mysql-5.7.17-winx64\\data 把E:\\mysql-5.7.17-winx64\\bin添加到环境变量 配置文件my.ini新建配置文件my.ini放在E:\\mysql-5.7.17-winx64，内容如下：12345[mysqld]basedir=E:/mysql-5.7.17-winx64datadir=E:/mysql-5.7.17-winx64/datatmpdir=E:/mysql-5.7.17-winx64/dataport = 3306 初始化打开CMD，进入目录E:\\mysql-5.7.17-winx64\\bin&gt;，执行初始化命令，如下 1234E:\\mysql-5.7.17-winx64\\bin&gt;mysqld --initialize --user=mysql --console// *******2017-02-25T07:35:47.155727Z 1 [Note] A temporary password is generated for root@localhost: s/KKIaag+3iS 获得了一个随机密码s/KKIaag+3iS 打开另一个CMD，执行C:\\Users\\Administrator&gt;mysqld --console，目的是让MySQL跑起来 回到刚才的CMD，还在E:\\mysql-5.7.17-winx64\\bin&gt;登录root mysql -uroot -p ，用的是上面生成的密码 123456789101112131415E:\\mysql-5.7.17-winx64\\bin&gt;mysql -uroot -pEnter password: ************Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.17Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 在MySQL的命令行里修改root的密码，记得打分号 12345mysql&gt; set password = password('youPwd');Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; exitBye 退出用新密码重新登录。可以发现密码已经修改成功。在这整个过程中，另一个CMD一直在运行MySQL。 122017-02-25T07:37:41.643275Z 0 [Note] mysqld: ready for connections.Version: '5.7.17' socket: '' port: 3306 MySQL Community Server (GPL) 启动与停止服务启动服务杀掉CMD里面的MySQL进程。安装并开启服务。 1234567E:\\mysql-5.7.17-winx64\\bin&gt;mysqld install MySQL --defaults-file=&quot;E:\\mysql-5.7.17-winx64\\my.ini&quot;Service successfully installed.E:\\mysql-5.7.17-winx64\\bin&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。 停止服务123C:\\Users\\Administrator&gt;net stop MySQLMySQL 服务正在停止.MySQL 服务已成功停止。 查看所有Windows服务在CMD中使用net命令，可以查看所有服务 12345678C:\\Users\\Administrator&gt;net start已经启动以下 Windows 服务:// ****IPsec Policy AgentMySQLNetwork Connections// **** 删除服务sc delete 服务名 1234567C:\\Users\\Administrator&gt;sc delete mysql[SC] DeleteService 成功C:\\Users\\Administrator&gt;net start mysql服务名无效。请键入 NET HELPMSG 2185 以获得更多的帮助。 删除服务后，重新初始化并建立服务前面已经删除服务，此时直接建立服务并启动会报错12345678C:\\Users\\Administrator&gt;mysqld install MySQL --defaults-file=&quot;E:\\mysql-5.7.17-winx64\\my.ini&quot;Service successfully installed.C:\\Users\\Administrator&gt;net start mysql发生系统错误 2。系统找不到指定的文件。 此时要把mysql这个服务删除sc delete mysql 然后把data目录内的文件全部删除，回到bin目录重新初始化一次。又获得了一个随机密码。再新建服务并启动即可。 123456789101112E:\\mysql-5.7.17-winx64\\bin&gt;mysqld --initialize --user=mysql --console// **********2017-02-25T08:11:51.156501Z 1 [Note] A temporary password is generated for root@localhost: gp/L/3#ayeo/E:\\mysql-5.7.17-winx64\\bin&gt;mysqld install MySQL --defaults-file=&quot;E:\\mysql-5.7.17-winx64\\my.ini&quot;Service successfully installed.E:\\mysql-5.7.17-winx64\\bin&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。 MySQL的服务正在运行，此时将随机密码修改成自己的密码youPwd 123456E:\\mysql-5.7.17-winx64\\bin&gt;mysql -uroot -pEnter password: ************Welcome to the MySQL monitor. Commands end with ; or \\g.// ******mysql&gt; set password = password('youPwd');Query OK, 0 rows affected, 1 warning (0.00 sec)","link":"/2017/02/25/Database/MySQL-install_and_config_Windows/"},{"title":"Gradle 构建多种版本","text":"本章目的 Build types 构建类型 Product flavors Build variants 构建不同种类 Signing configurations 开发APP时，会有生成不同版本的需求。比如测试版本和发布版本。不同版本之间通常有不同的设置。 Build types定义APP或者模块该被如何构建。 可以用buildTypes来定义构建类型。例如：123456buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' }} 默认的build.gradle文件会包含一个release构建类型 创建构建类型比如创建一个staging构建类型12345678910buildTypes { // staging 是一个自定义名字 // 生成signed App时可以选择这个类型 staging.initWith(buildTypes.debug) staging { applicationIdSuffix &quot;.staging&quot; versionNameSuffix &quot;-staging&quot; buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\\&quot;http://www.staging.com\\&quot;&quot;) }}这里定义了applicationIdSuffix，让staging版本的applicationId和release版本的不同。 initWith()创建一个新的构建类型并复制现有的构建类型。用这个方法可以复写已有的构建类型。 资源目录创建了新的构建类型后，可以建立新的资源文件。例如我们已经有了staging构建类型 12345678src├── androidTest├── debug├── greenRelease├── main├── redDebug├── staging// 可以新建资源目录└── test 不同资源目录里的文件可以用相同的文件名。 main目录里的strings.xml123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;GDemo&lt;/string&gt;&lt;/resources&gt; 1234&lt;resources&gt; &lt;!-- staging strings.xml --&gt; &lt;string name=&quot;app_name&quot;&gt;GStaging&lt;/string&gt;&lt;/resources&gt; 生成不同版本的app时，会自动去找相应的资源文件 依赖包管理每一种构建类型可以有自己的依赖。Gradle自动为每个类型创建依赖配置。下面就是单独为debug版本添加logging模块的依赖 12345678910dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', { exclude group: 'com.android.support', module: 'support-annotations' }) compile 'com.android.support:appcompat-v7:25.1.1' testCompile 'junit:junit:4.12' debugCompile 'de.mindpipe.android:android-logging-log4j:1.0.3'} Product flavors 产品特征product flavors用于创建同一个APP的不同版本。最直接的例子就是免费和付费版APP。 当我们要发布APP时，可以选择release或者staging（上面的例子）版。但是对同一个构建类型，比如对于release版，我们可以用Product flavors打包出有各自特征的APP。比如： 1234567891011// 多渠道打包可以用在这里配置// 一旦配置了productFlavors，生成apk时会默认选其中一个选项productFlavors { red { versionName &quot;1.0-red&quot; } green { applicationId &quot;com.rustfisher.gradletest.green&quot; // 使用另一个签名 versionNameSuffix &quot;-green&quot;// 版本名添加后缀 }} 资源文件新建了productFlavors类型后，我们可以新建相应的资源目录。 12345678src├── androidTest├── debug├── greenRelease // release版本 采用green├── main├── redDebug // debug版本 采用red├── staging└── test 多种特种的变量 Multiflavor variants在Product flavors中可以进行组合，例如 123456789101112131415161718192021222324android { flavorDimensions(&quot;color&quot;, &quot;price&quot;) // 新建了2种类型 // 多渠道打包可以用在这里配置 // 一旦配置了productFlavors，debug时会默认选一个选项 productFlavors { red { versionName &quot;1.0-red&quot; dimension &quot;color&quot; } green { applicationId &quot;com.rustfisher.gradletest.green&quot; // 使用另一个签名 versionNameSuffix &quot;-green&quot; dimension &quot;color&quot; } freeApp { dimension &quot;price&quot; } paidApp { dimension &quot;price&quot; } }} 那么在打包apk时，可以有如下4种版本 1234green-freeApp green-paidApp red-freeApp red-paidApp 一旦添加flavorDimensions，就必须为每一个flavor制定dimension。就像上面的color和price必须出现在下面4种productFlavors之中。否则会报错。 Build VariantsAndroid Studio左下角可以打开Build Variants窗口。选择模块和Build Variants。前面配置的构建类型都会在这个列表中出现。 Tasks 任务Android plugin for Gradle 会自动为每个配置的构建类型创建任务。新建项目时，会有默认的assembleDebug 和 assembleRelease。经过上面的配置以后，会有产生相对应的任务12345678910111213assembleassembleAndroidTestassembleDebugassembleFreeAppassembleGreenassembleGreenFreeAppassembleGreenPaidAppassemblePaidAppassembleRedassembleRedFreeAppassembleRedPaidAppassembleReleaseassembleStaging Resource and manifest mergingAndroid的Gradle插件会在打包app前将主要资源和构建类型资源合在一起。另外，lib工程也可以提供额外可被合并的资源文件。manifest文件也可被合并。比如在debug版本中申请正式版中不需要的权限。 定义构建变量给productFlavors中的类型添加资源 1234567891011121314productFlavors { red { versionName &quot;1.0-red&quot; dimension &quot;color&quot; resValue(&quot;color&quot;, &quot;flavor_color&quot;, &quot;#ff0000&quot;) } green { applicationId &quot;com.rustfisher.gradletest.green&quot; // 使用另一个签名 versionNameSuffix &quot;-green&quot; resValue(&quot;color&quot;, &quot;flavor_color&quot;, &quot;#00ff00&quot;) dimension &quot;color&quot; }// ...} 上面的flavor_color可以在代码中通过R文件找到R.color.flavor_color 参考：Gradle for Android Kevin Pelgrims","link":"/2017/01/19/Android/Gradle_for_android_Creating_Build_Variants/"},{"title":"Gradle 基础自定义构建","text":"win7 Android Studio 2.1.3 基础自定义构建 Basic Build Customization 本章目的 理解Gradle文件 build tasks入门 自定义构建 理解Gradle文件在Android Studio中新建一个项目后，会自动创建3个Gradle文件。 12345MyApp├── build.gradle├── settings.gradle└── app └── build.gradle 每个文件都有自己的作用 settings.gradle文件新建工程的settings文件类似下面这样 1include ':app' Gradle为每个settings文件创建Settings对象，并调用其中的方法。 The top-level build file 最外层的构建文件能对工程中所有模块进行配置。如下 12345678910111213141516171819202122buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.1.3' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files }}allprojects { repositories { jcenter() maven { url &quot;https://jitpack.io&quot; } }}task clean(type: Delete) { delete rootProject.buildDir} buildscript代码块是具体配置的地方，引用JCenter仓库。本例中，一个仓库代表着依赖库，换句话说是app可以从中下载使用库文件。JCenter是一个有名的 Maven 仓库。 dependencies代码块用来配置依赖。上面注释说明了，不要在此添加依赖，而应该到独立的模块中去配置依赖。 allprojects能对所有模块进行配置。 模块中的build文件模块中的独立配置文件，会覆盖掉top-level的build.gradle文件 1234567891011121314151617181920212223242526apply plugin: 'com.android.application'android { compileSdkVersion 25 buildToolsVersion &quot;25.0.2&quot; defaultConfig { applicationId &quot;com.xxx.rust.newproj&quot; minSdkVersion 18 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } }}dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:25.1.0'} 下面来看3个主要的代码块。 plugin第一行应用了Android 应用插件。Android插件由Google团队开发维护。该插件提供构建，测试，打包应用和模块需要的所有的task。 android最大的一个区域。defaultConfig区域对app核心进行配置，会配置覆盖AndroidManifest.xml中的配置。 applicationId复写掉manifest文件中的包名。但applicationId和包名有区别。manifest中的包名，在源代码和R文件中使用。所以package name在android studio中理解为一个查询类的路径比较合理。applicationId在Android系统中是作为应用的唯一标识，即在一个Android设备中所有的应用程序的applicationId都是唯一的。 dependencies是Gradle标准配置的一部分。Android中用来配置使用到的库。 定制化构建 Customizing the buildBuildConfig and resources自从SDK17以来，构建工具会生成一个BuildConfig类，包含着静态变量DEBUG和一些信息。如果你想在区分debug和正式版，比如打log，这个BuildConfig类很有用。可以通过Gradle来扩展这个类，让它拥有更多的静态变量。 以NewProj工程为例，app\\build.gradle 123456789101112131415161718192021222324252627android { compileSdkVersion 25 buildToolsVersion &quot;25.0.2&quot; defaultConfig { applicationId &quot;com.xxx.rust.newproj&quot; minSdkVersion 18 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; } buildTypes { debug { buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\\&quot;http://www.baidu.com\\&quot;&quot;) buildConfigField(&quot;String&quot;, &quot;A_CONTENT&quot;, &quot;\\&quot;debug content\\&quot;&quot;) resValue(&quot;string&quot;, &quot;str_version&quot;, &quot;debug_ver&quot;) } release { buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\\&quot;http://www.qq.com\\&quot;&quot;) buildConfigField(&quot;String&quot;, &quot;A_CONTENT&quot;, &quot;\\&quot;release content\\&quot;&quot;) resValue(&quot;string&quot;, &quot;str_version&quot;, &quot;release_ver&quot;) minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } }} 上面的buildConfigField和resValue在编译后，能在源代码中使用注意上面那个转义的分号不可少；注意里面的大小写，这里传入的参数就像是直接填入的代码一样 下面是编译后生成的BuildConfig文件，可以看到buildConfigField的东西已经在里面了 1234567891011public final class BuildConfig { public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;); public static final String APPLICATION_ID = &quot;com.xxx.rust.newproj&quot;; public static final String BUILD_TYPE = &quot;debug&quot;; public static final String FLAVOR = &quot;&quot;; public static final int VERSION_CODE = 1; public static final String VERSION_NAME = &quot;1.0&quot;; // Fields from build type: debug public static final String A_CONTENT = &quot;debug content&quot;; public static final String BASE_URL = &quot;http://www.baidu.com&quot;;} resValue会被添加到资源文件中 1mTv2.setText(R.string.str_version); 通过 build.gradle 增加获取 applicationId 的方式模块build.gradle中添加属性applicationId，会被编译到BuildConfig中12345project.afterEvaluate { project.android.applicationVariants.all { variant -&gt; def applicationId = [variant.mergedFlavor.applicationId, variant.buildType.applicationIdSuffix].findAll().join() }} 在代码中可以直接使用1String appID = BuildConfig.APPLICATION_ID; 获取时间的方法模块build.gradle中添加方法getTime()，并在buildTypes中添加域。123456789101112131415161718// 获取当前时间static def getTime() { String timeNow = new Date().format('YYYYMMdd-HHmmss') return timeNow}android { // ... buildTypes { debug { buildConfigField &quot;String&quot;, &quot;BUILD_TIME&quot;, &quot;\\&quot;&quot; + getTime() + &quot;\\&quot;&quot; } release { buildConfigField &quot;String&quot;, &quot;BUILD_TIME&quot;, &quot;\\&quot;&quot; + getTime() + &quot;\\&quot;&quot; // ... } }} BuildConfig.java中得到这个域。12// Fields from build type: debugpublic static final String BUILD_TIME = &quot;20180912-100335&quot;; 修改release apk文件名的方法gradle版本3.1.4。使用了上面的方法getTime()。 1234567891011android { // ... // 修改release的apk名字 applicationVariants.all { variant -&gt; variant.outputs.all { if (variant.buildType.name == 'release') { outputFileName = &quot;xxx_release_${defaultConfig.versionName}_${getTime()}.apk&quot; } } }} 以前的方法可能会遇到问题：Cannot set the value of read-only property 'outputFile' for ApkVariantOutputImpl_Decorated。参考：https://stackoverflow.com/questions/44239235/android-gradle-3-0-0-alpha2-plugin-cannot-set-the-value-of-read-only-property 工程范围的设置如果一个工程中有多个模块，可以对整个工程应用设置，而不用去修改每一个模块。 NewProj\\build.gradle12345678910allprojects { repositories { jcenter() }}ext { compileSDKVersion = 25 local = 'Hello from the top-level build'} 每一个build.gradle文件都能定义额外的属性，在ext代码块中。 在一个模块的libmodule\\build.gradle文件中，可以引用rootProject的ext属性 12345android { compileSdkVersion rootProject.ext.compileSDKVersion buildToolsVersion &quot;25.0.2&quot; // ....} 工程属性 Project properties定义properties的地方 ext代码块 gradle.properties文件 命令行 -P 参数 工程build.gradle文件123456789101112131415161718192021ext { compileSDKVersion = 25 local = 'Hello from the top-level build'}/** * Print properties info */task aPrintSomeInfo { println(local) println('project dir: ' + projectDir) println(projectPropertiesFileText)}task aPrintAllProperites() { println('\\nthis is aPrintAllProperites task\\n') Iterator pIt = properties.iterator() while (pIt.hasNext()) { println(pIt.next()) }} gradle.properties文件中增加1projectPropertiesFileText = Hello there from gradle.properties 在as的Gradle栏上双击执行aPrintSomeInfo，会连带下一个task也执行 123456789101113:08:10: Executing external task 'aPrintSomeInfo'...Hello from the top-level buildproject dir: G:\\openSourceProject\\NewProjHello there from gradle.propertiesthis is aPrintAllProperites task......BUILD SUCCESSFULTotal time: 1.025 secs13:08:11: External task execution finished 'aPrintSomeInfo'. 参考：Gradle for Android Kevin Pelgrims","link":"/2017/01/19/Android/Gradle_for_android_Basic_Build_Customization/"},{"title":"Gradle for Android 开始","text":"Gradle for Android开始Google在Gradle中的目标：能复用代码，创建构建变量，能配置和定制构建过程。 Gradle基础Gradle构建脚本并不是用XML来写的，而是基于Groovy的一种（domain-specifc language）DSL语言。这是一种运行在JVM上的动态语言。 如果要构建新的任务和插件，我们需要了解这门语言。 Projects and tasks这是Gradle种最重要的两个概念。每个构建（build）至少包含一个project，每一个project包含一个或多个task。每个build.gradle代表一个project。task被定义在这个构建脚本中。一个task对象包含一列需要被执行的Action对象。一个Action对象就是一块被执行的代码，就像Java中的方法。 当初始化构建进程时，Gradle收集build文件中的project和task对象。 构建的生命周期（The build lifecycle）为简化构建过程，构建工具创造了一种工作流的动态模型DAG（Directed Acyclic Graph）。这意味着所有的任务会一个接一个地执行，不会出现循环的情况。一个任务一旦被执行就不会再被调用。没有依赖的任务永远是最优先执行的。在配置过程中生成依赖关系。 一个Gradle构建过程有3个步骤： 初始化：工程实例被创建时初始化。如果有多个模块，每个模块有自己的build.gradle文件，多个project被创建。 配置：这一步执行build脚本，创建并配置每个project的task。 执行：Gradle决定执行那些任务。根据当前目录和传入参数执行task。 build配置文件build.gradle文件。配置build的地方。 12345678buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.2.2' }} repositories块中，指定JCenter作为依赖仓库。这个脚本获取了Android构建工具。这个Android插件提供了构建和测试应用所需的功能。 插件被用来扩展Gradle构建脚本的功能。在project中使用插件，就可以定义属性和任务。 Gradle Wrapper初步Gradle是一个开发中的工具。使用Gradle Wrapper可以避免一些问题，确保能构建顺利。Gradle在Windows系统上提供了batch文件，在其他系统上提供了shell脚本。试图运行脚本时，会自动检查并下载Gradle。但在我们的网络比较令人着急。可以尝试在网络上找资源。 比如我下载了一个gradle-2.14.1-all.zip，将其放到Android工程的gradle/wrapper下 12345gradle`-- wrapper |-- gradle-2.14.1-all.zip |-- gradle-wrapper.jar `-- gradle-wrapper.properties 然后修改gradle-wrapper.properties文件，把Url修改成distributionUrl=gradle-2.14.1-all.zip 在Android Studio提供的Terminal中运行grawdlew，先unzipping，然后开始下载依赖文件。这些文件在windows中默认存放到C:\\Users\\UserName\\.gradle\\wrapper\\dists\\gradle-2.14.1-all，还是很占空间的。此时你可以在项目下的命令行中使用grawdlew命令。比如查看版本。 12345678910111213G:\\rust_proj\\NDKProj&gt;gradlew -v------------------------------------------------------------Gradle 2.14.1------------------------------------------------------------Build time: 2016-07-18 06:38:37 UTCRevision: d9e2113d9fb05a5caabba61798bdb8dfdca83719Groovy: 2.4.4Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_77 (Oracle Corporation 25.77-b03)OS: Windows 7 6.1 amd64 如果在另一个Android项目下同样复制了gradle-2.14.1-all.zip，并且尝试运行gradlew，C盘里相应目录下又会多一个文件夹。 获取Gradle Wrapper打开Windows CMD，进入前面配置好的Android工程目录，同样可以运行gradlew。 此时我们的C盘里已经有gradle-2.14.1-all.zip了。找到gradle.bat的路径，将其添加到电脑PATH中。这里添加到用户的环境变量中。 在G盘新建一个目录gradleTest，然后创建一个build.gradle文件；其中填写如下代码 123task wrapper(type: Wrapper) { gradleVersion = '2.4'} 进入刚才的目录，在CMD中直接运行gradle 123456789G:\\gradleTest&gt;gradle:helpWelcome to Gradle 2.14.1.To run a build, run gradle &lt;task&gt; ...To see a list of available tasks, run gradle tasksTo see a list of command-line options, run gradle --helpTo see more detail about a task, run gradle help --task &lt;task&gt;BUILD SUCCESSFULTotal time: 1.714 secs 此时目录下生成了一个.gradle目录 如果当前目录下没有build.gradle文件，gradle也会执行并生成.gradle目录。 我们来观察Android项目里Gradle Wrapper的情况123456NDKProj/├── gradlew├── gradlew.bat└── gradle/wrapper/ ├── gradle-wrapper.jar └── gradle-wrapper.propertiesGradle Wrapper包含3个部分： MS可执行的gradlew.bat和Linux， Mac OS X可执行的gradlew 脚本需要的Jar文件 一个properties文件 在前面我们已经把properties文件修改成了这样：123456#Mon Aug 29 19:26:36 CST 2016distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=gradle-2.14.1-all.zip 原distributionUrl如下：1distributionUrl=https\\://services.gradle.org/distributions/gradle-2.14.1-all.zip 这意味着我们可以使用不同的URL和Gradle。我们前面已经这么做了。 运行基本的构建任务（task）进入Android工程目录下，用命令行执行gradlewgradlew tasks会打印出任务列表；gradlew tasks --all打印出所有的任务 gradlew assembleDebug编译当前项目，创建一个debug版本的apk gradlew clean清理当前项目的output gradlew check运行所有的检查，通常是在真机或者模拟器上运行测试 gradlew build触发assemble 和 check 这些功能在Android Studio上都有相应按键 参考：Gradle for Android Kevin Pelgrims","link":"/2017/01/19/Android/Gradle_for_android_Start/"},{"title":"PyQt QMainWindow 简单使用","text":"QMainWindow继承自QWidgetQMainWindow相当于程序的主界面，内置了menu和toolBar。使用 Qt Designer 可以很方便地添加menu选项。 对于较大型的界面，用Qt Designer比较方便。.ui文件就像Android中使用xml一样。画出的ui文件可以用PyQt中的PyUIC转换成py文件。转换后的py文件中有一个class。新建一个继承自QMainWindow的类，来调用生成的这个类。 主窗口关闭时，会调用closeEvent(self, *args, **kwargs)，可复写这个方法，加上一些关闭时的操作。比如终止子线程，关闭数据库接口，释放资源等等操作。 PyQt5 手写 QMainWindow 示例Win7 PyCharm Python3.5.1 PyQt5 手写一个main window，主要使用了菜单栏、文本编辑框、工具栏和状态栏12345|-- main.py|-- res| `-- sword.png`-- ui `-- app_main_window.py main.py主文件12345678910import sysfrom PyQt5.QtWidgets import QApplicationfrom ui.app_main_window import AppMainWindowif __name__ == '__main__': app = QApplication(sys.argv) window = AppMainWindow() window.show() sys.exit(app.exec_()) app_main_window.py窗口实现文件12345678910111213141516171819202122232425262728293031323334353637383940414243from PyQt5.QtCore import QCoreApplicationfrom PyQt5.QtGui import QIconfrom PyQt5.QtWidgets import QActionfrom PyQt5.QtWidgets import QMainWindowfrom PyQt5.QtWidgets import QTextEditclass AppMainWindow(QMainWindow): &quot;&quot;&quot; 菜单栏、文本编辑框、工具栏和状态栏 &quot;&quot;&quot; def __init__(self): super().__init__() self.init_ui() def init_ui(self): # 菜单栏 self.statusBar().showMessage('Main window is ready') self.setGeometry(500, 500, 450, 220) self.setMinimumSize(150, 120) self.setWindowTitle('MainWindow') # 文本编辑框 text_edit = QTextEdit() self.setCentralWidget(text_edit) # 填充剩下的位置 # 定义退出动作 exit_action = QAction(QIcon('res/sword.png'), 'Exit', self) exit_action.setShortcut('Ctrl+Q') exit_action.setStatusTip('Exit App') # 鼠标指向选项时在窗口状态栏出现的提示 # exit_action.triggered.connect(QCoreApplication.instance().quit) exit_action.triggered.connect(self.close) # 关闭app # 定义菜单栏，添加一个选项 menu_bar = self.menuBar() file_menu = menu_bar.addMenu('&amp;File') file_menu.addAction(exit_action) # 定义工具栏，添加一个退出动作 toolbar = self.addToolBar('&amp;Exit') toolbar.addAction(exit_action) 有的时候PyCharm给的代码提示不完全。网上说PyCharm配合vim插件来使用能带来很好的体验。生成的界面中，工具栏可以自由的拖动，可以放在上下左右4个地方。 同样的代码，可以很方便地移植到PyQt4中。 使用designer画出来的界面Ubuntu 使用designer绘制好界面后，讲ui文件转换成py代码。1234567891011121314151617181920import sysfrom PyQt5.QtWidgets import QMainWindow, QApplicationfrom ui_main_window import Ui_UAppMainWindowclass RustMainWindow(QMainWindow): &quot;&quot;&quot;主界面类&quot;&quot;&quot; def __init__(self): super(RustMainWindow, self).__init__() self.ma = Ui_UAppMainWindow() # designer画的界面 self.ma.setupUi(self)if __name__ == &quot;__main__&quot;: app = QApplication(sys.argv) main_window = RustMainWindow() main_window.show() sys.exit(app.exec_()) 复写__init__初始化方法时需要调用父类方法 PyQt4手写窗口代码和上面那个功能类似。 12345678910111213141516171819202122232425262728293031323334353637import sysfrom PyQt4.QtGui import QMainWindow, QTextEdit, QAction, QIcon, QApplicationclass AppMainWindow(QMainWindow): def __init__(self): super(AppMainWindow, self).__init__() self.init_ui() def init_ui(self): self.statusBar().showMessage('Main window is ready') self.setGeometry(500, 500, 450, 220) self.setMinimumSize(150, 120) self.setWindowTitle('MainWindow') text_edit = QTextEdit() self.setCentralWidget(text_edit) exit_action = QAction(QIcon('res/ic_s1.png'), 'Exit', self) exit_action.setShortcut('Ctrl+Q') exit_action.setStatusTip('Exit App') exit_action.triggered.connect(self.close) menu_bar = self.menuBar() file_menu = menu_bar.addMenu('&amp;File') file_menu.addAction(exit_action) toolbar = self.addToolBar('&amp;Exit') toolbar.addAction(exit_action)if __name__ == '__main__': app = QApplication(sys.argv) window = AppMainWindow() window.show() sys.exit(app.exec_()) 可以看出，PyQt4 和 5 的代码基本上是通用的。复写__init__的方法不同。","link":"/2016/12/28/PyQt_note/PyQt-QMainWindow_simple_practice/"},{"title":"PyQt 创建自定义QWidget","text":"PyQt5.QtWidgets 示例Win7 PyCharm Python3.5.1 PyQt5 主要文件：12345|-- main.py|-- res| `-- fish.jpg`-- ui `-- app_widget.py main.py12345678910111213import sysfrom PyQt5.QtWidgets import QApplicationfrom ui.app_widget import AppQWidgetif __name__ == '__main__': app = QApplication(sys.argv) w = AppQWidget() w.show() sys.exit(app.exec_()) app_main_window.py自定义了一个居中显示的窗口，关闭时弹确认框 12345678910111213141516171819202122232425262728293031323334353637383940414243from PyQt5.QtCore import QCoreApplicationfrom PyQt5.QtGui import QIconfrom PyQt5.QtWidgets import QWidget, QPushButton, QDesktopWidget, QMessageBoxclass AppQWidget(QWidget): &quot;&quot;&quot; A custom QWidget by Rust Fisher &quot;&quot;&quot; def __init__(self): super().__init__() self.init_ui() def init_ui(self): # self.setGeometry(300, 300, 400, 200) # 相当于move和resize self.resize(300, 200) self.move_to_center() self.setWindowTitle('Demo1') self.setWindowIcon(QIcon('res/fish.jpg')) btn1 = QPushButton('Quit', self) btn1.setToolTip('Click to quit') btn1.resize(btn1.sizeHint()) btn1.move(200, 150) btn1.clicked.connect(QCoreApplication.instance().quit) # cannot locate function connect def closeEvent(self, event): reply = QMessageBox.question(self, 'Message', 'Are you sure to quit now?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() def move_to_center(self): qr = self.frameGeometry() cp = QDesktopWidget().availableGeometry().center() # got center info here qr.moveCenter(cp) self.move(qr.topLeft()) # 应用窗口的左上方的点到qr矩形的左上方的点，因此居中显示在我们的屏幕上 Tips多控件可以存在list中存在一起，需要对整体操作时直接遍历列表 123456789101112131415161718192021222324252627282930 # 同组的控件可以存在同一个list中 self.cb_list = [ self.ma.i2cCB, self.ma.mipiCB, self.ma.eepromCB, self.ma.tem_sensorCB, self.ma.lensCB, self.ma.vcmCB, self.ma.mirrorCB, self.ma.mirrorCaliCB, ] self.test_count_et_list = [ self.ma.i2cCountEt, self.ma.mipiCountEt, self.ma.eepromCountEt, self.ma.tem_sensorCountEt, self.ma.lensCountEt, self.ma.vcmCountEt, self.ma.mirrorCountEt, self.ma.mirrorCaliCountEt, ]# 需要操作某组控件时 直接遍历列表def _click_test_item_cb(self): &quot;&quot;&quot; Update [choose all checkbox] by all test item state &quot;&quot;&quot; choose_all = True for cb in self.cb_list: choose_all = choose_all &amp; cb.isChecked() self.ma.selecteAllCB.setChecked(choose_all) QApplication与QWidgetQApplication是一个单例，在QWidget中可以通过QApplication.instance()获取到对象 实际上在实例化QApplication前就使用QtGui.QWidget()是会报错的12&gt;&gt;&gt; QtGui.QWidget()QWidget: Must construct a QApplication before a QPaintDevice参考 How QApplication() and QWidget() objects are connected in PySide/PyQt? 在我们自定义的QMainWindow中，也可以直接获取到QApplication的实例。1234567class RustMainWindow(QMainWindow): &quot;&quot;&quot; This is the main class &quot;&quot;&quot; def _trigger_english(self): print &quot;Change to English&quot;, QApplication.instance()# Change to English &lt;PyQt4.QtGui.QApplication object at 0x02ABE3A0&gt; 注意widget持有外部对象引用的问题如果在程序启动的地方将引用交给widget，退出时会造成应用无法关闭的问题（类似内存泄漏）。123456if __name__ == '__main__': app = QApplication(sys.argv) # 这里把app交给了MainWindow，MainWindow关闭时是无法正常退出应用的 main_d = RustMainWindow(app) # 不建议这么做 main_d.show() sys.exit(app.exec_())","link":"/2016/12/28/PyQt_note/PyQt5-Custom_QWidget/"},{"title":"PyCharm 安装和配置","text":"安装和配置PyCharm修改默认配置，修改config和system的路径，避免占据C盘太多的空间将PyQt中的工具PyUIC安装到PyCharm中，使用更便捷（Windows和Ubuntu平台） win7 Python3.5.1 PyQt5-5.6 PyCharm版本： JetBrains PyCharm Community Edition 2016.3.1(64) 安装路径： E:\\IntelliJ IDEA Community Edition 2016.1.1 PyCharm默认配置和Android Studio类似，可以自定义IDE的配置 在第一次启动前，找到bin\\idea.properties，修改一下路径 123idea.config.path=E:/IntelliJIDEAPath/configidea.system.path=E:/IntelliJIDEAPath/system 启动后，可以发现config和system都在E:/IntelliJIDEAPath下此举是为了避免C盘挤爆 PyCharm工程配置打开Settings1234Build, Execution, Deployment Console Python Console Python interpreter 选择 Python 3.5.1 假设有一个工程gui_app，同样要检查一下设置123Project: gui_app Project interpreter 选择3.5.1 后面会显示路径 安装扩展工具打开Settings &gt; Tools &gt; External Tools 选择新建+，或者编辑 安装QtDesignerName: QtDesigner12345Tool Settings Program: E:\\Python351\\Lib\\site-packages\\PyQt5\\designer.exe ## 选择安装好的PyQt5\\designer.exe Working directory: $FileDir$ 安装PyUIC将designer生成的ui文件转为py文件的工具；这是Python自带的工具 Name: PyUIC123456Tool Settings Program: E:\\Python351\\python.exe ## 选择安装好的python.exe Parameters: -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py Working directory: $FileDir$ Ubuntu下PyCharm配置将designer生成的ui文件转为py文件的工具需要sudo apt-get install pyqt5-dev-tools配置工具[Tool Settings]123Program: pyuic5Parameters: -o $FileNameWithoutExtension$.py $FileNameWithoutExtension$.uiWorking directory: $FileDir$","link":"/2016/12/28/PyQt_note/PyCharm-Install_and_config/"},{"title":"Python3.5 PyQt5 安装","text":"在Windows和Ubuntu下安装PyQt5需要先安装并配置好Python，Windows下需要配置环境变量。PyQt需要对应上Python版本。 Windows环境用pip3安装PyQt5先确认Python相关环境变量已经配置好，比如：1D:\\python36;D:\\python36\\Scripts;D:\\python36\\libs;然后运行pip3，参考 PyQt5 Download1pip3 install PyQt5从网上下载相关文件并安装，等待过程比较长。 PyQt5-5.6-gpl exe 安装方式Win7 Python3.5.1 PyQt5-5.6-gpl-Py3.5-Qt5.6.0-x64-2.exe （最新版本已经不再提供exe版本） 先安装Python3.5.1到 E:\\Python351再去官网下载PyQt5，翻墙后下载速度更快。双击安装，PyQt5会自动找到Python35的目录。本例中PyQt5安装到 E:\\Python351\\Lib\\site-packages\\PyQt5 现在就可以使用PyQt5了。 &gt;&gt;&gt; from PyQt5.QtWidgets import * 在命令行显示一个label试一下 123456&gt;&gt;&gt; import sys&gt;&gt;&gt; from PyQt5 import QtWidgets&gt;&gt;&gt; app = QtWidgets.QApplication(sys.argv)&gt;&gt;&gt; label = QtWidgets.QLabel('Label')&gt;&gt;&gt; label.resize(150,100)&gt;&gt;&gt; label.show() Ubuntu 16.04Python3.5直接安装1234sudo apt-get install python3-devsudo apt-get install python3-pyqt5sudo apt-get install qt5-default qttools5-dev-toolsdesigner # 启动designer 安装pyuic51sudo apt-get install pyqt5-dev-tools","link":"/2016/12/28/PyQt_note/Python-PyQt5_Python351_install/"},{"title":"Python3 读写csv文件中的数字","text":"环境与工具 Python3 PyCharm CE csv简介什么是csv？csv是逗号分隔的一种文件格式。例如下面这个csv格式的文本。123姓名,年龄,标签Rust Fisher,18,PythonTom Hanks,29,Java 这样的.csv文件可以用Excel或者WPS打开，会给出表格的形式。 要注意的是，csv是文本格式，并不是Excel的格式。我们用文本编辑器（例如xcode，记事本）是可以直接编辑它的。 读写csv文件读文件时先产生str的列表，把最后的换行符删掉；然后一个个str转换成int123456789101112131415161718## 读写csv文件csv_file = 'datas.csv'csv = open(csv_file,'w')for i in range(1,20): csv.write(str(i) + ',') if i % 10 == 0: csv.write('\\n')csv.close()result = []with open(csv_file,'r') as f: for line in f: linelist = line.split(',') linelist.pop()# delete: \\n for index, item in enumerate(linelist): result.append(int(item))print('\\nResult is \\n' , result) 输出：12Result is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 检查目录是否存在若目标目录不存在，则新建一个目录123456import osjson_dir = &quot;../dir_json/2017-04/&quot;if not os.path.exists(json_dir): print(&quot;json dir not found&quot;) os.makedirs(json_dir) print(&quot;Create dir &quot; + json_dir) 写文件时指定格式参考下面的代码，打开文件时指定utf8，转换成json时指定ensure_ascii=False123import jsonjson_file = open(json_dir + id + '.json', 'w', encoding='utf8')json_file.write(json.dumps(data_dict, ensure_ascii=False))避免写成的json文件乱码 函数 enumerate(iterable, start=0)返回一个enumerate对象。iterable必须是一个句子，迭代器或者支持迭代的对象。 enumerate示例1：12345678&gt;&gt;&gt; data = [1,2,3]&gt;&gt;&gt; for i, item in enumerate(data): print(i,item)0 11 22 3示例2：12345678&gt;&gt;&gt; line = 'one'&gt;&gt;&gt; for i, item in enumerate(line,4): print(i,item)4 o5 n6 e参考： https://docs.python.org/3/library/functions.html?highlight=enumerate#enumerate class int(x=0)class int(x, base=10)返回一个Integer对象。对于浮点数，会截取成整数。1234567891011&gt;&gt;&gt; print(int('-100'),int('0'),int('3'))-100 0 3&gt;&gt;&gt; int(7788)7788&gt;&gt;&gt; int(7.98)7&gt;&gt;&gt; int('2.33')Traceback (most recent call last): File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt; int('2.33')ValueError: invalid literal for int() with base 10: '2.33' 读取binary文件逐个byte读取，注意用b''来判断是否读到文件尾部1234567891011@staticmethoddef convert_bin_to_csv(bin_file_path, csv_file_path): if not os.path.exists(bin_file_path): print(&quot;Binary file is not exist! &quot; + bin_file_path) return with open(bin_file_path, &quot;rb&quot;) as bin_f: cur_byte = bin_f.read(1) while cur_byte != b'': # Do stuff with byte. print(int.from_bytes(cur_byte, byteorder='big', signed=True)) cur_byte = bin_f.read(1) 读取到的byte可以转换为int，参考文档 这里 cur_byte 类似于 b'\\x08'1print(int.from_bytes(cur_byte, byteorder='big', signed=True)) 从bin中读取数据并存入CSV文件中先从bin中读取byte，规定好几个字节凑成1个数字。按每行一个数字的格式写入CSV文件。 123456789101112@staticmethoddef convert_bin_to_csv(bin_file_path, csv_file_path, byte_count=1, byte_order='big', digit_signed=True): if not os.path.exists(bin_file_path): print(&quot;Binary file is not exist! &quot; + bin_file_path) return with open(csv_file_path, &quot;w&quot;) as csv_f: with open(bin_file_path, &quot;rb&quot;) as bin_f: cur_byte = bin_f.read(byte_count) while cur_byte != b'': csv_f.write(str(int.from_bytes(cur_byte, byteorder=byte_order, signed=digit_signed)) + &quot;,\\n&quot;) cur_byte = bin_f.read(byte_count) bin存储的数据格式一定要商量好。","link":"/2016/12/27/Python/Python-rw_in_csv/"},{"title":"Android NDK 示例-返回字符串，数组，Java对象；兼容性问题","text":"Android Studio 2.2.3 创建工程 NDKProj 工程准备在SmartAlgorithm.java中加载了库文件123456java`-- com `-- rustfisher `-- ndkproj |-- MainActivity.java `-- SmartAlgorithm.javaJNI目录，需要mk文件，头文件和源文件。这里头文件和源文件故意不统一文件名，也可实现效果。但还是建议用同样的文件名，方便定位。12345jni/|-- Android.mk|-- Application.mk|-- com_rustfisher_ndkproj_SmartAlgorithm.h`-- com_rustfisher_ndkproj_SmartAlgorithm_if_not_the_same.cpp NDK返回值加载SmartAlgorithm；这个是统一标示。LOCAL_MODULE 与 APP_MODULES 均为此标示。NDK中的方法要声明为native。1234567891011package com.rustfisher.ndkproj;public class SmartAlgorithm { static { System.loadLibrary(&quot;SmartAlgorithm&quot;); } public native String getMsg(); public native int add(int a,int b);}注意，Java文件生成头文件后，Java文件的路径不能轻易改动。 编写Android.mk文件；ABI 选择all，编译出支持多个平台的so文件。填入源文件的文件名。123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := SmartAlgorithmTARGET_ARCH_ABI := allLOCAL_SRC_FILES := com_rustfisher_ndkproj_SmartAlgorithm_if_not_the_same.cppinclude $(BUILD_SHARED_LIBRARY) 编写Application.mk文件（网上copy来的）。同样ABI 选择all。1234567APP_PLATFORM := android-16APP_MODULES := SmartAlgorithmAPP_ABI := allAPP_STL := stlport_staticAPP_CPPFLAGS += -fexceptions# for using c++ features,you need to enable these in your MakefileAPP_CPP_FEATURES += exceptions rtti 修改工程build.gradle文件，添加jni的配置。123456sourceSets { main { jni.srcDirs = [] jniLibs.srcDirs = ['src/main/libs']// 指定so库的位置 }} 编译出头文件，得到 com_rustfisher_ndkproj_SmartAlgorithm.h 12Administrator@rust-PC /cygdrive/g/rust_proj/NDKProj/app/src/main/javajavah com.rustfisher.ndkproj.SmartAlgorithm 将头文件放到jni目录下，与源文件一起。 生成的头文件不要手动去修改，直接使用即可。1234567891011121314151617181920212223242526272829/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_rustfisher_ndkproj_SmartAlgorithm */#ifndef _Included_com_rustfisher_ndkproj_SmartAlgorithm#define _Included_com_rustfisher_ndkproj_SmartAlgorithm#ifdef __cplusplusextern &quot;C&quot; {#endif/* * Class: com_rustfisher_ndkproj_SmartAlgorithm * Method: getMsg* Signature: ()Ljava/lang/String;*/JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getMsg (JNIEnv *, jobject);/* * Class: com_rustfisher_ndkproj_SmartAlgorithm * Method: add* Signature: (II)I*/JNIEXPORT jint JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_add (JNIEnv *, jobject, jint, jint);#ifdef __cplusplus}#endif#endif 编写源文件，实现头文件中的方法。一个是返回字符串，一个是加法。1234567891011121314151617181920#include &lt;jni.h&gt;#include &lt;string.h&gt;#include &lt;android/log.h&gt;#include &quot;com_rustfisher_ndkproj_SmartAlgorithm.h&quot;/* Already define in com_rustfisher_ndkproj_SmartAlgorithm.h, no need to extern C here.extern &quot;C&quot; { JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getMsg(JNIEnv *env, jobject obj); JNIEXPORT jint JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_add(JNIEnv *env, jobject obj, jint a, jint b);};*/JNIEXPORT jstring JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getMsg(JNIEnv *env, jobject obj) { return env-&gt;NewStringUTF(&quot;Hello from the JNI.&quot;);}JNIEXPORT jint JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_add(JNIEnv *env, jobject obj, jint a, jint b) { return a + b;}//* 然后在命令行 ndk-build。这里是win7下的Cygwin。123456Administrator@rust-PC /cygdrive/g/rust_proj/NDKProj/app/src/main/jni$ ndk-build.cmd[all] Compile++ : SmartAlgorithm &lt;= com_rustfisher_ndkproj_SmartAlgorithm_if_not_the_same.cpp[all] SharedLibrary : libSmartAlgorithm.so[all] Install : libSmartAlgorithm.so =&gt; libs/arm64-v8a/libSmartAlgorithm.so# ...... 后面还有很多 在libs目录下出现了对应的so库12345678910111213141516171819Administrator@rust-PC /cygdrive/g/rust_proj/NDKProj/app/src/main/libs$ tree.|-- arm64-v8a| `-- libSmartAlgorithm.so|-- armeabi| `-- libSmartAlgorithm.so|-- armeabi-v7a| `-- libSmartAlgorithm.so|-- mips| `-- libSmartAlgorithm.so|-- mips64| `-- libSmartAlgorithm.so|-- x86| `-- libSmartAlgorithm.so`-- x86_64 `-- libSmartAlgorithm.so7 directories, 7 files 在MainActivity中调用这两个方法。运行apk到机器上，查看log。发现调用成功。 12com.rustfisher.ndkproj D/MainActivity: onCreate: Hello from the JNI.com.rustfisher.ndkproj D/MainActivity: onCreate: 3 处理数组的方法1.不要直接操作输入的数组；2.注意释放本地引用，防止溢出。 1public native short[] getConvertedArray(short[] data, int dataLen); 12345678910111213141516JNIEXPORT jshortArray JNICALL Java_com_rustfisher_ndkproj_SmartAlgorithm_getConvertedArray(JNIEnv *env, jobject obj, jshortArray input, jint len) { jshort* inputPtr; inputPtr = env-&gt;GetShortArrayElements(input,0);// 直接操作指针会改变Android Dalvik中的值 jshort* resPtr; jshortArray result; result = env-&gt;NewShortArray(len);// 创建新的数组 resPtr = env-&gt;GetShortArrayElements(result,0);// 指针 for(jint i = 0;i &lt; len;i++) { resPtr[i] = inputPtr[i] * 2; } env-&gt;ReleaseShortArrayElements(input, inputPtr, 0);// 释放本地引用 env-&gt;SetShortArrayRegion(result,0,len,resPtr); // 存入数据 env-&gt;ReleaseShortArrayElements(result, resPtr, 0); // 释放本地引用 return result;// 返回结果} JNI层 unsigned char 与 jbyte 数组转换本例说明的是unsigned char 与 jbyte之间互相转换注意方法：(*env)-&gt;SetByteArrayRegion(env, jbyte_arr, 0, len, uc_ptr);java代码12345678910public byte[] getByteArrayFromJNI() { return nativeGetByteArray();}public byte[] byteArrayTravelJNI(byte[] input) { return nativeSendByteArray(input, input.length);}private native byte[] nativeGetByteArray(); // 从JNI中获取byte数组// 输入byte数组，在JNI中转换后再获取回来private native byte[] nativeSendByteArray(byte[] input, int len); JNI C代码12345678910111213141516171819202122232425262728293031323334// return byte array from unsigned char array. jbytes: 1 2 0 7f 80 81 ff 0 1JNIEXPORT jbyteArray JNICALL Java_com_rustfisher_ndkalgo_NDKUtils_nativeGetByteArray(JNIEnv *env, jobject jObj){ unsigned char uc_arr[] = {1, -2, 0, 127, 128, 129, 255, 256, 257}; int uc_arr_len = sizeof(uc_arr) / sizeof(uc_arr[0]); jbyte byte_array[uc_arr_len]; int i = 0; for(;i &lt; uc_arr_len; i++) { byte_array[i] = uc_arr[i]; } jbyteArray jbyte_arr = (*env)-&gt;NewByteArray(env, uc_arr_len); (*env)-&gt;SetByteArrayRegion(env, jbyte_arr, 0, uc_arr_len, byte_array); return jbyte_arr;}// jbyte -&gt; unsigned char -&gt; jbyteJNIEXPORT jbyteArray JNICALL Java_com_rustfisher_ndkalgo_NDKUtils_nativeSendByteArray (JNIEnv *env, jobject jObj, jbyteArray input_byte_arr, jint input_len){ int len = (int)input_len; jbyte *jbyte_ptr = (*env)-&gt;GetByteArrayElements(env, input_byte_arr, 0); unsigned char *uc_ptr = (unsigned char *)jbyte_ptr; jbyteArray jbyte_arr = (*env)-&gt;NewByteArray(env, len); jbyte byte_array[input_len]; int i = 0; for(;i &lt; input_len; i++) { byte_array[i] = uc_ptr[i]; } (*env)-&gt;SetByteArrayRegion(env, jbyte_arr, 0, len, byte_array); (*env)-&gt;ReleaseByteArrayElements(env, input_byte_arr, jbyte_ptr, 0); return jbyte_arr;} 关于SetByteArrayRegion这个方法方法说明：void SetXxxArrayRegion(JNIEnv *env, jarray array, jint start, jint length, Xxx elems[])将C数组的元素复制到Java数组中。注意最后一个参数要和前面的对应上。 void ReleaseXxxArrayElements(JNIEnv *env, jarray array, Xxx elems[], jint mode)通知虚拟机通过GetXxxArrayElements获得的一个指针已经不再需要了。Mode是0，更新数组元素后释放elems缓存。 在这里遇到过一个bug，同样的代码在armeabi上正常运行，但是到了v7a或v8a平台上就闪退。使用SetXxxArrayRegion这个方法时，传入的参数一定要和方法名中的Xxx对应上详细可以参考Core Java中的Java Native和Android Develop上关于abi的解释 测试调用12345678NDKUtils ndkUtils = new NDKUtils();byte[] res = ndkUtils.getByteArrayFromJNI(); // 从JNI中获取byte数组logBytes(res);Log.d(TAG, &quot;-------------------------------------------------------------&quot;);byte[] inputBytes = new byte[]{1, 2, 127, (byte) 128, (byte) 255, -120};byte[] tRes = ndkUtils.byteArrayTravelJNI(inputBytes); // 让byte数组在JNI中旅游一圈logBytes(inputBytes);logBytes(tRes); 输出1234bytes: 1 2 0 7f 80 81 ff 0 1 -------------------------------------------------------------bytes: 1 2 7f 80 ff 88 bytes: 1 2 7f 80 ff 88 直接操作输入的数组以int数组为例输入一个数组后，获取数组然后直接改变数组中的元素，最后释放掉本地引用 123456JNIEXPORT void JNICALL Java_com_rustfisher_ndkalgo_NDKUtils_nativeModifyArray (JNIEnv *env, jobject jObj, jintArray input_arr, jint input_len) { int * input_ptr = (*env)-&gt;GetIntArrayElements(env, input_arr, 0); input_ptr[input_len - 1] = input_ptr[input_len - 1] - 1; (*env)-&gt;ReleaseIntArrayElements(env, input_arr, input_ptr, 0); } 12345NDKUtils moUtil = new NDKUtils();int[] origin = new int[]{1, 2, 3, 4, 5, 6, 7};Log.d(TAG, &quot;origin before: &quot; + Arrays.toString(origin));moUtil.modifyArray(origin);Log.d(TAG, &quot;origin after: &quot; + Arrays.toString(origin)); 观察输出可以看出，输入的数组直接被改变了12origin before: [1, 2, 3, 4, 5, 6, 7]origin after: [1, 2, 3, 4, 5, 6, 6] 或者12345678910JNIEXPORT void JNICALL Java_com_rustfisher_face_1detect_1lib_CalHelper_cvtNV21 (JNIEnv *env, jclass jcls, jbyteArray input_arr,jint in_arr_len, jbyteArray target_arr, jint nv21_size, jint y_size, jint yuv_gap) { jbyte *in_ptr = env-&gt;GetByteArrayElements(input_arr, false); jbyte *target_ptr = env-&gt;GetByteArrayElements(target_arr, false); for(int i = y_size; i &lt; nv21_size; i+=2){ target_ptr[i] = in_ptr[i + yuv_gap + 1]; target_ptr[i + 1] = in_ptr[i + yuv_gap]; } } 返回Java对象NDK中可以创建Java对象并返回。例如我们新建一个JavaUser类。12345678910111213141516171819202122public class JavaUser { private int age; private String name; public JavaUser(int age, String name) { this.age = age; this.name = name; } public int getAge() { return age; } public String getName() { return name; } @Override public String toString() { return name + &quot;, &quot; + age; }} native方法返回一个JavaUser对象12345678910111213public class NDKUtils { static { System.loadLibrary(&quot;NDKMan&quot;); } public JavaUser createUser(int age, String name) { return nativeGetUser(age, name); } private native JavaUser nativeGetUser(int age, String name);} c文件实现代码。注意参数签名的写法，要参照标准。1234567JNIEXPORT jobject JNICALL Java_com_rustfisher_ndkalgo_NDKUtils_nativeGetUser (JNIEnv *env, jobject jObj, jint age, jstring name){ jclass userClass = (*env)-&gt;FindClass(env, &quot;com/rustfisher/ndkalgo/JavaUser&quot;); jmethodID userConstruct = (*env)-&gt;GetMethodID(env, userClass, &quot;&lt;init&gt;&quot;, &quot;(ILjava/lang/String;)V&quot;); return (*env)-&gt;NewObject(env, userClass, userConstruct, age, name);} 调用native方法生成对象12345private void testJavaUserNDK() { NDKUtils ndkUtils = new NDKUtils(); JavaUser tom = ndkUtils.createUser(20, &quot;Tom&quot;); Log.d(TAG, tom.toString());} NDK兼容性问题Vivo x6plus 兼容性问题。Vivo x6plus 打开Parrot界面即崩溃。但是Parrot官方APP能够正常使用。我自己的so库与Parrot的so库不兼容，出现 1234567java.lang.UnsatisfiedLinkError:dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.xx.xx.xxx-1/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.xx.xx.xxx-1/lib/arm64, /vendor/lib64, /system/lib64]]] couldn't find &quot;libjson.so&quot; at java.lang.Runtime.loadLibrary(Runtime.java:366) at java.lang.System.loadLibrary(System.java:988) at com.parrot.arsdk.ARSDK.loadSDKLibs(ARSDK.java:20) at com.parrot.sdk.activity.DronesListActivity.&lt;clinit&gt;(DronesListActivity.java:44) at java.lang.reflect.Constructor.newInstance(Native Method) 分析处理兼容性问题将Parrot官方apk解包后，找到so库文件。发现只有x86、mips、armeabi_v7a、armeabi 这4个。而我加载了有更多的库。 将我自己的so文件删除至只剩下Parrot那4个即可。 Android.mkTARGET_ARCH_ABI := x86 mips armeabi armeabi-v7a 同名so文件引起UnsatisfiedLinkError主工程app中带有C工程与so文件。现需要将所有的C工程移到新的模块mylib中。 新建模块mylib，将C工程复制进来。gradle中配置jni，因为修改了文件路径，重新生成头文件并修改cpp文件。在模块中进行ndk-build，获得so库。 安装运行app，出现UnsatisfiedLinkError：12java.lang.UnsatisfiedLinkError: No implementation found for void com.xx.jni.MyJNI.init(java.lang.String) (tried Java_com_xx_jni_MyJNI_init and Java_com_xx_jni_MyJNI_init__Ljava_lang_String_2)分析原因，app能够正常加载库文件，但未找到实现方法。app使用的so库，究竟是不是我们指定的那个。 尝试进行修复，原app工程的Android.mk中1LOCAL_MODULE := main移动到模块后，新的Android.mk修改为1LOCAL_MODULE := mynewmain库改了名字后，修改Java代码123static { System.loadLibrary(&quot;mynewmain&quot;);}重装app即可正常使用。 经过分析与尝试，删除原app工程中所有的so文件，再次重装app即可正常运行。不需要修改so库的名字。 错误原因猜想：app主工程与模块mylib中有同名的so文件，安装app时会优先使用app主工程中的so库。 jstring转为char的方法 jstring -&gt; charjstring转为char的方法12345678910111213141516char *jstringToChar(JNIEnv *env, jstring jstr) { char *rtn = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte *ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char *) malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; } env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;} 参考 JNI中string 、 char* 和 jstring 两种转换 - CSDN xlxxcc","link":"/2016/08/02/Android/NDK-use_sample_1/"},{"title":"Android NDK 初步","text":"开发环境： win7 64，Android Studio 2.1 需要工具：NDK，Cygwin 使用adb查看手机CPU架构信息将手机通过USB连接到电脑，adb shell进入手机根目录，执行cat /proc/cpuinfo12345678910111213141516171819shell@hnCHE-H:/ $ cat /proc/cpuinfocat /proc/cpuinfoProcessor : AArch64 Processor rev 3 (aarch64)processor : 0processor : 1processor : 2processor : 3processor : 4processor : 5processor : 6processor : 7Features : fp asimd evtstrm aes pmull sha1 sha2 crc32CPU implementer : 0x41CPU architecture: AArch64CPU variant : 0x0CPU part : 0xd03CPU revision : 3Hardware : hi6210sft可以看到手机处理器的信息 使用 SDK Manager 配置安装 NDK添加系统环境变量 G:\\SDK\\ndk-bundle;G:\\SDK\\platform-tools 下载并安装Cygwin：https://cygwin.com/install.html Cygwin 安装NDK需要的工具包（如果第一次安装时没有选择工具包，可以再次启动安装）：make, gcc, gdb, mingw64-x86_64-gcc, binutils 配置G:\\soft\\Cygwin\\home\\Administrator\\.bashrc，添加下面的指令，使用英文界面。12export LANG='en_US'export LC_ALL='en_US.GBK'配置text选项，在option里的text可设置。可以在G:\\soft\\Cygwin\\home\\Administrator\\.minttyrc中看到。 12Locale=zh_CNCharset=GBK 设置完字体后可以避免中文乱码。 配置 G:\\soft\\Cygwin\\home\\Administrator\\.bash_profile 12NDK=/cygdrive/G/SDK/ndk-bundle/ndk-build.cmdexport NDK 在Cygwin中查找NDK位置，可以看到在SDK目录里面 123Administrator@rust-PC /cygdrive/g/soft/Cygwin/home/Administrator$ echo $NDK/cygdrive/G/SDK/ndk-bundle/ndk-build.cmd 操作示例NDK工程JDK10已经不提供javah这个工具了，我们可以使用as支持c++的功能；详情见下文 生成一次试试。从github上获取android-ndk-android-mk，进入hello-jni工程。 123Administrator@rust-PC /cygdrive/g/rust_proj/android-ndk-android-mk/hello-jni$ ndk-build.cmd# 输出很多信息 编译成功后，自动生成一个libs目录，编译生成的.so文件放在里面。 1234567Administrator@rust-PC /cygdrive/g/rust_proj/NDKTest/app/src/main$ ndk-build.cmd[armeabi] Install : librust_ndk.so =&gt; libs/armeabi/librust_ndk.so# 进入java目录，编译.h文件Administrator@rust-PC /cygdrive/g/rust_proj/NDKTest/app/src/main/java$ javah com.rustfisher.ndktest.HelloJNI# 会生成一个.h文件 将它复制到jni文件夹下；这个就是JNI层的代码。 Ubuntu下javah报错。需要添加参数 1javah -cp /home/rust/Android/Sdk/platforms/android-25/android.jar:. com.example.LibUtil 使用C/C++实现JNI遇到错误： Error:Execution failed for task ‘:app:compileDebugNdk’. Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set “android.useDeprecatedNdk=true” in gradle.properties to continue using the current NDK integration. 解决办法：在app\\build.gradle文件中添加1234sourceSets.main { jniLibs.srcDir 'src/main/libs' jni.srcDirs = [] //disable automatic ndk-build call} 文件有3种：接口文件.h； 实现文件.c，注意与前面的.h文件同名； .h与.c生成的库文件.so 操作步骤小结From Java to C/C++Step 1 定义Java接口文件，里面定义好native方法。Step 2 javah生成.h接口文件 。Step 3 复制.h文件的文件名，编写C/C++文件。注意要实现.h中的接口。 NDK遇到的问题与注意事项文件关联问题写cpp源文件的时候，忘记include头文件。产生java.lang.UnsatisfiedLinkError: No implementation found for 之类的错误stackoverflow上有关于Android NDK C++ JNI (no implementation found for native…)的问题。 NDK本地对象数量溢出问题 Local ref table overflowNDK本地只允许持有512个本地对象，return后会销毁这些对象。必须注意，在循环中创建的本地对象要在使用后销毁掉。 1env-&gt;DeleteLocalRef(local_ref);// local_ref 是本地创建的对象 调用Java方法时，注意指定返回值env-&gt;CallBooleanMethod(resArrayList,arrayList_add, javaObject); ArrayList的add方法返回Boolean 参考：https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html C++调用C方法C++文件中，需要调用C里面的方法。如果未经任何处理，会出现无引用错误1error: undefined reference to '...... 因此在C++文件中涉及到C方法，需要声明。例如12345678#ifdef __cplusplusextern &quot;C&quot; {#include &quot;c_file_header.h&quot;#ifdef __cplusplus}#endif#endif// ___ 结束声明 javah生成的JNI头文件中也有extern，可作为参考 NDK中使用logcat配置：Cygwin， NDK 14.1…可以在NDK中使用logcat，方便调试需要在mk文件中添加1LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog 代码中添加头文件，即可调用logcat的方法1234#include &lt;android/log.h&gt;#define LOG_TAG &quot;rustApp&quot;__android_log_write(ANDROID_LOG_VERBOSE, LOG_TAG, &quot;My Log&quot;); 此时编译出现了错误：1234G:/SDK/ndk-bundle/build//../toolchains/x86_64-4.9/prebuilt/windows-x86_64/lib/gcc/x86_64-linux-android/4.9.x/../../../../x86_64-linux-android/bin\\ld: warning: skipping incompatible G:/SDK/ndk-bundle/build//../platforms/android-21/arch-x86_64/usr/lib/libc.a while searching for cG:/SDK/ndk-bundle/build//../toolchains/x86_64-4.9/prebuilt/windows-x86_64/lib/gcc/x86_64-linux-android/4.9.x/../../../../x86_64-linux-android/bin\\ld: error: treating warnings as errorsclang++.exe: error: linker command failed with exit code 1 (use -v to see invocation)make: *** [G:/openSourceProject/NDKAlgo/app/src/main/obj/local/x86_64/libNDKMan.so] Error 1 出现了error: treating warnings as errors处理方法，在mk文件中添加LOCAL_DISABLE_FATAL_LINKER_WARNINGS=true再次编译即可 我们可以使用宏定义简化打log的写法123456789#define LOG_TAG &quot;rustApp&quot;#define LOGV(...) __android_log_write(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG , LOG_TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO , LOG_TAG, __VA_ARGS__) #define LOGW(...) __android_log_print(ANDROID_LOG_WARN , LOG_TAG, __VA_ARGS__) #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , LOG_TAG, __VA_ARGS__) // 调用LOGV(&quot;This is my log&quot;); Android Studio 3 为library module添加C++支持as在新建project的时候可以选择支持C++，可以新建一个支持C++的项目来参考。可以不用自己javah来生成头文件。 在工程中新建android library，将CMakeLists.txt添加到模块中。这里模块名是native-lib12345678910111213141516171819202122232425cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp src/main/cpp/imagetool.cpp)find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. ${log-lib} ) 修改模块的build.gradle123456789101112131415161718192021222324252627282930android { compileSdkVersion 26 defaultConfig { minSdkVersion 19 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; // 添加 externalNativeBuild { cmake { cppFlags &quot;&quot; } } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } // 添加 externalNativeBuild { cmake { path &quot;CMakeLists.txt&quot; } }} 新建Java文件和C++文件，大致目录如下1234567891011main|-- AndroidManifest.xml|-- cpp| |-- imagetool.cpp // cpp文件| `-- native-lib.cpp|-- java| `-- com| `-- example| `-- myclib| `-- ImageDetect.java // Java文件`-- res ImageDetect.java123456789101112public class ImageDetect { static { System.loadLibrary(&quot;native-lib&quot;); } public static native void inputPath(String path); public static native String stringFromJNI(); public static native int getOne();} native-lib.cpp12345678910111213141516171819202122#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; {JNIEXPORT jstringJNICALLJava_com_example_myclib_ImageDetect_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &quot;In myclib Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str());}JNIEXPORT jintJNICALLJava_com_example_myclib_ImageDetect_getOne( JNIEnv *env, jobject /* this */) { return 9257;}} imagetool.cpp12345678910111213#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot;JNIEXPORT voidJNICALLJava_com_example_myclib_ImageDetect_inputPath( JNIEnv *env, jobject /* this */jobj, jstring inputPath) { // just test return;} 编译运行即可。","link":"/2016/06/14/Android/NDK-use_sample_2/"},{"title":"监听者模式 - 在Java与Android中的使用","text":"监听者模式（观察者模式）能降低对象之间耦合程度。为两个相互依赖调用的类进行解耦。便于进行模块化开发工作。不同模块的开发者可以专注于自身的代码。监听者用来监听自已感兴趣的事件，当收到自已感兴趣的事件时执行自定义的操作。在某些数据变化时，其他的类做出一些响应。处理数据（或者分发事件）的类主动投送消息，感兴趣的类主动“订阅”消息。 监听者模式在Android中有大量的运用，相信大家都不会感到陌生。在Android开发中，Button控件的点击事件就是监听者模式最常见的例子。当Button被点击，执行了 OnClickListener.onClick。Activity中给这个Button设置了自己实现的OnClickListener，并复写了onClick方法，就能执行自定义操作了。 Java代码实例下面来用Java来实现监听者模式。这个例子是给“计算类”持续地传入数据，处理好数据后，发出结果。感兴趣的类接收结果。2个文件：AlgoCalculator.java；MainUser.java AlgoCalculator.java是计算部分，接收数据并进行计算。并将结果传递出去。 MainUser.java是调用方，将基本数据传入AlgoCalculator并监听结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.algo;import java.util.LinkedList;import java.util.List;public class AlgoCalculator { private List&lt;short[]&gt; mDataBuffer = new LinkedList&lt;&gt;(); public AlgoCalculator() { } // 定义一个Listener接口；可将一个boolean值传递出去 public interface ResultChangeListener { void onChange(boolean found); } private ResultChangeListener resultChangeListener; // 调用方能够设置并实现这个接口 public void setResultChangedListener(ResultChangeListener resultChangedListener) { this.resultChangeListener = resultChangedListener; } // 传输数据 public void setDataStream(short[] data) { checkData(data);// 处理数据方法 } // 处理数据，并送出结果 private void checkData(short[] data) { if (data.length == 0) { return; } long sum = 0; for (short b : data) { sum += b; } if (sum &gt; 40) { resultChangeListener.onChange(true); // 数据处理结果 } else { resultChangeListener.onChange(false); } }} 主程序；调用方传入数据，获取结果123456789101112131415161718192021222324import com.algo.AlgoCalculator;public class MainUser { public static void main(String[] args) { AlgoCalculator algoCalculator = new AlgoCalculator(); // 初始化 // 设置监听器，并在里面增加要执行的动作 algoCalculator.setResultChangedListener(new AlgoCalculator.ResultChangeListener() { @Override public void onChange(boolean found) { System.out.println(&quot;result: &quot; + found); } }); short[] data1 = {1, 2, 3,}; short[] data2 = {10, 20, 30}; short[] data3 = {6, 7, 8}; short[] data4 = {1, 1, 1}; // 传入数据 algoCalculator.setDataStream(data1); // output false algoCalculator.setDataStream(data2); // output true algoCalculator.setDataStream(data3); // output false algoCalculator.setDataStream(data4); // output false }}在另外的类里，能够很方便地调用AlgoCalculator的计算能力并获取计算结果。在这里，每传入一次数据，就能获取一个结果。如果每秒钟传入一次数据，每秒钟就能获取一个结果。我们可以把复杂的算法封装起来，客户端只需要传入数据，即可获得（监听到）结果。 很多场景中都使用了监听者模式。开发者也可能在不知不觉中就运用了这个模式。 Android中使用监听器最常见的例子是给Button设置点击事件监听器。类似上个例子，设计一个接口当做监听器。Android中回调时可以利用handler，控制调用的线程。123456789101112131415private Handler mMainHandler;mMainHandler = new Handler(Looper.getMainLooper());// 在主线程中运行private void notifySthChange(final int state) { mMainHandler.post(new Runnable() { @Override public void run() { ArrayList&lt;SListener&gt; list = new ArrayList&lt;&gt;(mListeners); for (SListener l : list) { l.OnSthChanged(state); } } });}在回调中可以直接更新UI。","link":"/2016/05/16/DesignPattern/Listener_pattern_practice_in_Java_Android/"},{"title":"aboutView 开发记录","text":"工程地址 https://github.com/RustFisher/aboutView 虚拟键盘 - VKeyboardVKeyboard - Virtual keyboard 定义按键类定义Key类，代表按键。属性有ascii码，是否使用TextView，是否使用ImageView，按键类别（功能键，普通键）等。 123456public static class Key { private int keyType; // 按键种类 是普通按键或者是功能按键 private int uiType = UI_TEXT_VIEW; // UI使用的View类型 private String keyText; // 显示的文字 // ....} UI控制器实现实现一个虚拟键盘。采用给LinearLayout添加子view的方式。做一个UI控制器（Widget），需要传入一个LinearLayout作为根view。根据设置的键盘宽度动态调整每个按键的大小。 这种方式不太适合组件化。 创建组件的方式将「按键」装配到键盘上。采用适配器模式，将View添加到ViewGroup中。 VKey代表按键，VKeyboardBody代表键盘，VRow代表键盘上的一行，VKeyboardListener是监听器。VKeyboard继承Framelayout，创建适配器VKeyboard.Adapter，将「按键」装配到键盘上。 VKey - 按键代表按键。装载着keyCode，背景资源等等属性值。 VKeyboardBody - 键盘代表键盘的显示样式。比如UI的padding值和margin值。 VRow - 行一行按键。实际上是一个LinearLayout的属性值合集。 VKeyboardListener - 监听器事件监听器。例如点击事件等等。 VKeyboard - 键盘UI类实际上继承了FrameLayout。通过VKeyboard.Adapter获取到键盘的按键配置信息。创建对应的子View，并添加到FrameLayout中。 VKeyboard构造函数构造函数中有AttributeSet。attrs里面有id，layout_width，layout_height等等信息。 想在View的构造器中获取到定义中xml中的属性，需要从AttributeSet中获取。可能会获取到-1或-2，分别代表MATCH_PARENT和WRAP_CONTENT。因此要判断获取到的数字是否大于0，如果大于0则表明是一个指定的宽度，直接记下这个宽度值。获取到xml中指定的宽度后，再计算子view的宽度。12345678910111213141516public VKeyboard(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); int[] attrsArray = new int[]{ android.R.attr.id, // 0 android.R.attr.background, // 1 android.R.attr.layout_width, // 2 android.R.attr.layout_height // 3 }; final TypedArray a = context.obtainStyledAttributes(attrs, attrsArray); int layoutWidth = a.getLayoutDimension(2, ViewGroup.LayoutParams.MATCH_PARENT); if (layoutWidth &gt; 0) { keyboardWidthPx = layoutWidth; } a.recycle(); initKeyboardUI(context);} 参考 https://stackoverflow.com/questions/8037101/how-to-get-attributeset-properties12345678910111213141516public MapView(Context context, AttributeSet attrs) { // ... int[] attrsArray = new int[] { android.R.attr.id, // 0 android.R.attr.background, // 1 android.R.attr.layout_width, // 2 android.R.attr.layout_height // 3 }; TypedArray ta = context.obtainStyledAttributes(attrs, attrsArray); int id = ta.getResourceId(0 /* index of attribute in attrsArray */, View.NO_ID); Drawable background = ta.getDrawable(1); int layout_width = ta. getLayoutDimension(2, ViewGroup.LayoutParams.MATCH_PARENT); int layout_height = ta. getLayoutDimension(3, ViewGroup.LayoutParams.MATCH_PARENT); ta.recycle();} 给Keyboard添加按键（key）。在activity onCreate的时候，Keyboard已经执行了构造函数。之后我们通过setAdapter的方式给它添加key。","link":"/2015/12/25/Dev-note/dev-note-aboutView/"},{"title":"awk命令的使用","text":"Ubuntu14.04 目的：想用awk来统计某个文本中单词出现的次数，并以一定的格式输出结构通常，awk逐行处理文本。awk每接收文件的一行，然后执行相应的命令来处理。 用legal文件来做示例12345678$ cat /etc/legalThe programs included with the Ubuntu system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted byapplicable law. 搜索统计单词“law”的个数12$ awk -F : '/law/{count++} END{print &quot;the count is &quot;,count}' /etc/legalthe count is 1 统计单词“the”的个数12$ awk -F : '/the/{count++} END{print &quot;the count is &quot;,count}' /etc/legalthe count is 3 找到指定单词，自定义变量count自增，最后输出语句和count值 命令sort，把各行按首字母排列顺序重新排列起来 sort -nr，每行都以数字开头，按数字从达到小，排列各行 uniq -c，统计各行出现的次数，并把次数打印在每行前端 awk参数 NF - 浏览记录的域的个数 综合起来，命令就是12awk -F' ' '{for(i=1;i&lt;=NF;i=i+1){print $i}}' /etc/legal |sort|uniq -c|sort -nr|awk -F' ' '{printf(&quot;%s %s\\n&quot;,$2,$1)}'统计/etc/legal中单词出现次数，并以“单词 次数”格式输出结果","link":"/2015/12/16/Linux/awk-use/"},{"title":"grep 搜索字符串","text":"grep 搜索，怎样排除某些目录？使用 --exclude-dir 选项。 语法:1--exclude-dir=DIR Exclude directories matching the pattern DIR from recursive searches. 单个目录示例-R是表示启用正则1grep -E &quot;http&quot; ./ -R --exclude-dir=.git 多个目录示例1grep -E &quot;http&quot; . -R --exclude-dir={.git,res,bin} 多个文件示例排除扩展名为 java 和 js 的文件1grep -E &quot;http&quot; . -R --exclude=*.{java,js} 排除扩展名为 java，md~ 和 js 的文件123~/wd/rustNote/Linux_note$ grep -E DIR -R --exclude=*.{java,js,md~}grep_note.md: --exclude-dir=DIRgrep_note.md: Exclude directories matching the pattern DIR from recursive searches. 排除扩展名为java， js 和 md~ 的文件 排除一些文件，并且显示行号-n1grep -n -E &quot;org/webrtc/&quot; . -R --exclude=*.{java,ninja,TOC,so,o,jar} 如何在 Linux 系统和类 Unix 的操作系统中使用带正则表达式的 grep 命令呢？Linux 系统自带了支持拓展正则表达式的 GNU 版本 grep 工具。所有的 Linux 系统中默认安装的都是 GNU 版 grep 。grep 命令被用来检索一台服务器或工作站上任何位置的文本信息。 快速了解正则表达式如何匹配你要查找的内容？正则表达式只不过是每个输入行匹配的模式。模式是一个字符序列。下面都是范例： 例如：^w1”、“w1|w2”、“[^ ]。 在 /etc/passswd 中检索 vivek ： grep vivek /etc/passwd 输出结果案例：123vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bashvivekgite:x:1001:1001::/home/vivekgite:/bin/shgitevivek:x:1002:1002::/home/gitevivek:/bin/sh在任何情况下都搜索 ‘vivek’ (即不区分大小)：grep -i -w vivek /etc/passwd不区分大小写地检索 ‘vivek’ 和 ‘raj’ ： grep -E -i -w 'vivek|raj' /etc/passwd在最后一个例子中，使用了扩展正则表达式的模式。 固定检索内容的位置：你可以使用 ^ 和 $ 符号强制一个正则表达式分别匹配一行的开始或结束的位置。下面的示例显示以 ‘vivek’ 开头的文本： grep ^vivek /etc/passwd输出结果示例：12vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bashvivekgite:x:1001:1001::/home/vivekgite:/bin/sh 以#!开头的行123rust@rust-pc:~/note/Linux_note$ grep '^#!' *organize_so_names.sh:#! /bin/shsort_ranking_solution.md:#! /bin/sh 你可以只显示以 vivek 开头的文本行。举例说就是不显示 vivekgite , vivekg 这样单词开头的。grep -w ^vivek /etc/passwd 检索以 ‘foo’ 结尾的文本格式：grep 'foo$' FILENAME 你还可以用下面这样的方式搜索空白行：grep '^$' FILENAME 如何匹配具体字符？匹配 ‘Vivek’ 或 ‘vivek’ ：grep '[vV]ivek' FILENAME 或者可以这样：grep '[vV][iI][Vv][Ee][kK]' FILENAME 你可以匹配数字（例如匹配 vivek1 或 Vivek2 ）：grep -w '[vV]ivek[0-9]' FILENAME 你可以匹配两位数（例如匹配 foo11 ， foo12 ）：grep 'foo[0-9][0-9]' FILENAME 不仅仅是数字，你可以匹配字母：grep '[A-Za-z]' FILENAME 显示所有包含 “w” 或 “n” 字母的文本行：grep [wn] FILENAME 在括号内的表达式中，在“ [: ”和“ :] ”中所附的字符类的名称：代表属于该类的所有字符的列表。标准字符类名称： [:alnum:] – 字母数字字符 [:alpha:] – 字母顺序 [:blank:] – 空格和制表符 [:digit:] – 数字： ‘0 1 2 3 4 5 6 7 8 9’ [:lower:] – 小写字母：‘a b c d e f ’ [:space:] – 特殊字符：制表符，换行符，垂直制表符、换页，回车，和空间 [:upper:] – 大写字母：‘A B C D E F G H I J K L M N O P Q R S T U V W X Y Z’ 在下面这个例子中，匹配所有大写字母：grep '[:upper:]' FILENAME 如何使用通配符？你可以用 “.” 来代替单个字符。在下面的例子中，查询了所有以字母 “b” 开头、字母 “t” 结尾的三个字符的单词。grep '\\&lt;b.t\\&gt;' FILENAME在上面的例子中，\\&lt; 在单词的开始位置匹配空格字符串\\&gt; 在单词的结尾匹配空格字符串检索并输出所有两个字母的结果：grep '^..$' FILENAME检索并显示所有以 ‘.’ 和数字开头的结果：grep '^\\.[0-9]' FILENAME转义字符’.’正则表达式查找 IP 地址 192.168.1.254 将不能获得预期的结果：grep '192.168.1.254' /etc/hosts其中三个点都需要被转义：grep '192\\.168\\.1\\.254' /etc/hosts 以下示例将只匹配一个地址：egrep '[[:digit:]]{1,3}\\.[[:digit:]]{1,3}\\.[[:digit:]]{1,3}\\.[[:digit:]]{1,3}' FILENAME 以下将不分大小写地匹配单词 Linux 或 Unix ：egrep -i '^(linux|unix)' FILENAME 深入探索 grep 高级查找模式如何检索一个具有以 ‘-‘ 开头的的模式？使用 -e 选项搜索所有匹配 ‘–test–‘ 的结果。grep 会尝试把 ‘–test–‘ 作为一个选项解析：grep -e '--test--' FILENAME 如何在grep中使用 OR 的逻辑运算 ？grep -E 'word1|word2' FILENAME 或者 egrep 'word1|word2' FILENAME或者可以这样做grep 'word1\\|word2' FILENAME 如何在grep中使用 AND 的逻辑运算 ？按照下面的语法显示所有包含了单词 ‘word1′ 和 ‘word2′ 的结果：grep 'word1' FILENAME | grep 'word2' 或者可以这样：grep 'foo.*bar\\|word3.*word4' FILENAME 如何测试序列？你可以使用下面的语法测试一个字符在序列中的重复的次数： {N} {N,} {min,max} 匹配包含两个字母 v 的字符串结果：egrep &quot;v{2}&quot; FILENAME 下面的例子中将检索文件内包含 “col” 和 “cool” 的字符串结果：egrep 'co{1,2}l' FILENAME 搜索pattern或patern123rust@rust-pc:~/note/Linux_note$ egrep 'pat{1,2}ern' *grep_note.md:Exclude directories matching the pattern DIR from recursive searches.grep_note.md:grep_note.md: Exclude directories matching the pattern DIR from recursive searches.下面的例子中将匹配至少含有3个字母 c 的结果：egrep 'c{3,}' FILENAME 下面的示例将匹配 “91-1234567890″ 格式的手机号码（即 “两位数字-十位数字”）grep &quot;[[:digit:]]\\{2\\}[ -]\\?[[:digit:]]\\{10\\}&quot; FILENAME 如何使 grep 的输出结果高亮标注？使用下面例子的语法：grep --color regex FILENAME 如何使 grep 的输出只显示匹配的部分而不是整行？使用下面例子的语法：grep -o regex FILENAME 统计行数1grep &quot;&quot; -r . | wc -l","link":"/2015/11/29/Linux/grep_note/"},{"title":"Android 广播机制（Broadcast）介绍与使用","text":"Android应用可以通过广播从系统或其他App接收或发送消息。类似于订阅-发布设计模式。当某些事件发生时，可以发出广播。系统在某些状态改变时会发出广播，例如开机、充电。App也可发送自定义广播。广播可用于应用间的通讯，是IPC的一种方式。 广播的种类广播的种类也可以看成是广播的属性。 标准广播（Normal Broadcasts）完全异步的广播。广播发出后，所有的广播接收器几乎同时接收到这条广播。不同的App可以注册并接到标准广播。例如系统广播。 有序广播（Ordered Broadcasts）同步广播。同一时刻只有一个广播接收器能接收到这条广播。这个接收器处理完后，广播才会继续传递。有序广播是全局的广播。 本地广播（Local Broaddcasts）只在本App发送和接收的广播。注册为本地广播的接收器无法收到标准广播。 带权限的广播发送广播时可以带上相关权限，申请了权限的App或广播接收器才能收到相应的带权限的广播。如果在manifest中申请了相应权限，接收器可以不用再申请一次权限即可接到相应广播。 接收广播创建广播接收器，调用onReceive()方法，需要一个继承BroadcastReceiver的类。 注册广播代码中注册称为动态注册。在AndroidManifest.xml中注册称为静态注册。动态注册的刚波接收器一定要取消注册。在onDestroy()方法中调用unregisterReceiver()方法来取消注册。 不要在onReceive()方法中添加过多的逻辑操作或耗时的操作。因为在广播接收器中不允许开启线程，当onReceive()方法运行较长时间而没结束时，程序会报错。因此广播接收器一般用来打开其他组件，比如创建一条状态栏通知或启动一个服务。 新建一个MyExampleReceiver继承自BroadcastReceiver。1234567public class MyExampleReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,&quot;Got it&quot;,Toast.LENGTH_SHORT).show(); //abortBroadcast(); }}abortBroadcast()可以截断有序广播 在AndroidManifest.xml中注册广播接收器；name里填接收器的名字。可以设置广播接收器优先级：1234567&lt;intent-filter android:priority=&quot;100&quot;&gt;&lt;receiver android:name=&quot;.MyExampleReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.rust.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 让接收器接收到一条“com.rust.broadcasttest.MY_BROADCAST”广播。发送自定义广播（标准广播）时，要传送这个值。例如：12Intent intent = new Intent(&quot;com.rust.broadcasttest.MY_BROADCAST&quot;);sendBroadcast(intent); 发送有序广播，应当调用sendOrderedBroadcast()；12Intent intent = new Intent(&quot;com.rust.broadcasttest.MY_BROADCAST&quot;);sendOrderedBroadcast(intent，null); 发送广播App有3种发送广播的方式。发送广播需要使用Intent类。 sendOrderedBroadcast(Intent, String)发送有序广播。每次只有1个广播接收器能接到广播。接收器接到有序广播后，可以完全地截断广播，或者传递一些信息给下一个接收器。有序广播的顺序可受android:priority标签影响。同等级的接收器收到广播的顺序是随机的。 sendBroadcast(Intent)以一个未定义的顺序向所有接收器发送广播。也称作普通广播。这种方式更高效，但是接收器不能给下一个接收器传递消息。这类广播也无法截断。 LocalBroadcastManager.sendBroadcast广播只能在应用程序内部进行传递，并且广播接收器也只能接收到来自本应用程序发出的广播。这个方法比全局广播更高效（不需要Interprocess communication，IPC），而且不需要担心其它App会收到你的广播以及其他安全问题。 广播与权限发送带着权限的广播当你调用sendBroadcast(Intent, String)或sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle)时，你可以指定一个权限。接收器在manifest中申请了相应权限时才能收到这个广播。 例如发送一个带着权限的广播12sendBroadcast(new Intent(&quot;com.example.NOTIFY&quot;), Manifest.permission.SEND_SMS); 接收广播的app必须注册相应的权限1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 当然也可以使用自定义permission。在manifest中使用permission标签1&lt;permission android:name=&quot;custom_permission&quot; /&gt;添加后编译一下。即可调用Manifest.permission.custom_permission 接收带权限的广播若注册广播接收器时申明了权限，那么只会接收到带着相应权限的广播。 在配置文件中声明权限，程序才能访问一些关键信息。例如允许查询系统网络状态。1234&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;!-- 机器开机广播 --&gt;&lt;uses-permission android:name=&quot;android.permission.BOOT_COMPLETED&quot;&gt;如果没有申请权限，程序可能会意外关闭。 示例 - 使用标准广播，本地广播，带权限的广播，有序广播发送和接收广播。分为发送和接收方2个App。 使用带权限的广播。系统权限与自定义权限。使用权限需要在AndroidManifest.xml中声明。如果是自定义权限，需要先添加自定义权限。123&lt;!-- 自定义的权限 给广播用 --&gt;&lt;permission android:name=&quot;com.rust.permission_rust_1&quot; /&gt;&lt;uses-permission android:name=&quot;com.rust.permission_rust_1&quot; /&gt; 发送广播时带上权限声明。接收方（不论是否己方App）需要在AndroidManifest.xml中申请权限。注册接收器时也需要声明权限。 发送不带权限的有序广播12345private void sendStandardOrderBroadcast() { Intent intent = new Intent(MSG_PHONE); sendOrderedBroadcast(intent, null); Log.d(TAG, &quot;[App1] 发送不带权限的有序广播, &quot; + intent.getAction());} 发送方App1代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123private static final String TAG = &quot;rustApp&quot;;public static final String MSG_PHONE = &quot;msg_phone&quot;;public static final String PERMISSION_RUST_1 = &quot;com.rust.permission_rust_1&quot;; // 注册广播接收器 registerReceiver(mStandardReceiver1, makeIF()); registerReceiver(mStandardReceiver2, makeIF()); registerReceiver(mStandardReceiver3, makeIF()); registerReceiver(mStandardReceiverWithPermission, makeIF(), Manifest.permission.permission_rust_1, null); // 带上权限 LocalBroadcastManager.getInstance(getApplicationContext()) .registerReceiver(mLocalReceiver1, makeIF()); LocalBroadcastManager.getInstance(getApplicationContext()) .registerReceiver(mLocalReceiver2, makeIF()); LocalBroadcastManager.getInstance(getApplicationContext()) .registerReceiver(mLocalReceiver3, makeIF()); // 解除接收器 unregisterReceiver(mStandardReceiver1); unregisterReceiver(mStandardReceiver2); unregisterReceiver(mStandardReceiver3); unregisterReceiver(mStandardReceiverWithPermission); LocalBroadcastManager.getInstance(getApplicationContext()) .unregisterReceiver(mLocalReceiver1); LocalBroadcastManager.getInstance(getApplicationContext()) .unregisterReceiver(mLocalReceiver2); LocalBroadcastManager.getInstance(getApplicationContext()) .unregisterReceiver(mLocalReceiver3);// 发送标准广播private void sendStandardBroadcast() { Intent intent = new Intent(MSG_PHONE); sendBroadcast(intent); Log.d(TAG, &quot;[App1] Dispatcher 发送标准广播&quot;);}// 发送带权限的标准广播private void sendStandardBroadcastWithPermission() { Intent intent = new Intent(MSG_PHONE); sendBroadcast(intent, PERMISSION_RUST_1); Log.d(TAG, &quot;[App1] Dispatcher 发送带权限的标准广播&quot;);}// 发送本地广播private void sendAppLocalBroadcast() { Intent intent = new Intent(MSG_PHONE); LocalBroadcastManager.getInstance(getApplicationContext()).sendBroadcast(intent); Log.d(TAG, &quot;[App1] Dispatcher 发送本地广播&quot;);}private IntentFilter makeIF() { IntentFilter intentFilter = new IntentFilter(MSG_PHONE); intentFilter.addAction(Intent.ACTION_TIME_TICK); intentFilter.addAction(Intent.ACTION_TIME_CHANGED); return intentFilter;}// 标准接收器 用context来注册private BroadcastReceiver mStandardReceiver1 = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 标准接收器1 收到: &quot; + intent.getAction()); }};// 标准接收器 用context来注册private BroadcastReceiver mStandardReceiver2 = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 标准接收器2 收到: &quot; + intent.getAction()); if (intent.getAction().endsWith(MSG_PHONE)) { abortBroadcast(); // 截断有序广播 Log.d(TAG, &quot;[App1] 标准接收器2截断有序广播 &quot; + intent.getAction()); } }};// 标准接收器 用context来注册private BroadcastReceiver mStandardReceiver3 = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 标准接收器3 收到: &quot; + intent.getAction()); }};// 注册的时候给它带权限 标准接收器private BroadcastReceiver mStandardReceiverWithPermission = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 带权限的标准接收器收到: &quot; + intent.getAction()); }};/** * 用LocalBroadcastManager来注册成为本地接收器 * 收不到标准广播 - 不论是本app发出的还是别的地方发出来的 */private BroadcastReceiver mLocalReceiver1 = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 本地接收器1 收到: &quot; + intent.getAction()); }};private BroadcastReceiver mLocalReceiver2 = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 本地接收器2 收到: &quot; + intent.getAction()); }};private BroadcastReceiver mLocalReceiver3 = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App1] 本地接收器3 收到: &quot; + intent.getAction()); }}; 接收方App2代码123&lt;!-- 自定义的权限 给广播用 --&gt;&lt;permission android:name=&quot;com.rust.permission_rust_1&quot; /&gt;&lt;uses-permission android:name=&quot;com.rust.permission_rust_1&quot; /&gt; 123456789101112131415161718192021222324252627282930public static final String MSG_PHONE = &quot;msg_phone&quot;; registerReceiver(mDefaultReceiver, makeIF()); LocalBroadcastManager.getInstance(getApplicationContext()) .registerReceiver(mLocalReceiver, makeIF()); unregisterReceiver(mDefaultReceiver); LocalBroadcastManager.getInstance(getApplicationContext()) .unregisterReceiver(mLocalReceiver); private BroadcastReceiver mDefaultReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App2] standard receive: &quot; + intent.getAction()); } }; private BroadcastReceiver mLocalReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Log.d(TAG, &quot;[App2] local receive: &quot; + intent.getAction()); } }; private IntentFilter makeIF() { IntentFilter intentFilter = new IntentFilter(MSG_PHONE); intentFilter.addAction(Intent.ACTION_TIME_TICK); intentFilter.addAction(Intent.ACTION_TIME_CHANGED); return intentFilter; } 使用LocalBroadcastManager发出的本地广播，另一个App是接收不到的。要收到本地广播，同样需要LocalBroadcastManager来注册接收器。 可以把本地广播看成是一个局部的，App内的广播体系。 实验中我们注意到，Intent.ACTION_TIME_TICK广播是可以截断的。","link":"/2015/10/29/Android/Android-Broadcast_intro_use/"},{"title":"Android AIDL 了解与使用","text":"AIDL简介AIDL（Android Interface Definition Language, Android 接口定义语言）用于定义C/S体系结构中Server端可以提供的服务调用接口，框架层提供的Java系统服务接口大多由AIDL语言定义。Android提供了AIDL工具，可将AIDL文件编译成Java文件。提高服务开发的效率 程序员可以利用AIDL自定义编程接口，在客户端和服务端之间实现进程间通信（IPC）。在Android平台上，一个进程通常不能访问另外一个进程的内存空间，因此，Android平台将这些跨进程访问的对象分解成操作系统能够识别的简单对象。并为跨应用访问而特殊编排和整理这些对象。用于编排和整理这些对象的代码编写起来十分冗长，所以Android的AIDL提供了相关工具来自动生成这些代码。 开发人员只需要在AIDL文件中定义Server端可以提供的服务方法，AIDL工具便可将其转化为Java文件。转化后的Java文件包含C/S体系结构的以下内容： 服务接口 （IPowerManager） 服务在Client端的代理（Proxy） 服务存根（Stub） Binder类型与IIterface类型的转换接口（asInterface 和 asBinder 方法） 服务方法请求码 AIDL意义AIDL工具建立了基于Binder的C/S体系结构的通用组件；开发者可以专注于开发服务的功能，而不需理会具体的通信结构，提高效率。 应用示例根据上文我们可以知道，我们创建两个apk，一个作为服务提供方，一个作为AIDL服务调用方。 AIDL服务提供方代码首先是AIDL服务提供方主要文件目录123456789101112131415161718main/aidl/`-- com `-- rustfisher `-- ndkproj `-- ITomInterface.aidl // AIDL代码main/java`-- com `-- rustfisher |-- tom | `-- TomService.java // 对应的Servicebuild/generated/source/aidl/`-- debug `-- com `-- rustfisher `-- ndkproj `-- ITomInterface.java // 工程编译后AIDL生成的Java文件 提供给调用方 新建AIDL文件并写好接口进入服务方的工程，右键新建AIDL文件ITomInterface.aidl。文件会默认生成在main/aidl/com/rustfisher/ndkproj下12345678910// ITomInterface.aidlpackage com.rustfisher.ndkproj;// 文件名应该和接口名相同// 编写好AIDL文件后可以先编译一次interface ITomInterface { void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); String helloAIDL(String name); // 此次使用的方法} 编写服务方的接口实现代码在com.rustfisher.tom包内创建TomService.java文件；建立内部类TomServiceImpl实现接口的功能12345678910111213141516171819202122232425import com.rustfisher.ndkproj.ITomInterface;public class TomService extends Service { private static final String TAG = &quot;rustApp&quot;; public class TomServiceImpl extends ITomInterface.Stub { @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException { } @Override public String helloAIDL(String name) throws RemoteException { Log.d(TAG, name + &quot; requires helloAIDL()&quot;); return &quot;Hello &quot; + name + &quot;, nice to meet you!&quot;; } } @Nullable @Override public IBinder onBind(Intent intent) { return new TomServiceImpl(); // 绑定服务则返回 TomServiceImpl 实例 }} 服务方在AndroidManifest.xml文件中配置实现了TomService类后，对此AIDL服务进行配置；在AndroidManifest.xml文件中配置12345&lt;service android:name=&quot;com.rustfisher.tom.TomService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.rustfisher.ndkproj.ITomInterface&quot; /&gt; &lt;/intent-filter&gt;&lt;/service&gt;action里面写上AIDL文件 安装运行此apk到手机上让服务方运行起来 AIDL调用方代码（客户端）建立（或进入）AIDL调用方的工程，这里是aidlcaller工程。 主要文件目录12345678java/`-- com |-- rust | `-- aidlcaller | `-- MainActivity.java // 演示用的 `-- rustfisher `-- ndkproj // 这个路径尽量保持与服务提供方那里的一致 `-- ITomInterface.java // 从服务方那里copy来的 有如下3个步骤： 1.将AIDL服务端生成的Java文件复制到调用方工程里，尽量保持这个Java文件的路径与服务端的一致，便于识别 2.写代码绑定服务，获取AIDL服务对象 3.通过AIDL服务对象完成AIDL接口调用 编写调用方MainActivity.java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.rustfisher.ndkproj.ITomInterface;public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;rustApp&quot;; ITomInterface mTomService; // AIDL 服务 TextView mTv1; private ServiceConnection serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mTomService = ITomInterface.Stub.asInterface(service);// 获取服务对象 mTv1.setClickable(true); // 需要等服务绑定好 再允许点击 Log.d(TAG, &quot;[aidlcaller] onServiceConnected&quot;); } @Override public void onServiceDisconnected(ComponentName name) { Log.d(TAG, &quot;onServiceDisconnected &quot; + name); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initAIDLService(); initUI(); } private void initUI() { mTv1 = (TextView) findViewById(R.id.tv1); mTv1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { try { String hello = mTomService.helloAIDL(&quot;Jerry&quot;); Log.d(TAG, hello); } catch (Exception e) { Log.e(TAG, &quot;mTomService initAIDLService: Fail &quot;, e); e.printStackTrace(); } } }); } private void initAIDLService() { // 这个是服务提供方的AndroidManifest action Intent intent = new Intent(&quot;com.rustfisher.ndkproj.ITomInterface&quot;); intent.setPackage(&quot;com.rustfisher.ndkproj&quot;); // 服务提供者的包名 bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE); }} 测试和效果点击调用端的View，打出log Hello Jerry, nice to meet you!服务端apk打印log：Jerry requires helloAIDL() 如果调用失败则抛出 android.os.DeadObjectException 当服务提供方App没有在运行时，调用方去请求服务会失败。 服务端更新后，如果aidl文件没改动，不需要更新生成的Java文件如果服务端apk被卸载，调用端使用此服务时会出错 参考资料Android Binder 机制介绍","link":"/2015/10/26/Android/Android-AIDL_intro_and_use/"},{"title":"Android NDK 使用.a","text":"Android NDK 使用.a一个编译时使用.a文件的例子。流程是准备好库文件以及对应的头文件，编写makefile，编译。 准备库文件与头文件先准备头文件和.a文件。这里以ncnn目录为例。 12345678|-- Android.mk|-- Application.mk|-- ncnn| |-- include| | |-- benchmark.h| | |-- ....h # 对应的头文件| |-- lib| | `-- libncnn.a 编写makefile在Android.mk中声明库文件。这里是引入opencv的库。 12345678910111213141516171819202122LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := ncnnLOCAL_SRC_FILES := ncnn/lib/libncnn.ainclude $(PREBUILT_STATIC_LIBRARY)LOCAL_STATIC_LIBRARIES := ncnnOPENCVROOT:=$(LOCAL_PATH)/../../../../../../OpenCV-android-sdkOPENCV_CAMERA_MODULES:=offOPENCV_INSTALL_MODULES:=on#OPENCV_LIB_TYPE:=SHAREDOPENCV_LIB_TYPE:=STATICinclude ${OPENCVROOT}/sdk/native/jni/OpenCV.mk# v20 with sseLOCAL_SRC_FILES := v20/fdssttracker.cpp v20/fhog.cpp v20/runtracker.cpp \\ jni_eman.cpp \\ ncnn/ssdmobilenet.cpp jni_encnn.cpp# 后面是模块的配置 这里要注意，头文件和.a文件必须是对应的。否则编译时会报错error: undefined reference to 1234567E:/projects/myProj/myProject/f1/src/main/jni/ncnn/lib/libncnn.a(net.cpp.o):net.cpp:function ncnn::Net::load_model(__STDIO_FILE_STRUCT*): error: undefined reference to 'stderr'E:/projects/myProj/myProject/f1/src/main/jni/ncnn/lib/libncnn.a(net.cpp.o):net.cpp:function ncnn::Net::load_model(char const*): `error: undefined reference to`'stderr'E:/projects/myProj/myProject/f1/src/main/jni/ncnn/lib/libncnn.a(net.cpp.o):net.cpp:function ncnn::Net::load_model(unsigned char const*): error: undefined reference to 'stderr'E:/projects/myProj/myProject/f1/src/main/jni/ncnn/lib/libncnn.a(net.cpp.o):net.cpp:function ncnn::Net::find_blob_index_by_name(char const*) const: error: undefined reference to 'stderr'clang++.exe: error: linker command failed with exit code 1 (use -v to see invocation)make: *** [E:/projects/myProj/myProject/f1/src/main/obj/local/armeabi-v7a/libf1.so] Error 1","link":"/2015/10/26/Android/NDK-compile_import_a_file/"}],"tags":[{"name":"Android-2020","slug":"Android-2020","link":"/tags/Android-2020/"},{"name":"AIDL","slug":"AIDL","link":"/tags/AIDL/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"Android_View","slug":"Android-View","link":"/tags/Android-View/"},{"name":"Android_Media","slug":"Android-Media","link":"/tags/Android-Media/"},{"name":"Binder","slug":"Binder","link":"/tags/Binder/"},{"name":"Android_Broadcast","slug":"Android-Broadcast","link":"/tags/Android-Broadcast/"},{"name":"Android源码","slug":"Android源码","link":"/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Handler","slug":"Handler","link":"/tags/Handler/"},{"name":"Android_service","slug":"Android-service","link":"/tags/Android-service/"},{"name":"Media","slug":"Media","link":"/tags/Media/"},{"name":"MediaPlayer","slug":"MediaPlayer","link":"/tags/MediaPlayer/"},{"name":"Network","slug":"Network","link":"/tags/Network/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"OkHttp","slug":"OkHttp","link":"/tags/OkHttp/"},{"name":"mmap","slug":"mmap","link":"/tags/mmap/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"NDK","slug":"NDK","link":"/tags/NDK/"},{"name":"Cocos Creator","slug":"Cocos-Creator","link":"/tags/Cocos-Creator/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"安装mysql","slug":"安装mysql","link":"/tags/%E5%AE%89%E8%A3%85mysql/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"开发记录","slug":"开发记录","link":"/tags/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"for","slug":"for","link":"/tags/for/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NestJS","slug":"NestJS","link":"/tags/NestJS/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"公众号","slug":"公众号","link":"/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"运营的Python指南","slug":"运营的Python指南","link":"/tags/%E8%BF%90%E8%90%A5%E7%9A%84Python%E6%8C%87%E5%8D%97/"},{"name":"openpyxl","slug":"openpyxl","link":"/tags/openpyxl/"},{"name":"Excel","slug":"Excel","link":"/tags/Excel/"},{"name":"pyecharts","slug":"pyecharts","link":"/tags/pyecharts/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"WebRTC","slug":"WebRTC","link":"/tags/WebRTC/"},{"name":"华为云社区","slug":"华为云社区","link":"/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91%E7%A4%BE%E5%8C%BA/"},{"name":"hexo主题","slug":"hexo主题","link":"/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"echarts","slug":"echarts","link":"/tags/echarts/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","link":"/tags/Matplotlib/"},{"name":"plt","slug":"plt","link":"/tags/plt/"},{"name":"plot","slug":"plot","link":"/tags/plot/"}],"categories":[{"name":"Android_tutorial_2020","slug":"Android-tutorial-2020","link":"/categories/Android-tutorial-2020/"},{"name":"Android_note","slug":"Android-note","link":"/categories/Android-note/"},{"name":"CocosCreator","slug":"CocosCreator","link":"/categories/CocosCreator/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Design_pattern","slug":"Design-pattern","link":"/categories/Design-pattern/"},{"name":"miniprogram","slug":"miniprogram","link":"/categories/miniprogram/"},{"name":"Web_note","slug":"Web-note","link":"/categories/Web-note/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"Flutter_note","slug":"Flutter-note","link":"/categories/Flutter-note/"},{"name":"Linux_note","slug":"Linux-note","link":"/categories/Linux-note/"},{"name":"MongoDB","slug":"MongoDB","link":"/categories/MongoDB/"},{"name":"NestJS","slug":"NestJS","link":"/categories/NestJS/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"PyQt","slug":"PyQt","link":"/categories/PyQt/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"WebRTC","slug":"WebRTC","link":"/categories/WebRTC/"},{"name":"unclassified","slug":"unclassified","link":"/categories/unclassified/"}],"pages":[{"title":"RustFisher","text":"软件工程师。从事Android App开发工作。主要开发语言是Java。也在学习Kotlin。会用Python写脚本，分析数据。熟悉Linux的一些操作。 最近在完善Android 2020。Android方面的内容，会放到 https://an.rustfisher.com 需要用什么，就去学什么。 联系 邮箱 rustfisher@foxmail.com Github https://github.com/RustFisher","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"","text":"Awesome-pyecharts var chart_2db4c0f0b55642b9a92be47416c6ea60 = echarts.init( document.getElementById('2db4c0f0b55642b9a92be47416c6ea60'), 'white', {renderer: 'canvas'}); var option_2db4c0f0b55642b9a92be47416c6ea60 = { \"animation\": true, \"animationThreshold\": 2000, \"animationDuration\": 1000, \"animationEasing\": \"cubicOut\", \"animationDelay\": 0, \"animationDurationUpdate\": 300, \"animationEasingUpdate\": \"cubicOut\", \"animationDelayUpdate\": 0, \"color\": [ \"#c23531\", \"#2f4554\", \"#61a0a8\", \"#d48265\", \"#749f83\", \"#ca8622\", \"#bda29a\", \"#6e7074\", \"#546570\", \"#c4ccd3\", \"#f05b72\", \"#ef5b9c\", \"#f47920\", \"#905a3d\", \"#fab27b\", \"#2a5caa\", \"#444693\", \"#726930\", \"#b2d235\", \"#6d8346\", \"#ac6767\", \"#1d953f\", \"#6950a1\", \"#918597\" ], \"series\": [ { \"type\": \"funnel\", \"name\": \"\\u6f0f\\u65971\", \"data\": [ { \"name\": \"e1\", \"value\": 10000 }, { \"name\": \"e2\", \"value\": 4695 }, { \"name\": \"e3\", \"value\": 2584 }, { \"name\": \"e4\", \"value\": 1295 }, { \"name\": \"e5\", \"value\": 954 }, { \"name\": \"e6\", \"value\": 452 } ], \"sort\": \"descending\", \"gap\": 0, \"label\": { \"show\": true, \"position\": \"top\", \"margin\": 8 } } ], \"legend\": [ { \"data\": [ \"e4\", \"e1\", \"e3\", \"e2\", \"e5\", \"e6\" ], \"selected\": { \"e1\": true, \"e2\": true, \"e3\": true, \"e4\": true, \"e5\": true, \"e6\": true }, \"show\": true, \"padding\": 5, \"itemGap\": 10, \"itemWidth\": 25, \"itemHeight\": 14 } ], \"tooltip\": { \"show\": true, \"trigger\": \"item\", \"triggerOn\": \"mousemove|click\", \"axisPointer\": { \"type\": \"line\" }, \"showContent\": true, \"alwaysShowContent\": false, \"showDelay\": 0, \"hideDelay\": 100, \"textStyle\": { \"fontSize\": 14 }, \"borderWidth\": 0, \"padding\": 5 }, \"title\": [ { \"text\": \"\\u6f0f\\u6597\\u56fe1\", \"subtext\": \"\\u9ed8\\u8ba4\\u6837\\u5f0f\", \"padding\": 5, \"itemGap\": 10 } ] }; chart_2db4c0f0b55642b9a92be47416c6ea60.setOption(option_2db4c0f0b55642b9a92be47416c6ea60);","link":"/art/py/op-funnel/funnel_chart_1.html"},{"title":"","text":"Awesome-pyecharts var chart_27de115518aa451f93c8773b843bc825 = echarts.init( document.getElementById('27de115518aa451f93c8773b843bc825'), 'white', {renderer: 'canvas'}); var option_27de115518aa451f93c8773b843bc825 = { \"animation\": true, \"animationThreshold\": 2000, \"animationDuration\": 1000, \"animationEasing\": \"cubicOut\", \"animationDelay\": 0, \"animationDurationUpdate\": 300, \"animationEasingUpdate\": \"cubicOut\", \"animationDelayUpdate\": 0, \"color\": [ \"#c23531\", \"#2f4554\", \"#61a0a8\", \"#d48265\", \"#749f83\", \"#ca8622\", \"#bda29a\", \"#6e7074\", \"#546570\", \"#c4ccd3\", \"#f05b72\", \"#ef5b9c\", \"#f47920\", \"#905a3d\", \"#fab27b\", \"#2a5caa\", \"#444693\", \"#726930\", \"#b2d235\", \"#6d8346\", \"#ac6767\", \"#1d953f\", \"#6950a1\", \"#918597\" ], \"series\": [ { \"type\": \"funnel\", \"name\": \"\\u6f0f\\u65971\", \"data\": [ { \"name\": \"e1\", \"value\": 10000 }, { \"name\": \"e2\", \"value\": 4695 }, { \"name\": \"e3\", \"value\": 2584 }, { \"name\": \"e4\", \"value\": 1295 }, { \"name\": \"e5\", \"value\": 954 }, { \"name\": \"e6\", \"value\": 452 } ], \"sort\": \"descending\", \"gap\": 2, \"label\": { \"show\": true, \"position\": \"inside\", \"margin\": 8, \"formatter\": \"{b} \\u6570\\u91cf: {c}\" }, \"tooltip\": { \"show\": true, \"trigger\": \"item\", \"triggerOn\": \"mousemove|click\", \"axisPointer\": { \"type\": \"line\" }, \"showContent\": true, \"alwaysShowContent\": false, \"showDelay\": 0, \"hideDelay\": 100, \"formatter\": \"{a} {b} \\u6570\\u91cf: {c}\", \"textStyle\": { \"fontSize\": 14 }, \"borderWidth\": 0, \"padding\": 5 } } ], \"legend\": [ { \"data\": [ \"e4\", \"e1\", \"e3\", \"e2\", \"e5\", \"e6\" ], \"selected\": { \"e1\": true, \"e2\": true, \"e3\": true, \"e4\": true, \"e5\": true, \"e6\": true }, \"show\": true, \"padding\": 5, \"itemGap\": 10, \"itemWidth\": 25, \"itemHeight\": 14 } ], \"tooltip\": { \"show\": true, \"trigger\": \"item\", \"triggerOn\": \"mousemove|click\", \"axisPointer\": { \"type\": \"line\" }, \"showContent\": true, \"alwaysShowContent\": false, \"showDelay\": 0, \"hideDelay\": 100, \"textStyle\": { \"fontSize\": 14 }, \"borderWidth\": 0, \"padding\": 5 }, \"title\": [ { \"text\": \"\\u6f0f\\u6597\\u56fe1\", \"subtext\": \"\\u6539\\u53d8\\u4e86label\", \"padding\": 5, \"itemGap\": 10 } ] }; chart_27de115518aa451f93c8773b843bc825.setOption(option_27de115518aa451f93c8773b843bc825);","link":"/art/py/op-funnel/funnel_chart_2.html"},{"title":"","text":"Awesome-pyecharts var chart_ec8d0b5a5e6e476db93b96c76a92d53f = echarts.init( document.getElementById('ec8d0b5a5e6e476db93b96c76a92d53f'), 'white', {renderer: 'canvas'}); var option_ec8d0b5a5e6e476db93b96c76a92d53f = { \"animation\": true, \"animationThreshold\": 2000, \"animationDuration\": 1000, \"animationEasing\": \"cubicOut\", \"animationDelay\": 0, \"animationDurationUpdate\": 300, \"animationEasingUpdate\": \"cubicOut\", \"animationDelayUpdate\": 0, \"color\": [ \"#c23531\", \"#2f4554\", \"#61a0a8\", \"#d48265\", \"#749f83\", \"#ca8622\", \"#bda29a\", \"#6e7074\", \"#546570\", \"#c4ccd3\", \"#f05b72\", \"#ef5b9c\", \"#f47920\", \"#905a3d\", \"#fab27b\", \"#2a5caa\", \"#444693\", \"#726930\", \"#b2d235\", \"#6d8346\", \"#ac6767\", \"#1d953f\", \"#6950a1\", \"#918597\" ], \"series\": [ { \"type\": \"funnel\", \"name\": \"\\u6f0f\\u65971\", \"data\": [ { \"name\": \"e1\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 100.00%\", \"value\": 10000 }, { \"name\": \"e2\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 46.95%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 46.95%\", \"value\": 4695 }, { \"name\": \"e3\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 25.84%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 55.04%\", \"value\": 2584 }, { \"name\": \"e4\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 12.95%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 50.12%\", \"value\": 1295 }, { \"name\": \"e5\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 9.54%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 73.67%\", \"value\": 954 }, { \"name\": \"e6\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 4.52%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 47.38%\", \"value\": 452 } ], \"sort\": \"descending\", \"gap\": 2, \"label\": { \"show\": true, \"position\": \"inside\", \"margin\": 8, \"formatter\": \"{b}\\n\\u6570\\u91cf: {c}\" }, \"tooltip\": { \"show\": true, \"trigger\": \"item\", \"triggerOn\": \"mousemove|click\", \"axisPointer\": { \"type\": \"line\" }, \"showContent\": true, \"alwaysShowContent\": false, \"showDelay\": 0, \"hideDelay\": 100, \"formatter\": \"{a} {b} \\u6570\\u91cf: {c}\", \"textStyle\": { \"fontSize\": 14 }, \"borderWidth\": 0, \"padding\": 5 } } ], \"legend\": [ { \"data\": [ \"e2\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 46.95%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 46.95%\", \"e1\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 100.00%\", \"e3\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 25.84%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 55.04%\", \"e5\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 9.54%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 73.67%\", \"e4\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 12.95%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 50.12%\", \"e6\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 4.52%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 47.38%\" ], \"selected\": { \"e1\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 100.00%\": true, \"e2\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 46.95%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 46.95%\": true, \"e3\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 25.84%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 55.04%\": true, \"e4\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 12.95%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 50.12%\": true, \"e5\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 9.54%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 73.67%\": true, \"e6\\n\\u603b\\u4f53\\u8f6c\\u5316\\u7387: 4.52%\\n\\u76f8\\u5bf9\\u8f6c\\u5316\\u7387: 47.38%\": true }, \"show\": true, \"padding\": 5, \"itemGap\": 10, \"itemWidth\": 25, \"itemHeight\": 14 } ], \"tooltip\": { \"show\": true, \"trigger\": \"item\", \"triggerOn\": \"mousemove|click\", \"axisPointer\": { \"type\": \"line\" }, \"showContent\": true, \"alwaysShowContent\": false, \"showDelay\": 0, \"hideDelay\": 100, \"textStyle\": { \"fontSize\": 14 }, \"borderWidth\": 0, \"padding\": 5 }, \"title\": [ { \"text\": \"\\u6f0f\\u6597\\u56fe1\", \"subtext\": \"\\u4fee\\u6539\\u4e86\\u5404\\u9879\\u7684\\u6807\\u9898\", \"padding\": 5, \"itemGap\": 10 } ] }; chart_ec8d0b5a5e6e476db93b96c76a92d53f.setOption(option_ec8d0b5a5e6e476db93b96c76a92d53f);","link":"/art/py/op-funnel/funnel_chart_3.html"}]}