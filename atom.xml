<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RustFisher的自留地</title>
  
  <subtitle>Android App, Java, Python</subtitle>
  <link href="https://blog.rustfisher.com/atom.xml" rel="self"/>
  
  <link href="https://blog.rustfisher.com/"/>
  <updated>2024-01-12T01:13:22.481Z</updated>
  <id>https://blog.rustfisher.com/</id>
  
  <author>
    <name>Rust Fisher</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日寄（2024-01-11，Anlin，知乎）</title>
    <link href="https://blog.rustfisher.com/2024/01/11/fun/zt-zhihu-riji/riji-3024-1-11/"/>
    <id>https://blog.rustfisher.com/2024/01/11/fun/zt-zhihu-riji/riji-3024-1-11/</id>
    <published>2024-01-11T15:47:59.000Z</published>
    <updated>2024-01-12T01:13:22.481Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-quote">            <p>作者：Anlin<br>链接：<a href="https://zhuanlan.zhihu.com/p/677326021">https://zhuanlan.zhihu.com/p/677326021</a><br>来源：知乎</p>          </div><p>被裁了。</p><p>接到通知书的那一刻，没有想象中的激动和喜悦，更多的，还是一种水到渠成之后，如释重负的平静，一直以来的拼搏和汗水，在这一刻终于开花结果，星光不负赶路人，时光不负有心人，但行好事，莫问前程，一切都有最好的安排。</p><p>前面这段是两年前准备的考研上岸文案，一直没机会发来着。</p><p>早上被闹钟吵醒，又工作日，这鬼日子什么时候是个头，朋友发消息问我被裁了没，我说不道啊，没听说啊，借你吉言吧，真借到了，到公司就被叫进了会议室，投影开着视频会议，领导们一些在墙上，一些在桌子上，很正式。</p><p>鬼日子这就到头了，这一定就是念念不忘必有回响，问朋友怎么知道裁员消息的，他说这几天好几个技术交流群，很邪门，居然开始聊技术了。</p><p>有个很经典的问题“如果唐僧的取经团队要裁掉一个人，应该裁谁“，小时候总是和朋友吵得不可开交，现在懂了，发个招聘启事，朝廷项目，一把手重点关注，填补国内空白领域，500年资深技术员牵头，团队内有师徒机制，结项全员给大唐天庭双编制，以拿不动金箍棒无法胜任工作为由开掉，哪有指标下来直接砍骨干的。</p><p>以为会失眠，毕竟吃了大半年褪黑素，没想到睡了半年来最安稳的一觉。</p><p>原来人并不会像玻璃一样“bulingbuling”脆脆地碎掉，它更类似于锈蚀、腐烂、低温烫伤，温和地、毫无痛楚地，越来越麻木，越来越迟钝，直到某一天，再也说不出“我到了一百岁还可爱”这种话。</p><p>不知道怎么回事关注了个40多的阿姨，每天点开就看到她发读书笔记人生感悟，没什么共同话题，她平常看《鬼谷子的心理学》《王阳明的人生哲理》，我比较爱看斗破苍穹之什么什么的，她打算下个周天出门，因为天气预报说是晴天，她在要不要涂口红这件事上纠结了一个星期，她说这管口红买来还没涂过，最后一天晚上，她很正式地决定要涂口红，给自己打气，句子后面全是感叹号。</p><p>所有人都会老的，“春风若有怜花意，可否许我再少年“这样的诗句，只有少年念出来才意气风发。</p><p>晚上不用加班，虽然不知道心里到底什么感觉，但打算先吃顿烧烤，这玩意好，开心不开心都适合吃，楼下有家烧烤店，好吃，但很脏，在日本能拍好几集纪录片的那种，有天白天路过，看到在大扫除，黑黄黑黄一层一层往下冲，看着特舒服，当天晚上立马点了一大把回家，没内味了。</p><p>看评论有大哥说我一定在知乎赚了很多钱吧，我寻思有道理啊，激动地混身颤抖，心想难道不知不觉间我已经财富自由了？</p><p>啊没事了，要手动开的，15.15是回了一个值乎来的，当时看收到的问题没什么资格回答，纯打赏拿着受之有愧，索性关了就。</p><p>后来才知道17块太贵了，还好也没收多少。</p><p>虽说知识付费的精髓就在于，不买超过经济能力的课就觉得没用，但还是算了。</p><p>翻了翻之前的日寄，真羡慕，想不明白怎么写出来的，我妈说，你试试能不能养活自己吧，能的话随你，于是我开始按能养活自己的标准打工，才发现，为生活奔波的时候，没精力和大爷聊天，也没心情抬头看朝霞日落，连电梯上升的加速度都压得人腿软。</p>]]></content>
    
    
    <summary type="html">作者：Anlin发布于2024年01月11日</summary>
    
    
    
    <category term="职业发展" scheme="https://blog.rustfisher.com/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
    
    <category term="职业发展" scheme="https://blog.rustfisher.com/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>思考 | 公司活力（芦半山，稀土掘金）</title>
    <link href="https://blog.rustfisher.com/2024/01/03/Career/zt-juejin-company-dynamism/"/>
    <id>https://blog.rustfisher.com/2024/01/03/Career/zt-juejin-company-dynamism/</id>
    <published>2024-01-03T02:52:59.000Z</published>
    <updated>2024-01-03T02:55:01.428Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-quote">            <p>作者：芦半山<br>链接：<a href="https://juejin.cn/post/7239617977364168763">https://juejin.cn/post/7239617977364168763</a><br>来源：稀土掘金</p>          </div><p>经常看到一些互联网公司，尤其是创业公司，宣传自己的年轻员工占比高，公司充满活力。久而久之，大家都开始习惯这套说辞，认为一家公司有没有活力的标志就是年轻人多不多。可是当我们说一家公司充满活力时，到底在说什么？</p><p>我们是在说这家公司员工的体力充沛么？肯定不是，毕竟我们不用比拼打螺丝的速度，也不用比拼抡大锤的力度。再说，抡大锤，小年轻们不一定比得过中年大叔呢。</p><p>我们是在说这家公司员工满面红光、笑容可掬么？那也不是，毕竟要论这两项，高速收费口的工作人员早把各位杀的片甲不留。</p><p>我们是在说这家公司盈利颇丰么？那更不是，毕竟谁也不会把中烟草和活力二字扯上关系。可是若论赚钱能力，互联网的各位在中烟草面前都是弟弟。</p><p>那我们到底在说什么？</p><p>想必各位都看到今年上半年AI圈的迅猛增势，这些公司中有创业公司，譬如OpenAI和Midjourney，也有巨头公司，譬如Nvidia和Google。它们都可以称得上充满活力，原因并非它们拥有年轻的员工，而是它们一直做着创新突破的工作，是真正把大家带入更好未来的公司。</p><p>所以当我们说一家公司充满活力时，并不是想说它的员工充满活力，而是它的产品、它的创新工作充满活力。</p><p>事实上，Nvidia和Google这类公司中，大龄工程师并不少，而且多数都是研发的主力。举个例子，在我接触过的Google工程师中(Runtime和ART团队居多)，多数都拥有10年以上的工作经历。那这是否说明大龄工程师更具优势？难道国内的35岁理论要失效了？</p><p>问题的关键其实不在于工程师的年纪，而是工程师是否优秀。一个优秀的工程师25岁时表现优秀，等到50岁时就会变得卓越。而一个平庸的工程师，不论25岁还是50岁，都不会有多少突破性的工作。这就好比，不是老人坏了，而是坏人老了。你非要拿着年龄去衡量工程师的水平，多半会徒劳无功。</p><p>那这么说，年龄不是标准？其实年龄也是标准。因为优秀的工程师终归是少数，刚工作的时候泥沙俱下，分不清好坏。工作愈久，大浪淘沙的效应就愈明显。最终，那些少数优秀的大龄工程师都身居了要位，而剩下的那些，则频繁地活跃在求职市场。</p><p>国内职场令人吊诡的一点是，优秀的人才最终都走向了管理的位置，或者说，如果你走不到管理的位置，就不会被认定为优秀。这在技术领域其实是有严重问题的。专业人才得不到足够的重视和认可，站在背后指手画脚的人却被捧上了天，搞得大家都去研究PPT，学习向上管理，却忽略了创新不同于打仗，它主要来自于直接的实践，而非稳坐后方的指挥。</p><p>不过现实的残酷在于，创新只属于一小撮人。大多数的工作谈不上创新，只是时间和精力的耗散。不然为什么会有“人力资源”这个词？当把创新或者人的主观能动性从工作中剥离后，人便是资源，和矿产无异，而管理者的高贵就体现在如何支配这些资源。</p><p>我希望有一天，50岁的人也可以写代码，写出很漂亮的代码。毕竟，我们都有50岁的一天。  </p>]]></content>
    
    
    <summary type="html">经常看到一些互联网公司，尤其是创业公司，宣传自己的年轻员工占比高，公司充满活力。久而久之，大家都开始习惯这套说辞，认为一家公司有没有活力的标志就是年轻人多不多。可是当我们说一家公司充满活力时，到底在说什么？我们是在说这家公司员工的体力充沛么？肯定不是，毕竟我们不用比拼打螺丝的速度，也不用比拼抡大锤的力度。再说，抡大锤，小年轻们不一定比得过中年大叔呢。</summary>
    
    
    
    <category term="职业发展" scheme="https://blog.rustfisher.com/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
    
    <category term="职业发展" scheme="https://blog.rustfisher.com/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>技术并不一定比其他高级（通往自由之路，稀土掘金）</title>
    <link href="https://blog.rustfisher.com/2023/11/24/Career/zt-juejin-tech-is-not-so-high-level/"/>
    <id>https://blog.rustfisher.com/2023/11/24/Career/zt-juejin-tech-is-not-so-high-level/</id>
    <published>2023-11-24T15:12:59.000Z</published>
    <updated>2024-01-03T02:53:47.843Z</updated>
    
    <content type="html"><![CDATA[<div class="note note-quote">            <p>作者：通往自由之路<br>链接：<a href="https://juejin.cn/post/7304598711991795750">https://juejin.cn/post/7304598711991795750</a><br>来源：稀土掘金</p>          </div><p>这里的技术可以是计算机或者别的什么技术。当然首先指的是开发技术。</p><p>很长一段时间里，就我个人有一种天然的技术高于其他的感觉，虽未明示，但骨子里有一种谦虚的傲慢。认为开发高于产品、设计、测试等。</p><p>不知道其他人是否有过这种想法。或者我觉得那种典型的技术人的思维，要么思维不够开放，要么就是一种谦虚的傲慢。</p><p>这种傲慢最可怕的是因为漠视掉其它的价值，导致技术人的格局不够。格局不够会看不到更大世界的运行规律，导致无法做出更加正确的决策。有一副著名的对联</p><p>能攻心则反侧自消,自古知兵非好战</p><p>不审势即宽严皆误,后来治蜀要深思</p><p>我觉得这是对格局不够后果最直接准确的描述：宽严皆误。说下我是怎么想到技术并不一定比其他高级的？</p><p>前几天群里同组的同学@我让我改一篇文章，我才知道公司开始举办一年一度的一年一词活动，开始面向全体征稿。第一年的时候我参与了，但没有选中。第二年没有参与。</p><p>我看了下同组同学那篇文章，觉得不怎么滴啊，也是这激起我的求胜心，决定自己写一篇，今年再参加一次。于是那天下午我就写完了初稿。初稿的题目是造轮子，第一句</p><blockquote><p>一般来说说造轮子的都是程序员，因为开发从某个意义上来讲就是在重复造轮子，亦如太阳底下没有新鲜事，也亦如任何历史都是当代史。</p></blockquote><p>为了能够被选上，我认真又做了几次修改，重读了几次。我有点福至心灵的发现我在开发上犯了一个错误，就是我似乎一直认为技术才是最重要的，不管是有意无意的，这是事实。但是开发从某个意义上来讲就是在重复造轮子，正如太阳底下没有新鲜事，也亦如任何历史都是当代史，技术和其他一样，也是重复的单元。</p><p>要想尽快搞清楚技术，只要找到其中代表性的重复单元就可以了。而实际也早就有人总结了这些单元，比如功能单元的代表各种ui组件库，业务单元的代表往往是对功能单元的再加工。好比功能单元是原型机，而业务单元是定制化。</p><p>前几天也看到一篇文章的题目《不过是享受了互联网的十年红利期而已》。遂想到行业高速发展时期，技术实现是第一位的；但行业进入饱和期，产品、运营应该才是创造利润的关键。正如计算机底层技术开发人员，过了计算机技术爆发的年代，反倒不如业务开发赚的多。</p><p>这一切的一切不过是特定时期的表现。技术并不一定比其他高级，现在就是技术不再处于第一优先级的时刻。</p>]]></content>
    
    
    <summary type="html">很长一段时间里，就我个人有一种天然的技术高于其他的感觉，虽未明示，但骨子里有一种谦虚的傲慢。认为开发高于产品、设计、测试等。不知道其他人是否有过这种想法。或者我觉得那种典型的技术人的思维，要么思维不够开放，要么就是一种谦虚的傲慢。</summary>
    
    
    
    <category term="职业发展" scheme="https://blog.rustfisher.com/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
    
    <category term="职业发展" scheme="https://blog.rustfisher.com/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>《纳瓦尔宝典》读书笔记</title>
    <link href="https://blog.rustfisher.com/2023/06/01/reading/SocialScience/The-Almanack-of-Naval-Ravikant-note/"/>
    <id>https://blog.rustfisher.com/2023/06/01/reading/SocialScience/The-Almanack-of-Naval-Ravikant-note/</id>
    <published>2023-06-01T06:07:59.000Z</published>
    <updated>2023-06-08T06:13:41.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><image src="cover-Naval.jpg" style="height:260px"><div class="note note-info">            <p>《纳瓦尔宝典》</p><p>作者：埃里克·乔根森</p><p>这本书是对纳瓦尔的介绍，包含了他探索最深入的两个主题：财富和幸福。</p>          </div><h2 id="摘抄与笔记"><a href="#摘抄与笔记" class="headerlink" title="摘抄与笔记"></a>摘抄与笔记</h2><h3 id="第一章-积累财富"><a href="#第一章-积累财富" class="headerlink" title="第一章 积累财富"></a>第一章 积累财富</h3><p>赚钱跟工作的努力程度没什么必然联系。</p><p>如果还不知道自己应该做什么，那么你先要弄清楚这个问题。在这之前，不要盲目发力。</p><p>追求财富，而不是金钱或地位。财富是指在你睡觉时仍能为你赚钱的资产。金钱是我们转换时间和财富的方式。地位是你在社会等级体系中所处的位置。</p><p>获得财富的一个途径，就是为社会提供其有需求但无从获得的东西，并实现规模化。</p><p>选择一个有长期发展前景的行业，找到可以长期合作的人。</p><p>选择聪明过人、精力充沛的商业伙伴，但更重要的是，他们要正直诚信。</p><p>不要跟愤世嫉俗和消极悲观的人合作。他们的预言会自我实现。</p><p>学会销售，学会构建，两技傍身，势不可当。</p><p>专长指的是无法通过培训获得的知识。如果社会可以培训你，那么社会也可以培训他人来取代你。</p><p>要想有所专长，就要追求真正的兴趣和热爱，而不是盲目追逐热点。</p><p>累积专长的过程，对你而言就像玩耍，对他人来说则很吃力。</p><p>专长往往具有高度的技术性或创造性，不能被外包或自动化。</p><p>培养责任感，勇于以个人名义承担商业风险。社会将根据责任大小、股权多少和杠杆效应回报你。</p><p>要想获得财富，就必须充分利用杠杆效应。商业杠杆来自资本、劳动力和复制边际成本为零的产品（代码和媒体）。</p><p>劳动力杠杆就是让别人为你工作。这是最古老、争夺最激烈的一种杠杆。拥有劳动力杠杆会让你的父母觉得你很了不起，但不要过度追逐劳动力杠杆。</p><p>代码和媒体是不需要许可就能使用的杠杆。这两个杠杆是新富阶层背后的杠杆。你可以创建软件和媒体，让它们在你睡觉时为你工作。</p><p>如果不会写代码，那就出书、写博客、做视频、录播客。</p><blockquote><p>即 自媒体（仅供参考）</p></blockquote><p>学习微观经济学、博弈论、心理学、说服术、伦理学、数学和计算机。</p><p>读比听快，做比看快。</p><p>设定一个大胆的个人时薪，并严格执行。如果解决一个问题节省的成本低于时薪，那就忽略问题；如果外包一项任务的成本低于时薪，那就选择外包。</p><p>工作时要拼尽全力，毫无保留。不过，共事的人和工作的内容比努力程度更重要。</p><p>世界上没有快速致富的教程。即使有，那也只是提供教程的人想从你身上赚钱。</p><p>运用专长，发挥杠杆效应，最终你会得到自己应得的。</p><p>总结：把自己产品化。</p><blockquote><p>个人ip？打造自己的产品？<br>或者做出自己的产品，让产品持续为你赚钱。</p></blockquote><p>“自己”具有独特性，“产品化”是发挥杠杆效应；“自己”具有责任感，“产品化”需要专长。“自己”其实也具有专长。因此，这两个重点就可以概括上述所有的理念。</p><p>如果想要实现致富的长期目标，你就应该问问自己：“这是我真正想要的东西吗？我的规划目标是我真正想要的吗？”得到肯定的答案后，再问问自己：“我实现产品化了吗？我实现规模化了吗？我选择规模化的方式是劳动力、资本，还是代码或媒体？”</p><p>我能提供什么独特的价值？</p><p>金钱是我们转移财富的方式。金钱是社会的信用符号，具有调用别人时间的能力。</p><blockquote><p>金钱是权力的一种</p></blockquote><p>所以，我对财富的定义是在睡觉时也能带来收入的企业和资产</p><p>销售技能是一种专长。</p><p>专长无法被教授，但可以被学习。</p><p>关于个人天赋和专长，举例如下：· 销售技巧。· 音乐天赋：学习任何乐器都不费力。· 专注力强：容易沉浸在一个事物中，并很快记住相关知识点。· 热爱科幻：喜欢读科幻小说，吸收新知识的能力特别强。· 擅长游戏：对博弈论了解得透彻深刻。· 喜欢八卦：深入挖掘朋友的社交网络，将来可能成为有所建树的记者。</p><p>社会、商业和金钱是技术的下游产物，而技术本身又是科学的下游产物。应用科学是推动人类社会发展的引擎。由此得出的推论是，应用科学家是世界上最有权威的人。这一点在未来几年会更加突出。</p><p>只要在网上进行独特的自我表达，你就有机会传播快乐，累积财富，打造产品，创立企业。</p><p>致富最重要的技能是成为终身学习者，无论想学什么，你都得找到途径和方法。</p><p>如今，在9到12个月内成为一个全新领域的专家比在很久以前选择了“正确的”专业要重要得多。只有掌握好基础知识，才能不忌惮任何书籍。如果在图书馆读到一本自己无法理解的书，那么你先要了解读懂这本书需要哪些基础知识，打好基础后再深入研究。基础是极为重要的。</p><p>投资交友，着眼长远</p><p>出发点并不重要，行为本身才重要。因此，遵守道德标准并非易事。</p><blockquote><p>论迹不论心</p></blockquote><p>99%的努力终将白费。</p><blockquote><p>即使白费，也还是要投入</p></blockquote><p>显然，没有一种努力是完全白费的，因为我们总能在努力的过程中学到一些东西。任何经历都可以成为学习的机会。举例来说，回顾求学生涯，当时写的论文、读的书、做的练习，99%不适用于现实社会。学到的一些地理和历史知识你从未派上用场，学的一门外语你早已不再使用，一些数学知识你也早已全然忘记。</p><p>努力找到不会被浪费的1%。这1%对你是有意义的，值得你用余生去追求。一旦找到，你就要心无旁骛，全力以赴。</p><p>勇于以个人名义承担商业风险。社会将根据责任、股权和杠杆效应回报你。</p><p>要努力工作，直到有能力拥有企业股权。你可以买入企业的股票，成为小股东，也可以创办一家属于自己的企业。总而言之，要想方设法拥有企业的所有权，这一点真的非常重要。</p><p>如果一件事物一开始让你兴致盎然，后来又让你觉得索然无味，那么它只是暂时分散了你的注意力，并不是你心智上真正的好奇所在。请继续寻找。</p><p>无论做什么事情，我都以事情本身为目标。这也是艺术创作的一个鲜明特征。无论是创业、健身还是恋爱、交友，我始终都认为生命的意义在于专注于事情本身，体验过程，享受当下。神奇的是，当专注于事情本身时，你反而能做得更好。即使是赚钱，你也能成为赚得最多的那个。</p><blockquote><p>就当做是真的吧</p></blockquote><p>对一件事情的欲望越小，顾虑就越少，执念就越少，反而越会顺其自然，遵循内心。你会以自己擅长的方式，始终不渝地做下去，工作质量也会因此提高。</p><p>第一种是劳动力杠杆，也就是让别人给你打工。</p><p>资本是第二种相对较好的杠杆形式。资本杠杆就是用钱来扩大决策的影响力。</p><p>最后一种杠杆是最新出现的，也是普通人最触手可及的。这种杠杆就是“复制边际成本为零的产品”。</p><p>靠出租自己的时间是永远无法致富的。</p><p>无论处于人生的哪个阶段，努力的目标都是不断提高自己的独立性，而不是升职加薪。拥有独立性，为自己独特的产出成果负责（而不是像打工一样为投入的时间负责），这才是最理想的状态</p><p>想加入一家伟大的科技公司，销售技能和构建技能必备其一。如果二者都不具备，那就去学习。</p><p>我认为每个人都应该立志掌握某些领域的专业知识，并以此赚取经济回报。</p><p>给自己的时间设定价格，用时薪计算时间价值。如果用花钱的方式节省的时间价值更高，那就花钱，不要犹豫。要想真的赚到钱，先要相信你自己很值钱。</p><p>这世上的游戏不外乎两种。第一种是金钱游戏。金钱不能解决所有问题，但可以解决所有和金钱有关的问题。大家都明白这一点，所以每个人都想赚钱。但与此同时，许多人内心深处觉得自己是赚不到钱的，所以，他们不喜欢看到创造财富的故事。他们会攻击整个商业体系，宣称“赚钱是邪恶的，不应该赚钱”。但其实他们在玩第二种游戏，这种游戏叫地位游戏。他们之所以说“我不需要钱，我不想要钱”，是因为他们想占领高地，让别人高看一眼。地位就是一个人在社会等级中的位置。</p><p>地位游戏会一直存在，这是无法回避的。当你努力创造财富时，你可能会受到别人的攻击。这时，你需要意识到，大多数时候，他们是在试图牺牲你以提高自己的地位。他们玩的是另一个游戏，是一个不可取的游戏，因为它是一个零和游戏，而不是一个正和游戏。</p><p>人生早期有三个重大决定：在哪里生活，和谁在一起，从事什么职业。</p><p>找到自己擅长的领域，然后用自己的技能去帮助他人：提供免费的产品或服务，主动向世界传递善意。</p><p>赚钱的目的是解决财务问题，满足物质需求。我认为，摆脱金钱贪念最好的办法就是，赚了钱之后不要升级自己的生活方式。赚到钱的人往往会自然而然地提高生活水准。假设你一次性赚到一大笔钱，而不是靠日积月累。此时你依然保持着原有的生活方式，还没来得及升级，你的金钱就会远远超出你的实际需求和欲望，这反而让你达到一种财务自由的状态。</p><p>我把自由看得高于一切。我说的自由是多种多样的：想做什么就做什么的自由，不想做什么就不去做的自由，不受自我情绪或外界影响的自由，等等。自由是我最珍视的价值。</p><p>获得好运的方法：</p><ul><li>希望好运不期而至。</li><li>不停地折腾，直到撞上大运。</li><li>做好心理准备，对别人错过的机会保持敏感。</li><li>把你所做的事情做到极致。精益求精，直到名副其实。让机会自动找到你，让运气成为必然。</li></ul><p>“在一个长线游戏中，似乎每个人都在让彼此变得富有。而在一个短线游戏中，似乎每个人都在让自己变得富有。”</p><p>我认为商业社交纯属浪费时间。</p><p>“做一个创造者，创造出人们想要的有趣的东西。展示你的技能，练习你的技能，最终会有合适的人找到你。”</p><p>如果一个人大谈特谈自己有多诚实，那么他很可能是不诚实的。这只是我学到的一个小小的警示信号。当一个人不断宣扬自己的价值观，或者自我吹嘘时，那就意味着他在掩饰什么。</p><p>成功需要时间。即使万事俱备——你已经把成功所需的各个要素收入囊中，需要投入的时间也具有不确定性。而如果一直在掐算时间，在成功真正到来之前，你的耐心就会被消磨殆尽。</p><p>“但行好事，莫问前程”不容易，不仅不容易，而且难于上青天。“只求付出，不求回报”是人生中最难做到的一件事，但也是让人收获最大的一件事。</p><p>人生真正的履历，其实就是一生所承受痛苦的集合。</p><p>在物质世界里，金钱不能给人带来快乐，不能解决人的健康问题，不能让所有家庭变得美满和睦，不能让人免受情绪波动的困扰。但金钱可以买到自由，可以解决许多外在的问题。所以，赚钱是一个合情合理的奋斗目标。</p><h3 id="第二章-增强判断力"><a href="#第二章-增强判断力" class="headerlink" title="第二章 增强判断力"></a>第二章 增强判断力</h3><p>我对智慧的定义是“知道个人行为的长期后果”，用于解决外部问题的智慧其实就是判断力。</p><p>时间的投入是必需的，但判断力更重要。在前进的过程中，方向比速度更重要，特别是运用了杠杆以后。</p><p>要直面现实，就要放下自我，消除自我意识，忘记自我判断，平复自我情绪。</p><p>阻碍我们看清现实的最大因素就是我们对现实“应有的样子”有先入为主的印象。<br>痛苦时刻的一个定义是：当你看到事物的真面目不是你本来想要的样子时，你是痛苦的。</p><p>深知，越是渴望以某种特定的方式解决问题，我就越不可能看清事实</p><p>感受跟事实是两码事。感受只是自我对事实的部分估计。</p><p>悠闲的大脑才能产生伟大的创意</p><p>究其根本，人类的所有发明和成就都是为了解决交配权的分配问题。<br>人生的很多问题都可以从进化论、热力学、信息论和复杂性理论中找到解释和预测。</p><p>一条简单的人生经验：如果在一个艰难的决定上意见不统一，你就应该选择短期内更痛苦的道路。</p><p>每天花一个小时阅读科学、数学和哲学类书籍，7年内，你就可能跻身少数的成功人士之列。</p><p>不要比谁读书更快。书越好，你越要慢慢阅读、慢慢吸收。</p><h3 id="第三章-学习幸福"><a href="#第三章-学习幸福" class="headerlink" title="第三章 学习幸福"></a>第三章 学习幸福</h3><p>对我来说，幸福的含义主要是没有痛苦，没有欲望，不沉溺于对未来或过去的思考，真正拥抱当下，拥抱现状，拥抱现实的一切</p><p>事情总是一件压着一件，处理完这件，下一件会接踵而至，永远有做不完的事，所以焦虑感才会普遍存在。</p><p>工作时，和比自己更成功的人在一起。玩耍时，和比自己更快乐的人在一起。</p><p>如果不想跟一个人共事一生，那就一天都不要和他共事。</p><p>爱生活，无暇理会不快乐的人</p><h3 id="第四章-自我救赎"><a href="#第四章-自我救赎" class="headerlink" title="第四章 自我救赎"></a>第四章 自我救赎</h3><p>我生活中的第一要务是我的身体健康。对我来说，健康的重要性高于幸福，高于家庭，高于工作。我的身体健康是一切的起点，排在第一位，紧随其后的是我的心理健康和精神健康。接着是家人的健康和幸福。在确保了这些之后，我就可以按照自己的意志在这个世界上自由活动了。</p><p>最了不起的超能力就是改变自我的能力</p><p>我犯过很多错。面对错误，我都用同样的方式进行反思和总结。这些错误都是那个年龄段难以避免的，当时并不能觉察，只有事后才会显现出来。为了走出错误的阴影，我扪心自问：“当30岁时，你会给20岁的自己什么建议？当40岁时，你会给30岁的自己什么建议？”（如果年纪更小，你可以每5年为一个时间段这样问自己。）坐下来认真思考自己过去每一年的经历和感受：“2007年，我在做什么，我感觉怎么样？2008年，我在做什么，我感觉怎么样？2009年，我在做什么，我感觉怎么样？”</p><p>如果真的想做一件事，有一个方法就是广而告之，让身边的人都知道。比如，你想戒烟，你可以对你认识的每一个人说：“我戒烟了，我做到了。我向你保证。”</p><blockquote><p>自我实现。或者对别人说“我不抽烟”</p></blockquote><p>有想法就直接采取行动，就是这么简单。但大多数人都会说自己还没准备好，所以也就不会对朋友广而告之了。</p><p>如果有什么事情是你以后想做的，现在就去做，人生没有“以后”。</p><p>第一条原则是阅读，广泛地阅读。阅读面要广，不要局限于社会认可的书，更不要局限于我推荐的书。要为了阅读而阅读，培养对阅读的热爱。即使喜欢读言情小说、侦探书或漫画书也没关系，不存在所谓的垃圾。开卷有益，尽管读吧。假以时日，你会找到那些你应该读和喜欢读的东西。第二条原则是，掌握与阅读技巧相关的数学和说服技能。这两种技能有助于你在现实世界里活得游刃有余、畅行无阻。</p><p>我压根就不评估自己的效率。我不赞成自我评估，我觉得这是一种自我约束、自我惩罚和自我冲突。</p><p>如果他人因对你抱有期待而受伤，那就是他们的问题。如果他们和你有约在先，那就是你的问题。但如果他们只是单方面对你有所期待，那就完全是他们的问题，与你毫无关系。他们会对生活有各种各样的期待，越早打破他们对你的期待越好。</p><p>珍惜自己的时间。你唯一真正拥有的就是时间。时间比金钱更重要，比朋友更重要，比什么都重要。你的时间就是你的一切。不要浪费自己的时间。珍惜时间并不意味着不能放松下来享受生活。只要是做自己想做的事情，你就不是在浪费时间。但是，如果没有把时间花在想做的事情上，既没有赚到钱，也没有学到东西，你就要问问自己到底在瞎忙什么。不要花自己的时间去取悦别人。别人快不快乐是他们的问题，不是你的问题。你快乐了，别人也会快乐。你快乐了，别人会问你是如何快乐起来的，他们会从中学到点儿什么，但是你没有责任让别人快乐。</p><p>忙碌的思绪会加速主观时间的流逝。</p>]]></content>
    
    
    <summary type="html">这本书是对纳瓦尔的介绍，包含了他探索最深入的两个主题：财富和幸福。</summary>
    
    
    
    <category term="reading" scheme="https://blog.rustfisher.com/categories/reading/"/>
    
    
    <category term="读书笔记" scheme="https://blog.rustfisher.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>知乎上有意思的回答 - 汇总</title>
    <link href="https://blog.rustfisher.com/2023/05/30/fun/zt-zhihu-summary/"/>
    <id>https://blog.rustfisher.com/2023/05/30/fun/zt-zhihu-summary/</id>
    <published>2023-05-30T09:45:59.000Z</published>
    <updated>2023-12-25T06:16:38.476Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="/2023/04/27/fun/zt-zhihu-1/" title="知乎有趣的回答1 - 不劳而获 | 中国空间站为什么要叫外国人来 | 邻居的猫 | 导师的话1 | 百度 gpt">知乎有趣的回答1 - 不劳而获 | 中国空间站为什么要叫外国人来 | 邻居的猫 | 导师的话1 | 百度 gpt</a></li><li><a href="/2023/05/08/fun/zt-zhihu-2/" title="知乎有趣的回答2 - 烂尾楼没人管吗？ | 活下去的理由">知乎有趣的回答2 - 烂尾楼没人管吗？ | 活下去的理由</a></li><li><a href="/2023/05/10/fun/zt-zhihu-3/" title="知乎的回答截图3 - 为什么想自律却自律不起来">知乎的回答截图3 - 为什么想自律却自律不起来</a></li><li><a href="/2023/05/25/fun/zt-zhihu-4/" title="知乎有趣的回答4 - 创业段子">知乎有趣的回答4 - 创业段子</a></li><li><a href="/2023/05/04/fun/zt-zhihu-career-civil-1/" title="知乎职场回答 - 体制内1">知乎职场回答 - 体制内1</a></li><li><a href="/2023/05/30/fun/zt-zhihu-career-job-1/" title="知乎职场回答1">知乎职场回答1</a></li><li><a href="/2023/06/14/fun/zt-zhihu-life-health-1/" title="知乎回答 - 生活与健康1">知乎回答 - 生活与健康1</a></li><li><a href="/2023/04/27/fun/zt-zhihu-why-people-said-we-need-to-study-hard/" title="知乎回答 - 为什么所有人都在告诉我好好学习？">知乎回答 - 为什么所有人都在告诉我好好学习？</a></li></ul>]]></content>
    
    
    <summary type="html">收集一些知乎上有意思的回答，截图。职场篇。</summary>
    
    
    
    <category term="fun" scheme="https://blog.rustfisher.com/categories/fun/"/>
    
    
    <category term="知乎" scheme="https://blog.rustfisher.com/tags/%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
  <entry>
    <title>关于ENVI（.hdr+.img）、.mat、.tif的一些理解</title>
    <link href="https://blog.rustfisher.com/2023/04/18/ENVI/note-ENVI-hdr-img-mat-tif/"/>
    <id>https://blog.rustfisher.com/2023/04/18/ENVI/note-ENVI-hdr-img-mat-tif/</id>
    <published>2023-04-18T01:59:59.000Z</published>
    <updated>2023-04-18T02:03:39.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于ENVI（-hdr-img）、-mat、-tif的一些理解"><a href="#关于ENVI（-hdr-img）、-mat、-tif的一些理解" class="headerlink" title="关于ENVI（.hdr+.img）、.mat、.tif的一些理解"></a>关于ENVI（.hdr+.img）、.mat、.tif的一些理解</h1><div class="note note-info">            <p>原文作者：Akari00000<br>原文链接：<a href="https://blog.csdn.net/zx74196870/article/details/130213171">https://blog.csdn.net/zx74196870/article/details/130213171</a></p>          </div><p>书接上篇博客<a href="https://blog.csdn.net/zx74196870/article/details/130160795">c++ envi（.hdr+.img）图像转换成tiff格式 纯c++</a><br>这是一些关于这几个格式的一些探索研究，萌新的探索之旅</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>研究这几个格式的初衷是为了解决读的问题，这个时期的我完全不懂格式是什么意思。</p><p>通过mulitbanread（）函数，我可以实现MATLAB读写ENVI，把ENVI转换成.mat，我的.mat是一个三维矩阵，我能不能看到mat是什么样的数据组成呢？</p><p>说到底我只知道ENVI是.hdr+.img，hdr这么小，应该是放不下数据了，如果img装了数据，是怎么装的呢？</p><p>我是否有一个手段来验证multibandread（）转换的.mat正确与否？此时的我还不会使用二进制阅读器</p><p>此时我的目标是用c++调用multibandread（），所以我要通过.mat来研究.img，我要知道</p><p><img src="1.png" alt="函数的形参怎么填"><br>函数的形参怎么填</p><h2 id="对-mat和ENVI的探索"><a href="#对-mat和ENVI的探索" class="headerlink" title="对.mat和ENVI的探索"></a>对.mat和ENVI的探索</h2><p>HDR<br><img src="2.png" alt="在这里插入图片描述"></p><p>ENVI参数是：<br>行：1387<br>列：1829<br>波段数：20<br>数据字节数：2<br>数据存储格式：BIP</p><p>BIP是个啥玩意呢，我一开始也是懵逼的，网上看了很多文档，只看文字我压根看不懂。好在找到一个大佬的文章，有图！<a href="https://blog.csdn.net/m0_46387817/article/details/108467947">遥感图像通用数据格式（BSQ\BIL\BIP）的理解</a>，这里我直接截图关键部分<br><img src="3.png" alt="在这里插入图片描述"><br>通过阅读ENVI图像的文档ANALYZE7.5得知，.img存储的是简单的数据（2字节）</p><p>那我的.img的存储顺序是什么呢，以数学上的二维矩阵举例，如下图</p><p><img src="4.png" alt="在这里插入图片描述"><br>把上图想象成一个由1829个“小矩阵”拼成的大矩阵</p><p>我们知道，无论几位矩阵，在内存里的存储都是连续存储，通过c++遍历输出.img，得知.img存储的短整型数据的每个数字大小，5000~20000的数字（也可以通过二进制阅读器查看）。</p><p>那mat做了什么呢？怎么转换我的数据块的？</p><p>multibanread（）转换<br><img src="5.png" alt="在这里插入图片描述"><br>结果<br><img src="6.png" alt="在这里插入图片描述"><br>无法显示，数据量太大<br><img src="7.png" alt="在这里插入图片描述"><br>load（），输出1第一行<br><img src="8.png" alt="在这里插入图片描述"></p><p>结果可知，mat是个三维数组（废话<br><img src="9.png" alt="在这里插入图片描述"><br>mat行：1829<br>mat列：1387<br>mat波段数：20<br>按照mat的理解应该是 1829 （行）<em> （1387 </em> 20）（列）<br><img src="10.png" alt="在这里插入图片描述"><br>matlab的第一行有27740个元素，27740 =  1387 * 20</p><p>mat数据排布，20个“小矩阵”拼成的“大矩阵”<br><img src="11.png" alt="在这里插入图片描述"><br>与.img数据排布<br>对比<img src="12.png" alt="在这里插入图片描述"></p><p>然后发现个严肃的问题，我TM img不是这么排的啊？.mat是怎么存储我的每一个数据的呢？27740 =  1387 <em> 20，20我可以理解为是20个波段，1387是img的1387行，这时候我做出了一个假设，有没有可能，.mat是在按波段数存储呢？每张图片是1829</em>1387，存储了20个波段。这样的存储排布，就是上图的“20张图”。</p><p>我现在需要通过我的.img，得到20张（1829<em>1387）的图像。img的数据源是1829张（1387</em>20）图像，把每个数据块（小矩阵）想象成一个数据平面。接下来，我会做出一个“错误”的想象，方便理解，假设数据在内存空间里可以做到立体存储，这个三维数组就可以想象成一个长方体。假设我把每个数据平面叠在一起，就会得到个“立体存储空间”，这样就可以拼凑出一个一个棱长是1829,1387,20的长方体了<br><img src="13.png" alt="在这里插入图片描述"></p><p>沿着左侧面“切”一刀，正好可以“切”20刀，第一个侧面（小矩阵）如图<br><img src="14.png" alt="在这里插入图片描述"><br>长1387，宽1829，这不是很眼熟了呢？<br>把每个侧面拼在一起（20个小矩阵拼在一起）<br>得到一个宽1829，长1387*20的“大矩阵”数据</p><p><img src="15.png" alt="在这里插入图片描述"><br>与.img的数据排布进行对比</p><p><img src="16.png" alt="在这里插入图片描述"></p><p>根据这个假设得到一个假定数据排列顺序，假定结论：.mat把.img的矩阵数据按照波段存储。接下来就是验证.mat是不是把.img的数据这么存储的</p><p>用c++和matlab，索引相同坐标下的5个数据，<br>代码如图<br>c++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>FILE* P = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span>* idata = <span class="hljs-keyword">new</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span>[<span class="hljs-number">1829</span> * <span class="hljs-number">1387</span> * <span class="hljs-number">20</span> * <span class="hljs-number">2</span>];<br><br><span class="hljs-built_in">fopen_s</span>(&amp;P, <span class="hljs-string">&quot;C:\\Users\\41128\\Desktop\\matlab\\1.img&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-built_in">fread</span>(idata, <span class="hljs-number">2</span>, <span class="hljs-number">1829</span> * <span class="hljs-number">1387</span> * <span class="hljs-number">20</span>, P);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;(2,1,1)   &quot;</span> &lt;&lt; idata[<span class="hljs-number">27740</span>] &lt;&lt; endl;<span class="hljs-comment">//(2,1,1)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(1,1,2)   &quot;</span> &lt;&lt; idata[<span class="hljs-number">1</span>] &lt;&lt; endl;<span class="hljs-comment">//(1,1,2)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(1,3,1)   &quot;</span> &lt;&lt; idata[<span class="hljs-number">40</span>] &lt;&lt; endl;<span class="hljs-comment">//(1,3,1)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(3,1387,1)   &quot;</span> &lt;&lt; idata[<span class="hljs-number">83201</span>] &lt;&lt; endl;<span class="hljs-comment">//(3,1387,1)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;(2,1,2)   &quot;</span> &lt;&lt; idata[<span class="hljs-number">27741</span>] &lt;&lt; endl;<span class="hljs-comment">//(2,1,2)</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果<br><img src="17.png" alt="在这里插入图片描述"><br>matlab</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><br>load (<span class="hljs-string">&quot;1.mat&quot;</span>)<br>inputimg(<span class="hljs-number">1</span> , :)<br>inputimg(<span class="hljs-number">2</span> , <span class="hljs-number">1</span> , <span class="hljs-number">1</span>)<br>inputimg(<span class="hljs-number">1</span> , <span class="hljs-number">1</span> , <span class="hljs-number">2</span>)<br>inputimg(<span class="hljs-number">1</span> , <span class="hljs-number">3</span> , <span class="hljs-number">1</span>)<br>inputimg(<span class="hljs-number">3</span> , <span class="hljs-number">1387</span> , <span class="hljs-number">1</span>)<br>inputimg(<span class="hljs-number">2</span> , <span class="hljs-number">1</span> , <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>结果<br><img src="18.png" alt="在这里插入图片描述"><br>c++和matlab的输出结果一致，所以.mat的排布如图所示<br><img src="19.png" alt="在这里插入图片描述"></p><p>所以我可以通过.mat来验证.img的数据，也证明了.mat封装的数据没问题（有兴趣可以多试几个，我的想法有问题的话麻烦指出~）</p><p>结论：.mat把.img的数据按波段，按列顺序存储</p><p>还有一种理解，用存储顺序来理解<br>.img</p><p><img src="20.png" alt="在这里插入图片描述"></p><p><img src="21.png" alt="在这里插入图片描述"></p><p>A、B分别代表相对位置，以下为.mat存储几何示意图（1个小矩阵）<br><img src="22.png" alt="在这里插入图片描述"></p><p>所以.mat可以看做20个宽1829，长1387的矩阵组合成的大“二维矩阵”<br><img src="23.png" alt="在这里插入图片描述"></p><p>.mat的存储逻辑示意图（A1  -&gt; B1829为一个矩阵，地址由小到大）：<br><img src="24.png" alt="在这里插入图片描述"></p><p>即先存储.img每个矩阵的第一列,第一列A1 -&gt; B1 -&gt; A2 -&gt; B2 -&gt; … -&gt; A1829 - &gt;B1829。<br>即       <strong><em>逐列存储</em></strong>，之前在一个文档上印证过这个想法…现在找不到了</p><p>总结：.img转.mat两个格式逻辑排布，我想了4天，包括在写这个文档的时候，我还能想错，实在是太乱了，容易错。我认为思考这个问题的关键点有两点：1. 从数学逻辑思考（类似存储逻辑）2.从几何逻辑思考   3.从存储逻辑思考                                             </p><p>啥，你问我这玩意有啥用…….我只能说，这时候的我认为有用，而且这时我还被批评：4天你就干了个这？<br>好吧我承认我确实工作进度很慢，菜是这样的。不过这也为我未来研究tiff格式打好了基础，这更新了我的思维逻辑，从数据的存储结构去想问题。未来这个存储结构，我会用在c++转.mat的项目上。</p><p>说个有意思的事，我花了4天才搞明白的结构，给一个老师讲，半个小时就讲通了……………不得不感慨，人与人之间的差距是巨大的QAQ，老师还是牛。</p><p>对了，以上的说法均默认行存储，如果是列存储或者“Z”存储就不适用。</p><h2 id="对tiff的研究"><a href="#对tiff的研究" class="headerlink" title="对tiff的研究"></a>对tiff的研究</h2><p>其实我看tiff的时候还算顺利，花了两天（）<br>网上有很多关于tiff的教程，啥都不懂的时候去看看是挺好的。但是最大的问题，网上应该几乎找不到和自己相同的案例吧。所以我认为看格式文档是最关键的，网上的教程只是帮你入门，文档才帮助你学明白的关键。</p><p>对tiff分析的关键，是第一个ifdoffset，从而分析IFD，以下是我学习的时候自己做的分析笔记，该tiff通过enviclassic转换</p><p><img src="25.png" alt="在这里插入图片描述"><br>堆着tiff文档，一个一个分析自己的TIFF。我的图像只有一个IFD，多IFD按照TIFF文档的要求分析就好。</p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>envi、tiff格式的文档以及我自己做的我的tiff的分析<br>ANALYZE75、TIFF6、TIFF格式的文档。<br>链接：<a href="https://pan.baidu.com/s/1kaRVsAJysAkLS-S0dqW2rg">https://pan.baidu.com/s/1kaRVsAJysAkLS-S0dqW2rg</a><br>提取码：2nrn</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>花了7天干出了个这，我也觉得自己很慢。不过还是受益匪浅，感觉自己对数据结构有了一点点了解。换成大佬来，这估计是个很简单的问题吧（）。<br>如果未来要做c++  envi转.mat，感觉有了一点点思路：）</p>]]></content>
    
    
    <summary type="html">研究这几个格式的初衷是为了解决读的问题。通过mulitbanread（）函数，我可以实现MATLAB读写ENVI，把ENVI转换成.mat，我的.mat是一个三维矩阵，我能不能看到mat是什么样的数据组成呢？</summary>
    
    
    
    <category term="ENVI" scheme="https://blog.rustfisher.com/categories/ENVI/"/>
    
    
    <category term="ENVI" scheme="https://blog.rustfisher.com/tags/ENVI/"/>
    
  </entry>
  
  <entry>
    <title>《巨人的方法》读书笔记</title>
    <link href="https://blog.rustfisher.com/2023/04/11/reading/SocialScience/TRIBE-OF-MENTORS-note/"/>
    <id>https://blog.rustfisher.com/2023/04/11/reading/SocialScience/TRIBE-OF-MENTORS-note/</id>
    <published>2023-04-11T06:12:59.000Z</published>
    <updated>2023-06-08T01:30:33.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><image src="巨人的方法-封面.jpg" style="height:260px"><div class="note note-info">            <p>作者：蒂姆·费里斯</p><p>通过一些简短的对话，传奇的创业家、投资人、艺术家、作家、科学家、电影人、运动员、教育家，与你分享他们深刻的失败、值得的投资、荒诞的习惯、常当作礼物送给他人的书、听过最糟的建议、忙碌的时候如何放松、如何重拾专注力……</p>          </div><h2 id="摘抄与笔记"><a href="#摘抄与笔记" class="headerlink" title="摘抄与笔记"></a>摘抄与笔记</h2><h3 id="大脑像身体一样有韧性"><a href="#大脑像身体一样有韧性" class="headerlink" title="大脑像身体一样有韧性"></a>大脑像身体一样有韧性</h3><p>痛苦能令人清醒，痛苦的时候你无法再否认当下的真相，你将被迫做出令你不适的改变。</p><p>把你的求知欲聚焦在当前的“热门”事物上。如果你的求知欲把你带到社会最终想要到达的地方，你将获得丰厚的报酬。做任何你想做的事，但不要那么焦虑、痛苦、情绪化。所有事情都是需要时间的。</p><p>忽略不公平，世上没有公平可言。尽你所能发挥自己的才能。</p><h3 id="作家应专注于自己的内心，不要总思考读者想读什么"><a href="#作家应专注于自己的内心，不要总思考读者想读什么" class="headerlink" title="作家应专注于自己的内心，不要总思考读者想读什么"></a>作家应专注于自己的内心，不要总思考读者想读什么</h3><p>如果有截止日期，我就会在那之前完成工作，但如果没有，我的效率就会非常低。我还发现，自己会一直处于工作状态。我很少能长时间全神贯注地工作，也很少能无忧无虑地休息。</p><p>晚上工作会扼杀社交生活，因为大多数社交生活都发生在周末以及工作日的晚上7点至11点之间。如果在这段时间工作，你就会突然成为那个别人永远都约不到的朋友，这种做法是极其短视的，也是不明智的。</p><p>当我设计工作上的接受清单时，我会使用一种方法，我称其为“墓志铭测试”。如果碰到什么机会，我会问自己，如果我的墓志铭写上相关内容，我是否会感到高兴。答案如果明显是否定的，就意味着这个机会对我而言并非十分重要。</p><p>病榻测试会促使我问自己两个问题：“当我临终时，我可能会想这个人吗？”通过这个问题，我可以确保把时间花在合适的人身上。</p><blockquote><p>类似的思考方法还有“遗愿清单”</p></blockquote><h3 id="越深入学习，越会发现自己无知"><a href="#越深入学习，越会发现自己无知" class="headerlink" title="越深入学习，越会发现自己无知"></a>越深入学习，越会发现自己无知</h3><p>批评不等于失败</p><p>改变和成长的秘诀不是意志力，而是积极的互助小组。</p><blockquote><p>圈子，以及志同道合的人</p></blockquote><h3 id="没人欠你任何东西-阿梅莉亚·布恩（Amelia-Boone）"><a href="#没人欠你任何东西-阿梅莉亚·布恩（Amelia-Boone）" class="headerlink" title="没人欠你任何东西 阿梅莉亚·布恩（Amelia Boone）"></a>没人欠你任何东西 阿梅莉亚·布恩（Amelia Boone）</h3><p>当我觉得大脑卡壳的时候，完成一项任务，不管它有多无聊，都会给我重新集中精力的动力。除此之外，我还会运动，最好是越野跑。大自然和内啡肽总能解决问题。</p><blockquote><p>和前面的整理家务类似</p></blockquote><p>你如果想弄清楚自己的人生方向或者对什么充满热情，就关注那些你在意过程而非结果的活动、想法和领域。我们都喜欢那些结果可以证明一切的任务，不过，我发现真正的成就来自对过程的热爱。寻找那些你喜欢过程胜于结果的东西，结果将随之而来。</p><h3 id="活在当下"><a href="#活在当下" class="headerlink" title="活在当下"></a>活在当下</h3><p>“活在当下。”（我一直努力做到这一点，但常常败下阵来。）</p><h3 id="要用一生来学习"><a href="#要用一生来学习" class="headerlink" title="要用一生来学习"></a>要用一生来学习</h3><p>“跟随自己的好奇心，不管它指向何方。”</p><h3 id="比起原创我更看重诚意-约瑟夫·高登-莱维特（Joseph-Gordon-Levitt）"><a href="#比起原创我更看重诚意-约瑟夫·高登-莱维特（Joseph-Gordon-Levitt）" class="headerlink" title="比起原创我更看重诚意 约瑟夫·高登-莱维特（Joseph Gordon-Levitt）"></a>比起原创我更看重诚意 约瑟夫·高登-莱维特（Joseph Gordon-Levitt）</h3><p>谷歌学术和谷歌很像，只不过是用来搜索学术论文和科学研究成果的。如果我想了解什么东西，我不会去读那些吸引眼球的标题党，而是会在谷歌学术上寻找科学的内容。这样做花的时间更长。学术论文不容易读懂。实际上，我经常需要别人的帮助，但一切都是值得的。</p><h3 id="期望值的不确定性也包括在期望值之内-朱莉娅·加莱夫（Julia-Galef）"><a href="#期望值的不确定性也包括在期望值之内-朱莉娅·加莱夫（Julia-Galef）" class="headerlink" title="期望值的不确定性也包括在期望值之内  朱莉娅·加莱夫（Julia Galef）"></a>期望值的不确定性也包括在期望值之内  朱莉娅·加莱夫（Julia Galef）</h3><p>我已经学会远离一种令人分心的东西，那就是向我推送我已经了解且认同的内容的媒体，比如政治媒体。这些信息可能会让人上瘾，因为它们看起来是那么有道理，就像和朋友发泄一样。但是，你从中学不到任何东西，而且我认为，沉迷其中会使你逐渐地无法容忍其他观点。所以，我会提醒自己浪费了这么多时间却什么都学不到，以此防止自己上瘾。</p><blockquote><p>这类东西也能让别人上瘾</p></blockquote><h3 id="37-不要把失败与结果联系在一起"><a href="#37-不要把失败与结果联系在一起" class="headerlink" title="37 不要把失败与结果联系在一起"></a>37 不要把失败与结果联系在一起</h3><p>要寻求异见。一定要努力找到和你意见不同的人，他们可以诚实且富有成效地扮演唱反调的人。挑战自己，真心聆听那些想法和意见与你相异的人。尽可能远离政治泡沫和回音室效应。愿意倾听那些持不同意见的人说的话。尝试每天改变你对一件事的看法。</p><h3 id="41-信息量达到临界值后，额外信息会加深“确认偏见”"><a href="#41-信息量达到临界值后，额外信息会加深“确认偏见”" class="headerlink" title="41 信息量达到临界值后，额外信息会加深“确认偏见”"></a>41 信息量达到临界值后，额外信息会加深“确认偏见”</h3><p>朱利安·杰恩斯的《二分心智的崩塌：人类意识的起源》</p><h3 id="44-时间和注意力是完全不同的两件事"><a href="#44-时间和注意力是完全不同的两件事" class="headerlink" title="44 时间和注意力是完全不同的两件事"></a>44 时间和注意力是完全不同的两件事</h3><p>时间和注意力是完全不同的两件事。它们是你前进过程中最宝贵的资源。</p><p>注意力是工作的媒介。虽然人们经常说没有足够的时间，但你要记住，注意力总是比时间少。全神贯注意味着全力以赴，每个人都想抢走你的注意力，请保护好它。</p><h3 id="47-技术的重点不是赚钱，而是解决问题"><a href="#47-技术的重点不是赚钱，而是解决问题" class="headerlink" title="47 技术的重点不是赚钱，而是解决问题"></a>47 技术的重点不是赚钱，而是解决问题</h3><p>创造的价值要多于你获取的价值</p><blockquote><p>不是技术不值钱，而是产品不值钱</p></blockquote><h3 id="49-优秀与卓越的区别在于善良"><a href="#49-优秀与卓越的区别在于善良" class="headerlink" title="49 优秀与卓越的区别在于善良"></a>49 优秀与卓越的区别在于善良</h3><p>失败意味着要继续奋斗，而奋斗总能给我增添力量。</p><p>还有一点也很关键，那就是要始终保持友善。善良在那段战胜困难的旅程中至关重要。优秀与卓越的差距就在于善良。</p><p>学会享受当下，而不是总为未来而努力。</p><h3 id="50-找出问题所在永远是一项可靠的投资"><a href="#50-找出问题所在永远是一项可靠的投资" class="headerlink" title="50 找出问题所在永远是一项可靠的投资"></a>50 找出问题所在永远是一项可靠的投资</h3><p>确定问题所在永远是一项可靠的投资，值得我们投入时间、金钱和精力。</p><p>睡眠。饮食、运动和职业道德远远比不上睡眠对生活、爱情、育儿和领导方式的影响。</p><div class="note note-success">            <p>喜欢忙碌并不是勤劳。——塞涅卡</p>          </div><h3 id="57-要尊重自己"><a href="#57-要尊重自己" class="headerlink" title="57 要尊重自己"></a>57 要尊重自己</h3><p>“你99岁，快要死了，你现在有机会回到现在，这时你会怎么做？”当很多次遇到难题时，我都会用上这句话。</p><blockquote><p>闭上眼睛，想象自己是个99岁的老人</p></blockquote><p>我必须非常留心应该把自己的精力放在哪里。在此过程中，我改变了使用手机的方式。我没有将每封邮件都视为人生中最重要的事情，而是把它们视为能量的化身。这封邮件会给我带来能量，还是会从我身上吸走能量？我意识到大多时候答案都是后者。</p><p>你用什么方法重拾专注力？我只需要接触实实在在的东西即可。这可以通过很多方式来实现：游泳，水是真实的；冥想，心是真实的；与动物接触，它们也是真实的；独自在阳光下享用一顿美餐。我喜欢一个人吃饭，我会慢慢品尝食物，把很多心思融到食物中，我的味觉比以前更敏锐了。吃饭时，我往往会因为食物的味道而激动。这些无足轻重的真实时刻会让你忘掉烦心事。</p><h3 id="83-要诚实地思考问题"><a href="#83-要诚实地思考问题" class="headerlink" title="83 要诚实地思考问题"></a>83 要诚实地思考问题</h3><p>不必担心余生将要做什么，只需要找到一份未来3到5年能够挣钱的有趣工作即可。</p><h3 id="85-没有通向成功的普遍可行之路"><a href="#85-没有通向成功的普遍可行之路" class="headerlink" title="85 没有通向成功的普遍可行之路"></a>85 没有通向成功的普遍可行之路</h3><p>一个人对生活的态度在很大程度上取决于他们的乐观程度。乐观的人会更多地投资自己，因为他们认为延迟奖励会更高。悲观的人更喜欢为了获得立即回报而牺牲长期利益。然而，被每日负面新闻驱动的媒体行业所做的，正是我们俗话说的只见树木不见森林。</p><h3 id="86-好好设计自己的每一天"><a href="#86-好好设计自己的每一天" class="headerlink" title="86 好好设计自己的每一天"></a>86 好好设计自己的每一天</h3><p>财务自由是创造力的源泉。</p><h3 id="87-真正的失败会给人极大的自由"><a href="#87-真正的失败会给人极大的自由" class="headerlink" title="87 真正的失败会给人极大的自由"></a>87 真正的失败会给人极大的自由</h3><p>一次真正的失败会给人极大的自由。你不可能再往下掉了，所以往上爬是唯一的选择。你没有什么可以失去的东西了。因此，这种自由好似狂喜，它可以为你的心打开一扇门，引导你走向自己真正想做的事情。这个过程充满了无限的自由和喜悦，同时毫无恐惧。你将获得极大的幸福。</p><h3 id="89-以“做自己”为生是一种神奇的体验"><a href="#89-以“做自己”为生是一种神奇的体验" class="headerlink" title="89 以“做自己”为生是一种神奇的体验"></a>89 以“做自己”为生是一种神奇的体验</h3><p>你越早笑出来，越早可以继续自己的生活。你越早自嘲，越早可以过上真正的生活。</p><h3 id="94-迅速学习，但不要急于验证"><a href="#94-迅速学习，但不要急于验证" class="headerlink" title="94 迅速学习，但不要急于验证"></a>94 迅速学习，但不要急于验证</h3><p>迅速学习，但不要急于验证。</p><h3 id="95-戒糖"><a href="#95-戒糖" class="headerlink" title="95 戒糖"></a>95 戒糖</h3><p>我决定做一个项目，让它只有一个功能，并且把它做好，我的目标不是大获成功，而是不要以失败告终。任何结果都比未能交付要好。</p><p>美国有很大一部分人乳糖不耐受，但许多人都置之不理或是没有接受诊断。我只要有一点儿不小心，就会因腹胀而感到痛苦不已。</p><p>（1）尽可能避免摄入乳糖，包括奶酪和黄油（不幸的是，还包括几乎所有的巧克力，如果标签上写着“可能含有少量牛奶”，那就说明也不行）；</p><p>（2）即使我觉得没有吃过任何含乳糖的食物，每天也要服用两次乳糖酶片，因为在外出就餐时你永远不知道饭菜里面究竟都有什么；</p><p>（3）每天服用两次西甲硅油，因为这对排出气体有直接帮助。不要担心打嗝，因为体内的气体必须被排出，而人体只有两个排出口。最好让气体从上面排出来，而不是迫使它从下面排出。</p><h3 id="96-把事情做好的最佳方法就是放手"><a href="#96-把事情做好的最佳方法就是放手" class="headerlink" title="96 把事情做好的最佳方法就是放手"></a>96 把事情做好的最佳方法就是放手</h3><p>“为一个比你自己更远大的目标活着。”奇怪的是，这虽然不一定让你的生活更轻松，却可以让你更满意自己的生活。</p><blockquote><p>设定一个终极目标，能让你解脱出来</p></blockquote><h3 id="110-不要为了完美而拖延时间"><a href="#110-不要为了完美而拖延时间" class="headerlink" title="110 不要为了完美而拖延时间"></a>110 不要为了完美而拖延时间</h3><p>“重大机遇从来不会明明白白地显露出来。”</p><p>不管你是寻找最好的工作、客户、合作伙伴，还是新的商机，你第一眼看到它时，它都不太可能吸引你。实际上，最佳的机会一开始甚至都不会引起你的注意。一般来说，重大机会从表面上看往往没有什么吸引力。一个机会之所以能成为重大机会，全在于它的优点。如果潜在优点一看便知，那么这个机会早已成为别人的盘中物了。</p>]]></content>
    
    
    <summary type="html">通过一些简短的对话，传奇的创业家、投资人、艺术家、作家、科学家、电影人、运动员、教育家，与你分享他们深刻的失败、值得的投资、荒诞的习惯、常当作礼物送给他人的书、听过最糟的建议、忙碌的时候如何放松、如何重拾专注力……</summary>
    
    
    
    <category term="reading" scheme="https://blog.rustfisher.com/categories/reading/"/>
    
    
    <category term="读书笔记" scheme="https://blog.rustfisher.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网站资源迁移说明</title>
    <link href="https://blog.rustfisher.com/2023/01/18/unclassified/web-res-move-2023/"/>
    <id>https://blog.rustfisher.com/2023/01/18/unclassified/web-res-move-2023/</id>
    <published>2023-01-18T08:32:32.000Z</published>
    <updated>2023-05-05T08:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网站迁移说明"><a href="#网站迁移说明" class="headerlink" title="网站迁移说明"></a>网站迁移说明</h1><p>博客站 blog.rustfisher.com 和教程站 an.rustfisher.com 的网站资源已经上传到github。</p><ul><li><a href="https://github.com/RustFisher/rustfisher.github.io">rustfisher.github.io - github</a></li><li><a href="https://github.com/AnRFDev/AnRFDev.github.io">AnRFDev.github.io - github</a></li></ul><p>并托管在cloudflare</p><ul><li><a href="an.rustfisher.com">an.rustfisher.com</a> -&gt; anrfdev-github-io.pages.dev</li><li><a href="blog.rustfisher.com">blog.rustfisher.com</a> -&gt; rustfisher-github-io.pages.dev</li></ul><p>若访问速度过慢，可考虑使用🪜</p><blockquote><p>mac终端配置使用<br>export http_proxy=<a href="http://127.0.0.1:7890">http://127.0.0.1:7890</a><br>export https_proxy=<a href="http://127.0.0.1:7890">http://127.0.0.1:7890</a></p></blockquote>]]></content>
    
    
    <summary type="html">博客站 blog.rustfisher.com 和教程站 an.rustfisher.com 的网站资源已经上传到github。若访问速度过慢，可考虑使用🪜</summary>
    
    
    
    <category term="unclassified" scheme="https://blog.rustfisher.com/categories/unclassified/"/>
    
    
  </entry>
  
  <entry>
    <title>2021年11月总结</title>
    <link href="https://blog.rustfisher.com/2021/11/30/Summary/2021-11/"/>
    <id>https://blog.rustfisher.com/2021/11/30/Summary/2021-11/</id>
    <published>2021-11-30T15:59:59.000Z</published>
    <updated>2023-04-10T00:39:31.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul><li><a href="https://an.rustfisher.com/android/jetpack/compose/compose-sample-proj1/">Jetpack Compose引入示例工程 | AnRFDev</a></li><li><a href="https://an.rustfisher.com/android/jetpack/compose/use-compose-in-proj/">现有工程使用Compose | AnRFDev</a></li><li><a href="https://an.rustfisher.com/android/ui/widget/seekbar/seekbar-custom-thumb-animation/">Android SeekBar 自定义thumb，thumb旋转动画效果 | AnRFDev</a></li></ul><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1oY411W7oa">【Android开发基础】03-改造初始工程 - bilibili</a><ul><li><a href="https://www.zhihu.com/zvideo/1447344528176455680">知乎视频</a></li></ul></li></ul><h2 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h2><ul><li><a href="https://an.rustfisher.com/webrtc/intro/concept-intro/">WebRTC概念简介 | AnRFDev</a></li><li><a href="https://an.rustfisher.com/webrtc/web-samples/getUserMedia-open-camera/">WebRTC打开本地摄像头 | AnRFDev</a></li><li><a href="https://an.rustfisher.com/webrtc/web-samples/canvas1/">WebRTC从摄像头获取图片传入canvas | AnRFDev</a></li><li><a href="https://an.rustfisher.com/webrtc/web-samples/css-filters/">WebRTC与CSS滤镜（filter） | AnRFDev</a></li></ul><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><h3 id="华为云社区"><a href="#华为云社区" class="headerlink" title="华为云社区"></a>华为云社区</h3><ul><li><a href="https://bbs.huaweicloud.com/blogs/308726">如何快速得到一个在线问卷应用？｜【玩转应用魔方】</a></li><li><a href="https://bbs.huaweicloud.com/blogs/308935">华为云语音交互实战｜【我们都是华为云专家】</a></li><li><a href="https://bbs.huaweicloud.com/blogs/312616">【云驻共创】区块链技术是如何影响各个产业的？</a></li></ul>]]></content>
    
    
    <summary type="html">Android文章、视频。WebRTC概念简介。以及华为云社区的一些更新。</summary>
    
    
    
    <category term="总结" scheme="https://blog.rustfisher.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://blog.rustfisher.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Android" scheme="https://blog.rustfisher.com/tags/Android/"/>
    
    <category term="WebRTC" scheme="https://blog.rustfisher.com/tags/WebRTC/"/>
    
    <category term="华为云社区" scheme="https://blog.rustfisher.com/tags/%E5%8D%8E%E4%B8%BA%E4%BA%91%E7%A4%BE%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC概念介绍</title>
    <link href="https://blog.rustfisher.com/2021/11/09/WebRTC/webRTC-concept-intro/"/>
    <id>https://blog.rustfisher.com/2021/11/09/WebRTC/webRTC-concept-intro/</id>
    <published>2021-11-09T12:28:11.000Z</published>
    <updated>2023-04-15T07:26:52.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="guide-1.png" alt="本文大纲"></p><h2 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h2><p>WebRTC（Web Real-Time Communication）。Real-Time Communication，实时通讯。</p><p>WebRTC能让web应用和站点之间选择性地分享音视频流。在不安装其它应用和插件的情况下，完成点对点通信。<br>WebRTC背后的技术被实现为一个开放的Web标准，并在所有主要浏览器中均以常规JavaScript API的形式提供。对于客户端（例如Android和iOS），可以使用提供相同功能的库。 WebRTC是个<a href="https://github.com/webrtc">开源项目</a>，得到Google，Apple，Microsoft和Mozilla等等公司的支持。2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。</p><p>WebRTC包括一系列API和相互关联的协议来实现通信。</p><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="VoIP"><a href="#VoIP" class="headerlink" title="VoIP"></a>VoIP</h3><p>Voice over Internet Protocol，在网络上传输声音消息的技术。<br>例如网络音频通话。或者叫做IP电话，宽带电话。使用VoIP技术的一大原因是费用低。</p><h2 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h2><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>Network address translation，网络地址转换。<br>NAT能给你的设备一个公共IP地址。一个路由器（router）有一个公共IP地址，每个连接到路由的设备有一个私有的IP地址。<br>设备发送请求时，会从一个特定端口，通过私有IP发送到路由的公共IP。这样每个设备在网上不需要都有一个公共IP地址，但也能被其它设备发现。</p><p>参考 <a href="https://datatracker.ietf.org/doc/html/rfc2663">IP Network Address Translator (NAT) Terminology and Considerations</a></p><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><p>Interactive Connectivity Establishment，互动式连接建立（交互式连通性建立）。<br>ICE是一套能让web浏览器之间互相连接的框架。通常来说，节点A到B是很难直接相连的。防火墙会阻止连接，设备没有公共IP地址，路由不允许直接连接其他节点。<br>ICE使用STUN或者TURN服务（或者同时使用两者）来建立连接。</p><p>参考 <a href="https://www.ietf.org/rfc/rfc8445.txt">ICE | rfc8445</a></p><h3 id="STUN"><a href="#STUN" class="headerlink" title="STUN"></a>STUN</h3><p>Session Traversal Utilities for NAT (STUN) ，NAT会话传输工具。<br>STUN协议能发现客户端（节点）的公共地址。客户端发送一个请求给网上的STUN服务器，服务器返回客户端的公共地址。不管客户端在路由器的NAT后能否可达。<br>STUN为请求者提供了可公开访问的IP地址，它就不再参与对话了。</p><p><img src="webrtc-stun.png" alt="STUN"></p><p>有些路由器会限制设备与外面其它设备的连接。这意味着即使STUN服务器知道了路由的公共IP地址，也没法建立连接。<br>这种情况下我们需要使用<strong>TURN</strong>。</p><h3 id="TURN"><a href="#TURN" class="headerlink" title="TURN"></a>TURN</h3><p>Traversal Using Relays around NAT，使用中继绕过NAT传输。<br>一些路由器使用一种叫“Symmetric NAT”（对称型NAT）的限制。这意味着路由器仅允许之前连接过的节点（peer）来建立连接。</p><p><strong>STUN</strong>提供了一个能让应用（终端，节点）穿过NAT的方法。STUN允许客户端获得一个传输地址（一个IP和端口）来获取其它节点的数据。<br>然而STUN获取到的地址不一定能被所有节点使用。这些地址是否可用取决于网络拓扑的情况。所以，单独STUN无法提供完整的穿越NAT的方案。</p><p>TURN协议允许两个处于NAT环境的主机利用中继进行通讯。客户端能够在TURN服务器上分配资源，与其它客户端（peer）进行通讯。<br>客户端关联一个TURN服务器的地址（relayed server address）来作为中继。<br>客户端发送报文给TURN服务，TURN服务使用relayed server address作为源地址向其他客户端中继转发报文。<br>穿越NAT，这个过程就像是“打洞”。也有人称TURN服务器为“打洞服务器”。</p><p><img src="webrtc-turn.png" alt="TURN"></p><p>这么看，TURN服务器需要有大的带宽。因此，ICE会优先考虑直接通讯，无法直接通讯情况下会使用TURN。</p><p>参考 <a href="https://www.ietf.org/rfc/rfc8656.txt">TURN rfc8656</a></p><h3 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h3><p>Session Description Protocol，会话描述协议。</p><p>描述多媒体连接内容的协议。例如分辨率，格式，编码，加密算法等等。</p><p>实际上，SDP不是个真正的协议。它也是用来描述设备之间连接与传输多媒体的数据格式。</p><p>参考 <a href="https://www.rfc-editor.org/rfc/rfc8866.html">SDP: Session Description Protocol | rfc8866</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://webrtc.org/getting-started/media-devices">媒体设备入门 ｜ webrtc.org</a></li><li><a href="https://media.prod.mdn.mozit.cloud/attachments/2016/01/27/12363/9d667775214ae0422fae606050f60c1e/WebRTC%20-%20Signaling%20Diagram.svg">2个节点建立连接时的沟通过程 ｜ MDN</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols">WebRTC 协议介绍 ｜ developer.mozilla.org</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API/Signaling_and_video_calling">信令与视频通话 ｜ developer.mozilla.org</a></li></ul>]]></content>
    
    
    <summary type="html">WebRTC入门导读，介绍一些概念。WebRTC (Web Real-Time Communication)。VoIP，NAT，ICE，STUN，TURN，SDP。</summary>
    
    
    
    <category term="WebRTC" scheme="https://blog.rustfisher.com/categories/WebRTC/"/>
    
    
    <category term="WebRTC" scheme="https://blog.rustfisher.com/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>Python抓取博客记录，获取标题与url</title>
    <link href="https://blog.rustfisher.com/2021/10/13/Python/scrapy-hw-blog-record/"/>
    <id>https://blog.rustfisher.com/2021/10/13/Python/scrapy-hw-blog-record/</id>
    <published>2021-10-13T15:15:14.000Z</published>
    <updated>2023-04-15T07:26:52.298Z</updated>
    
    <content type="html"><![CDATA[<p>在博客网站发布了一些博客。总共有四十多篇。现在查看这些博客需要翻页，不是很方便。<br>想要弄出一个列表，把标题和链接展示出来。如果手动去复制粘贴，耗时耗力，也不够自动化。<br>有没有什么自动化的方法呢？想到以前用python做过抓取的功能。</p><p>开发环境：</p><ul><li>Python3.7</li><li>PyCharm 2018.3.7 (Community Edition)</li><li>macOS 11.4</li></ul><h2 id="安装scrapy"><a href="#安装scrapy" class="headerlink" title="安装scrapy"></a>安装scrapy</h2><p>我们主要使用的框架是scrapy，官网 <a href="https://scrapy.org/">https://scrapy.org/</a> </p><p>如果需要换用清华的pip源，执行下面的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U<br>pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure></p><p>根据<a href="https://docs.scrapy.org/en/latest/intro/install.html">官网文档</a>进行安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install Scrapy<br></code></pre></td></tr></table></figure></p><h2 id="分析目标网页"><a href="#分析目标网页" class="headerlink" title="分析目标网页"></a>分析目标网页</h2><p>目标网页的部分html如下<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blog-menu blog-menu-noImg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blog-menu-header blog_no_attachment&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;portal_usercenter_2_usernew_blog_title_cus_i_0&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blogs/301790&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;common-blog-title&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Kotlin协程取消与超时&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 0px; color: rgb(51, 51, 51);&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blog-title-wrap&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;overflow-wrap: break-word;&quot;</span>&gt;</span><br>            Kotlin协程取消与超时<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><br>需要提取的是标题（title）和网址（url）。</p><h3 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h3><p>使用<code>scrapy shell</code>工具来分析一下目标网页<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell <span class="hljs-string">&#x27;https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_1&#x27;</span><br></code></pre></td></tr></table></figure><br>windows下的url需要用双引号</p><p>可以看到如下的运行结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">2021-10-13 09:46:47 [asyncio] DEBUG: Using selector: KqueueSelector<br>[s] Available Scrapy objects:<br>[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)<br>[s]   crawler    &lt;scrapy.crawler.Crawler object at 0x7fd889766990&gt;<br>[s]   item       &#123;&#125;<br>[s]   request    &lt;GET https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_1&gt;<br>[s]   response   &lt;200 https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_1&gt;<br>[s]   settings   &lt;scrapy.settings.Settings object at 0x7fd88987bb50&gt;<br>[s]   spider     &lt;DefaultSpider <span class="hljs-string">&#x27;default&#x27;</span> at 0x7fd889c7b710&gt;<br>[s] Useful shortcuts:<br>[s]   fetch(url[, redirect=True]) Fetch URL and update <span class="hljs-built_in">local</span> objects (by default, redirects are followed)<br>[s]   fetch(req)                  Fetch a scrapy.Request and update <span class="hljs-built_in">local</span> objects <br>[s]   shelp()           Shell <span class="hljs-built_in">help</span> (<span class="hljs-built_in">print</span> this <span class="hljs-built_in">help</span>)<br>[s]   view(response)    View response <span class="hljs-keyword">in</span> a browser<br>2021-10-13 09:46:48 [asyncio] DEBUG: Using selector: KqueueSelector<br></code></pre></td></tr></table></figure></p><p>尝试用scrapy的<code>css()</code>方法来提取元素，操作它的<code>response</code>变量</p><p>例如提取<code>div.blog-menu</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">In [2]: response.css(<span class="hljs-string">&#x27;div.blog-menu&#x27;</span>)<br>Out[2]: <br>[&lt;Selector xpath=<span class="hljs-string">&quot;descendant-or-self::div[@class and contains(concat(&#x27; &#x27;, normalize-space(@class), &#x27; &#x27;), &#x27; blog-menu &#x27;)]&quot;</span> data=<span class="hljs-string">&#x27;&lt;div class=&quot;blog-menu blog-menu-noImg&quot;&gt;&lt;&#x27;</span>&gt;,<br>...<br></code></pre></td></tr></table></figure><br>可以得到页面上所有满足要求的元素。拿到的元素是<strong>Selector</strong>，可以再进行下一步的操作。</p><p>用for循环读取提取到的元素，在此基础上，去抓取中文标题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">In [6]: <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.css(<span class="hljs-string">&#x27;div.blog-menu&#x27;</span>):<br>   ...:     <span class="hljs-built_in">print</span>(item.css(<span class="hljs-string">&#x27;a.common-blog-title::attr(title)&#x27;</span>).extract()[0])<br>   ...: <br>Kotlin协程取消与超时<br>Android Kotlin协程入门<br>Kotlin协程基础<br>Kotlin协程入门<br>Android View post 方法<br>Android Activity 传递Parcelable对象<br>Android Handler，Looper与MessageQueue使用与分析<br>Android线程池使用介绍<br>Java线程介绍<br>使用ECharts绘制网址径向树状图<br></code></pre></td></tr></table></figure></p><p><code>a.common-blog-title::attr(title)</code>表示的是我们要查找<code>&lt;a&gt;</code>里面的内容，指定class为<code>common-blog-title</code>，并且查找<code>title</code>属性。<br><code>css().extract()</code>将结果列表提取出来。最后得到我们关心的信息。</p><p>获取<code>url</code>同理，把提取部分修改为<code>::attr(href)</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>前面用shell工具进行分析，我们了解提取目标信息的方法。接下来写Python代码。</p><p>在合适的地方新建一个scrapy工程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy startproject blog<br></code></pre></td></tr></table></figure><br>可以得到一系列文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">blog<br>    spiders<br>        .gitignore<br>        __init__.py<br>    __init__.py<br>    items.py<br>    middlewares.py<br>    pipelines.py<br>    settings.py<br></code></pre></td></tr></table></figure></p><p>在<code>spiders</code>目录里新建一个文件<code>Hw.py</code>，它就是我们的“蜘蛛”。完整代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">import</span> scrapy<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">item</span>):<br>    <span class="hljs-keyword">return</span> item[<span class="hljs-string">&#x27;page&#x27;</span>]<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HwBlog</span>(scrapy.Spider):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    在最外层的blog目录进行操作</span><br><span class="hljs-string">    scrapy crawl hw</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    name = <span class="hljs-string">&quot;hw&quot;</span>  <span class="hljs-comment"># scrapy crawl hw</span><br>    res_list = []<br>    req_count = <span class="hljs-number">0</span><br>    total_url = <span class="hljs-number">5</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_requests</span>(<span class="hljs-params">self</span>):<br>        self.res_list = []<br>        urls = []<br>        base_url = <span class="hljs-string">&#x27;https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732/page_&#x27;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, self.total_url + <span class="hljs-number">1</span>):<br>            urls.append(base_url + <span class="hljs-built_in">str</span>(i))<br><br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=url, callback=self.parse)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        self.req_count = self.req_count + <span class="hljs-number">1</span><br>        page = response.url.split(<span class="hljs-string">&quot;_&quot;</span>)[-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response.css(<span class="hljs-string">&#x27;div.blog-menu&#x27;</span>):<br>            title_se = item.css(<span class="hljs-string">&quot;a.common-blog-title&quot;</span>)<br>            blog_url = <span class="hljs-string">&#x27;https://bbs.huaweicloud.com&#x27;</span> + (title_se.css(<span class="hljs-string">&quot;::attr(href)&quot;</span>).extract()[<span class="hljs-number">0</span>])<br>            blog_title = title_se.css(<span class="hljs-string">&quot;::attr(title)&quot;</span>).extract()[<span class="hljs-number">0</span>]<br>            self.res_list.append(&#123;<span class="hljs-string">&quot;title&quot;</span>: blog_title, <span class="hljs-string">&quot;url&quot;</span>: blog_url, <span class="hljs-string">&quot;page&quot;</span>: page&#125;)<br><br>        json_res = json.dumps(self.res_list, ensure_ascii=<span class="hljs-literal">False</span>)<br>        <span class="hljs-built_in">print</span>(json_res)<br><br>        res_file_path = <span class="hljs-string">&#x27;raw/hw.json&#x27;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(res_file_path, <span class="hljs-string">&#x27;w+&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(json_res)<br><br>        <span class="hljs-keyword">if</span> self.req_count &lt; self.total_url:<br>            <span class="hljs-keyword">return</span><br>        res_md = <span class="hljs-string">&#x27;raw/hw.md&#x27;</span><br>        self.res_list.sort(key=cmp)  <span class="hljs-comment"># 用页码来排序</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(res_md, <span class="hljs-string">&#x27;w+&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.writelines(<span class="hljs-string">&#x27;## 华为云社区&#x27;</span>)<br>            f.write(<span class="hljs-string">&#x27;\n博客数量:&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(self.res_list)) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> self.res_list:<br>                f.write(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                f.write(<span class="hljs-string">&#x27;- [&#x27;</span> + d[<span class="hljs-string">&#x27;title&#x27;</span>] + <span class="hljs-string">&#x27;](&#x27;</span> + d[<span class="hljs-string">&#x27;url&#x27;</span>] + <span class="hljs-string">&#x27;)&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>要启动的话，输入以下命令<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scrapy crawl hw</span><br></code></pre></td></tr></table></figure></p><p>接下来简单看一下代码</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>name</code>是蜘蛛的名字。我们启动的时候会用到它。这个名字由我们自己定义。</p><p><code>res_list</code>是暂存结果的列表。把获取到的结果暂时存放在里面。</p><p><code>total_url</code>表示一共要爬几个页面</p><p><code>req_count</code>表示请求次数</p><h3 id="start-requests-self"><a href="#start-requests-self" class="headerlink" title="start_requests(self)"></a><code>start_requests(self)</code></h3><p>在这个方法里进行一些配置工作。比如配置目标url。<br>我们是预先知道有5个页面，所以配置了5个url。</p><p>用<code>scrapy.Request(url=url, callback=self.parse)</code>构建请求</p><p><code>parse</code>是回调函数，请求成功后走这个方法。</p><h3 id="parse-self-response"><a href="#parse-self-response" class="headerlink" title="parse(self, response)"></a><code>parse(self, response)</code></h3><p>请求成功后，结果保存在<code>response</code>中。前面用shell进行的操作，可以直接写成python代码。</p><p>当请求次数达到目标后，开始写文件。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这是Python scrapy的一次简单应用。</p><p>安装scrapy，分析目标网页。把获取到的数据整理后写成markdown文件。</p><p>视频在<a href="https://www.bilibili.com/video/BV1qL411G7WB/">这里</a></p><iframe src="//player.bilibili.com/player.html?bvid=BV1qL411G7WB&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="400px"> </iframe>]]></content>
    
    
    <summary type="html">在博客网站发布了一些博客。总共有四十多篇。现在查看这些博客需要翻页，不是很方便。想要弄出一个列表，把标题和链接展示出来。用Python来实现这个过程。</summary>
    
    
    
    <category term="Python" scheme="https://blog.rustfisher.com/categories/Python/"/>
    
    
    <category term="爬虫" scheme="https://blog.rustfisher.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>2021年9月总结</title>
    <link href="https://blog.rustfisher.com/2021/09/30/Summary/2021-9/"/>
    <id>https://blog.rustfisher.com/2021/09/30/Summary/2021-9/</id>
    <published>2021-09-30T15:59:59.000Z</published>
    <updated>2023-04-15T07:25:29.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>给<a href="https://an.rustfisher.com">Android站</a>添加更多色彩。使用Mkdocs的功能，增加折叠功能和按钮。</p><p>增加了一个<a href="https://an.rustfisher.com/about/recent-post/">「最近更新」的界面</a>。在md里写html。手动汇总一下最近的更新信息。</p><p>做了一个导航页面 <a href="https://an.rustfisher.com/an-tree.html。">https://an.rustfisher.com/an-tree.html。</a><br>开发记录在这里 -&gt; <a href="https://rustfisher.com/2021/09/02/Web/note-echarts-py-url/">使用ECharts绘制网址径向树状图</a>。</p><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p>入门了协程。了解了协程的基本概念。</p><h2 id="网站修改"><a href="#网站修改" class="headerlink" title="网站修改"></a>网站修改</h2><p>利用mkdocs的插件，增加一些功能。</p><h3 id="增加引用"><a href="#增加引用" class="headerlink" title="增加引用"></a>增加引用</h3><p>一个markdown文件，可以引用其它文件的内容。用的框架是mkdocs，需要加入插件。在<code>mkdocs.yml</code>文件里加入<code>plugins</code>声明</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">plugins:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">search</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">macros</span><br><br><span class="hljs-attr">copyright:</span> <span class="hljs-string">Copyright</span> <span class="hljs-string">&amp;copy;</span> <span class="hljs-number">2020</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2021 </span><span class="hljs-string">RustFisher</span><br></code></pre></td></tr></table></figure><p>注意它与<code>copyright</code>同级。</p><p>但是还需要在电脑本地安装一下这个<code>macros</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install mkdocs-macros-plugin<br></code></pre></td></tr></table></figure></p><p>md引用其他文件的语法是<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name"><span class="hljs-name">include</span></span> &#x27;snippet.md&#x27; %&#125;</span><br></code></pre></td></tr></table></figure></p><p>如果要指定被引用文件的路径<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-bullet">-</span> <span class="hljs-attr">macros:</span><br>    <span class="hljs-attr">include_dir:</span> <span class="hljs-string">include-md</span><br></code></pre></td></tr></table></figure><br>注意<code>include_dir</code>必须再缩进8个空格</p><p>参考:</p><ul><li><a href="https://www.mkdocs.org/user-guide/configuration/#configuration-inheritance">https://www.mkdocs.org/user-guide/configuration/#configuration-inheritance</a></li><li><a href="https://mkdocs-macros-plugin.readthedocs.io/en/latest/#installation">https://mkdocs-macros-plugin.readthedocs.io/en/latest/#installation</a><ul><li><a href="https://mkdocs-macros-plugin.readthedocs.io/en/latest/advanced/#including-snippets-in-pages">https://mkdocs-macros-plugin.readthedocs.io/en/latest/advanced/#including-snippets-in-pages</a></li></ul></li></ul><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>同一篇文会先发在<a href="https://an.rustfisher.com/">🔗 Android教程站</a>，并同步发布到各个社区，更新内容汇总:</p><ul><li><strong>Android协程基础</strong><ul><li><a href="https://an.rustfisher.com/android/coroutines/intro1/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/301425"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://juejin.cn/post/7012167390926635038/">🔗 掘金社区</a></li><li><a href="https://www.cnblogs.com/rustfisher/p/15339044.html">🔗 博客园</a></li></ul></li><li><strong>Kotlin协程取消与超时</strong><ul><li><a href="https://an.rustfisher.com/kotlin/coroutines/cancel-timeout/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/301790"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li></ul></li><li><strong>Kotlin协程基础</strong><ul><li><a href="https://an.rustfisher.com/kotlin/coroutines/basic/b2/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/301126"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://juejin.cn/post/7011144404538753032/">🔗 掘金社区</a></li><li><a href="https://www.cnblogs.com/rustfisher/p/15336721.html">🔗 博客园</a></li></ul></li><li><strong>Kotlin协程入门</strong><ul><li><a href="https://an.rustfisher.com/kotlin/coroutines/basic/first/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/301044"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://juejin.cn/post/7010778538043260964/">🔗 掘金社区</a></li><li><a href="https://www.cnblogs.com/rustfisher/p/15330285.html">🔗 博客园</a></li><li><a href="https://ld246.com/article/1632492657279">🔗 链滴</a></li></ul></li><li><strong>Android View post 方法解析</strong><ul><li><a href="https://an.rustfisher.com/android/ui/view/rtfsc/post/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/300835"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://juejin.cn/post/7009652473937788964/">🔗 掘金社区</a></li><li><a href="https://ld246.com/article/1632062734581">🔗 链滴</a></li><li><a href="https://www.cnblogs.com/rustfisher/p/15322722.html">🔗 博客园</a></li></ul></li><li><strong>Android Activity 传递Parcelable对象</strong><ul><li><a href="https://an.rustfisher.com/android/activity/launch-send-parcelable/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/300757"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://segmentfault.com/a/1190000040709459">🔗 segmentfault</a></li></ul></li><li><strong>Handler，Looper与MessageQueue使用与分析</strong><ul><li><a href="https://an.rustfisher.com/android/handler/Handler_src_note/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/300369">🔗 华为云社区</a></li></ul></li><li><strong>Android使用线程池介绍</strong><ul><li><a href="https://an.rustfisher.com/android/concurrent/thread-pool-use-intro/">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/300152"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://juejin.cn/post/7006574333153771557/">🔗 掘金社区</a></li><li><a href="https://www.cnblogs.com/rustfisher/p/15263394.html">🔗 博客园</a></li><li><a href="https://ld246.com/article/1631345469189">🔗 链滴</a></li></ul></li><li><strong>Android多线程综述</strong><ul><li><a href="https://an.rustfisher.com/android/thread/android-thread-survey/">🔗 Android教程站</a></li></ul></li><li><strong>Java多线程介绍</strong><ul><li><a href="https://an.rustfisher.com/java/thread/thread-class-intro">🔗 Android教程站</a></li><li><a href="https://bbs.huaweicloud.com/blogs/298451"><image src="/img/avatar/huawei.png" style="width:18px; height:18px"></image> 华为云社区</a></li><li><a href="https://juejin.cn/post/7005038299249115173/">🔗 掘金社区</a></li><li><a href="https://www.cnblogs.com/rustfisher/p/15237641.html">🔗 博客园</a></li><li><a href="https://ld246.com/article/1631001736567">🔗 链滴</a></li></ul></li><li><a href="https://an.rustfisher.com/about/recent-post">Android合集的最近更新</a></li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>每个月多写一点。加强对网络通信的学习。</p>]]></content>
    
    
    <summary type="html">an.rustfisher.com添加更多色彩。使用Mkdocs的功能，增加折叠功能和按钮。做了一个导航页面。</summary>
    
    
    
    <category term="总结" scheme="https://blog.rustfisher.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://blog.rustfisher.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Android" scheme="https://blog.rustfisher.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>使用ECharts绘制网址径向树状图</title>
    <link href="https://blog.rustfisher.com/2021/09/02/Web/note-echarts-py-url/"/>
    <id>https://blog.rustfisher.com/2021/09/02/Web/note-echarts-py-url/</id>
    <published>2021-09-02T08:29:01.000Z</published>
    <updated>2023-04-15T07:26:52.299Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://an.rustfisher.com">an.rustfisher.com</a>有很多内容，很多页面。如果用一个树状图把所有页面展示出来会是什么效果？<br>第一时间想到了<a href="https://echarts.apache.org/zh/index.html">ECharts</a>。</p><p><a href="https://an.rustfisher.com/an-tree.html">最后效果： https://an.rustfisher.com/an-tree.html</a></p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>数据来源于配置文件。我们只需要把内容读出来，整理成ECharts需要的格式并保存为文件。</p><h3 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h3><p>Android站用的框架是Mkdocs，网址都设置在<strong>mkdocs.yml</strong>里。关键配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">nav:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Android basic:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">开始:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">新建工程:</span> <span class="hljs-string">android/startProject/start_new_project.md</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">使用Kotlin:</span> <span class="hljs-string">android/startProject/as-use-kotlin.md</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">Activity:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Activity综述:</span> <span class="hljs-string">android/activity/overview.md</span><br></code></pre></td></tr></table></figure><p>我们需要把这些数据读出来，弄成ECharts可以用的格式。</p><p>打开PyCharm，用python来处理数据。</p><h3 id="python处理数据"><a href="#python处理数据" class="headerlink" title="python处理数据"></a>python处理数据</h3><p>我们使用3.7版本python。要读取yml的内容，不想用读文本的方式一行行来读，还得自己解析。<br>python中有个库<a href="https://pypi.org/project/PyYAML/"><code>PyYAML</code></a>专门用于读取yml格式的数据。</p><p>在PyCharms里装上这个包。用它来读取yml里的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> yaml<br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(md_file, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> a_yaml_file:<br>        <span class="hljs-comment"># 解析yaml</span><br>        yaml_data = yaml.load(a_yaml_file, Loader=yaml.FullLoader)<br>        nav = yaml_data[<span class="hljs-string">&#x27;nav&#x27;</span>]<br></code></pre></td></tr></table></figure></p><p>ECharts需要的格式是<code>name</code>和<code>children</code>。同时可以添加别的字段。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Android教程&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Android basic&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p>读取到的数据层级比较多，用递归方法来处理它们。把所有的数据都遍历一遍，整理成需要的格式。</p><p>递归的时候，遇到数组，则继续递归；遇到字符串，则表示可以拼接网址了。</p><p>完整脚本如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> yaml<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_url_map</span>(<span class="hljs-params">main_site, md_file</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(md_file, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> a_yaml_file:<br>        <span class="hljs-comment"># 解析yaml</span><br>        yaml_data = yaml.load(a_yaml_file, Loader=yaml.FullLoader)<br><br>        nav = yaml_data[<span class="hljs-string">&#x27;nav&#x27;</span>]<br><br>        sorted_data = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Android教程&quot;</span>, <span class="hljs-string">&quot;children&quot;</span>: [], <span class="hljs-string">&quot;collapsed&quot;</span>: <span class="hljs-literal">False</span>&#125;<br><br>        <span class="hljs-keyword">for</span> big_dict <span class="hljs-keyword">in</span> nav:<br>            load_url(main_site, big_dict, sorted_data)<br><br>        url_file = <span class="hljs-string">&#x27;android-url-map.json&#x27;</span><br>        <span class="hljs-keyword">if</span> os.path.exists(url_file):<br>            os.remove(url_file)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(url_file, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> s:<br>            s.write(<span class="hljs-built_in">str</span>(json.dumps(sorted_data, ensure_ascii=<span class="hljs-literal">False</span>)))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_url</span>(<span class="hljs-params">main_site, input_dict, res_data</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    递归处理数据</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> k1 <span class="hljs-keyword">in</span> input_dict:<br>        v1 = input_dict[k1]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v1, <span class="hljs-built_in">list</span>):<br>            item1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: k1, <span class="hljs-string">&quot;children&quot;</span>: []&#125;<br>            res_data[<span class="hljs-string">&#x27;children&#x27;</span>].append(item1)<br>            <span class="hljs-keyword">for</span> v1_child <span class="hljs-keyword">in</span> v1:<br>                load_url(main_site, v1_child, item1)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(v1, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-comment"># 此时已经是url了</span><br>            final_item = &#123;<span class="hljs-string">&quot;name&quot;</span>: k1, <span class="hljs-string">&quot;url&quot;</span>: main_site + v1[<span class="hljs-number">0</span>:-<span class="hljs-number">3</span>]&#125;<br>            res_data[<span class="hljs-string">&#x27;children&#x27;</span>].append(final_item)<br>            <span class="hljs-keyword">return</span> final_item<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成android站的sitemap&quot;</span>)<br>    gen_url_map(<span class="hljs-string">&#x27;https://www.an.rustfisher.com/&#x27;</span>,<br>                <span class="hljs-string">&#x27;/Users/rustfisher/mkdocs.yml&#x27;</span>)<br><br></code></pre></td></tr></table></figure></p><p>最后写一个<strong>android-url-map.json</strong>文件。</p><h2 id="制作网页"><a href="#制作网页" class="headerlink" title="制作网页"></a>制作网页</h2><p>经过观察，我们选用径向树状图（tree-radial）。<br>查看ECharts的径向树状图<a href="https://echarts.apache.org/examples/zh/editor.html?c=tree-radial">使用示例</a>，下载一个示例html，在它的基础上修改。</p><p>添加上<code>jquery</code>的引用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>修改要读取的json文件名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">getJSON</span>(<span class="hljs-string">&#x27;./android-url-map.json&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure></p><p>把前面得到的json文件和这个html文件放在同一层级，上传服务器。</p><p>打开： <a href="https://an.rustfisher.com/an-tree.html">https://an.rustfisher.com/an-tree.html</a> 可以看到效果。</p><h3 id="扩大显示范围"><a href="#扩大显示范围" class="headerlink" title="扩大显示范围"></a>扩大显示范围</h3><p>这个时候的网页体验不是很好，页面不够大，图表超出上下范围了。可以给它添个竖直的滚动条<code>overflow-y: scroll</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100%; width: 100%; overflow-y: scroll;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>修改一下网页的<code>body</code>。外层的<code>container</code>占100%宽高，里面的<code>chartContainer</code>给一个<code>min-height: 1600px</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100%; margin: 0; width: 100%;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 100%; width: 100%;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chartContainer&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%; min-height: 1600px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>script里加上对<code>resize</code>的监听<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (myChart != <span class="hljs-literal">null</span> &amp;&amp; myChart != <span class="hljs-literal">undefined</span>) &#123;<br>        myChart.<span class="hljs-title function_">resize</span>();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>这时再看浏览器的效果，图表有了更多的空间显示。</p><p>参考</p><ul><li><a href="https://stackoverflow.com/questions/33454946/echarts-and-bootstrap-responsive-width">https://stackoverflow.com/questions/33454946/echarts-and-bootstrap-responsive-width</a></li><li><a href="https://stackoverflow.com/questions/12575251/why-is-my-page-not-scrollable">https://stackoverflow.com/questions/12575251/why-is-my-page-not-scrollable</a></li></ul><h3 id="点击打开页面"><a href="#点击打开页面" class="headerlink" title="点击打开页面"></a>点击打开页面</h3><p>默认点击效果是折叠和展开。对于最末尾的叶子节点，加一个点击事件让它打开相应的界面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">myChart.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) &#123;<br>    <span class="hljs-keyword">if</span> (params.<span class="hljs-property">data</span> &amp;&amp; params.<span class="hljs-property">data</span>.<span class="hljs-property">url</span>) &#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(params.<span class="hljs-property">data</span>.<span class="hljs-property">url</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="/img/radial-tree-cover.png" alt=""></p><p><a href="https://an.rustfisher.com/an-tree.html">最后效果： https://an.rustfisher.com/an-tree.html</a></p>]]></content>
    
    
    <summary type="html">用一个树状图把an.rustfisher.com所有页面展示出来会是什么效果？</summary>
    
    
    
    <category term="Web_note" scheme="https://blog.rustfisher.com/categories/Web-note/"/>
    
    
    <category term="web" scheme="https://blog.rustfisher.com/tags/web/"/>
    
    <category term="echarts" scheme="https://blog.rustfisher.com/tags/echarts/"/>
    
    <category term="python" scheme="https://blog.rustfisher.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2021年8月总结</title>
    <link href="https://blog.rustfisher.com/2021/08/31/Summary/2021-8/"/>
    <id>https://blog.rustfisher.com/2021/08/31/Summary/2021-8/</id>
    <published>2021-08-31T15:59:59.000Z</published>
    <updated>2023-04-15T07:26:52.248Z</updated>
    
    <content type="html"><![CDATA[<p>除了继续学习Android开发，也在其它方面做了一些拓展尝试。看了一些其它的技术。</p><h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><p>这个月主要以Android为主。参加了<a href="https://bbs.huaweicloud.com/community/usersnew/id_1606985929124732">华为云社区</a>的云驻共创活动。</p><ul><li><a href="https://rustfisher.com/2021/08/03/NestJS/mp-wx-http-status-code/">状态码造成微信公众号“该公众号提供的服务出现故障”</a></li><li><a href="https://bbs.huaweicloud.com/blogs/296652">【云驻共创】Knative应用开发指南</a></li><li><a href="https://bbs.huaweicloud.com/blogs/297488">【云驻共创】基于转移的语义Parser分享</a></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>继续完善<a href="https://an.rustfisher.com">Android站</a>。<br>这个月的Android方面博客/教程文章主要涉及<a href="https://an.rustfisher.com/android/ui/view/animation/view-animation-intro/">动画</a>、<a href="https://an.rustfisher.com/android/jetpack/workManager/use1/">WorkManager</a>和广播等基础知识。</p><ul><li><a href="https://an.rustfisher.com/android/jetpack/workManager/use1/">WorkManager使用入门</a></li><li><a href="https://an.rustfisher.com/android/jetpack/workManager/use2/">WorkManager工作约束，延迟与查询工作</a></li><li><a href="https://an.rustfisher.com/android/jetpack/workManager/periodic1/">Android WorkManager定时任务</a></li><li><a href="https://an.rustfisher.com/android/ui/view/animation/animation-drawable-use/">使用AnimationDrawable</a></li><li><a href="https://an.rustfisher.com/android/ui/view/animation/tween-use1/">补间动画</a></li><li><a href="https://an.rustfisher.com/android/ui/view/animation/object-animator-intro/">ObjectAnimator 更改视图位置</a></li><li><a href="https://an.rustfisher.com/android/broadcast/intro_use/">广播机制Broadcast介绍与使用</a></li><li><a href="https://an.rustfisher.com/android/service/start/foreground-service/">启动前台服务</a></li><li><a href="https://an.rustfisher.com/android/ui/view/view-summary/">View综述</a></li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>继续完善Android内容。尝试更多的新技术。</p>]]></content>
    
    
    <summary type="html">除了继续学习Android开发，也在其它方面做了一些拓展尝试。看了一些其它的技术。</summary>
    
    
    
    <category term="总结" scheme="https://blog.rustfisher.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://blog.rustfisher.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="Android" scheme="https://blog.rustfisher.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>状态码造成微信公众号“该公众号提供的服务出现故障”</title>
    <link href="https://blog.rustfisher.com/2021/08/03/NestJS/mp-wx-http-status-code/"/>
    <id>https://blog.rustfisher.com/2021/08/03/NestJS/mp-wx-http-status-code/</id>
    <published>2021-08-03T15:14:56.000Z</published>
    <updated>2023-04-15T07:26:52.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h2><p>我们使用NestJS写后台代码，给微信公众号提供服务。<br>用户给公众号发消息时，公众号会显示“该公众号提供的服务出现故障”。<br>虽然后台代码可以正常处理业务，但这个提示非常影响用户体验。</p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>根据<a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html">微信公众号文档</a>给的提示，出现这个问题的原因是没有给微信服务器返回正确的信息。</p><p>微信服务器需要的是<code>success</code>或者空的字符串。不能是json格式的字符串。<br>搜了一下其他文章，有的说xml里也不能带有空格；有的说公众号绑定了第三方平台，要去解绑。<br>但这些和我们的情况不一致。</p><p>给公众号的接口是默认返回<code>success</code>的。</p><p>查看运行log，发现用户发送1条消息给公众号，我们的服务端会收到4条一模一样的消息。<br>这4条消息的MsgId是一样的。网上也有人提供了防止重复消息的办法。</p><p>于是尝试以下方法</p><ol><li>维护一个map，key是MsgId。</li><li>接收到消息后，如果发现是重复的MsgId，则立刻返回<code>success</code>（或者空字符串）。</li></ol><p>但是问题依旧没有解决。</p><p>微信服务器认为它没有拿到正确的返回值，于是走了重试的流程。<br>我们ubuntu服务器上使用了nginx，于是我们查看nginx的log<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs log">81.69.1.1 - - [03/Aug/2021:09:41:25 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 0 &quot;-&quot; &quot;Mozilla/4.0&quot;<br>81.69.1.1 - - [03/Aug/2021:09:41:26 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 7 &quot;-&quot; &quot;Mozilla/4.0&quot;<br>81.69.1.1 - - [03/Aug/2021:09:41:26 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 7 &quot;-&quot; &quot;Mozilla/4.0&quot;<br>42.192.1.1 - - [03/Aug/2021:09:41:26 +0800] &quot;POST /mywxserve/?signature=sign1111&amp;timestamp=1627954885&amp;nonce=1832145745&amp;openid=qqq HTTP/1.1&quot; 201 7 &quot;-&quot; &quot;Mozilla/4.0&quot;<br></code></pre></td></tr></table></figure><br>可以看到有2个ip地址，发来了3+1次请求。看到nginx返回的状态码都是201。<br>(ip地址和信息模糊处理)</p><p>状态码201表示“已创建”。NestJS默认状态码是200，但是<a href="https://docs.nestjs.com/controllers#status-code">默认POST的状态码</a>是201。</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>我们强制让nestjs返回状态码200<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@HttpCode</span>(<span class="hljs-number">200</span>)<br><span class="hljs-meta">@Post</span>()<br><span class="hljs-keyword">async</span> <span class="hljs-title function_">onWxEvent</span>(<span class="hljs-meta">@Body</span>(<span class="hljs-string">&#x27;xml&#x27;</span>) <span class="hljs-attr">xmlData</span>: <span class="hljs-title class_">IWxMessageXmlData</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></p><p>再尝试一下，看到nginx的log，返回状态码是200了。公众号也正常了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs log">81.69.1.1 - - [03/Aug/2021:09:53:27 +0800] &quot;POST /mywxserve/?signature=rustfisher&amp;timestamp=1627955607&amp;nonce=1829147547&amp;openid=xxx0 HTTP/1.1&quot; 200 0 &quot;-&quot; &quot;Mozilla/4.0&quot;<br></code></pre></td></tr></table></figure></p><p>由此可见，接收微信公众号消息的时候，除了要返回空字符串或者<code>success</code>文本；返回状态码必须是200。<br>用其他的后台框架可能不会遇到状态码问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>wx基础消息能力-被动回复用户消息 <a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html</a></li><li>NestJS controller <a href="https://docs.nestjs.com/controllers#status-code">https://docs.nestjs.com/controllers#status-code</a> </li><li>NestJS文章集合 <a href="https://rustfisher.com/categories/NestJS/">https://rustfisher.com/categories/NestJS/</a></li><li>http状态码 <a href="https://rustfisher.com/2021/06/25/Network/http-code/">https://rustfisher.com/2021/06/25/Network/http-code/</a></li></ul>]]></content>
    
    
    <summary type="html">使用NestJS给微信公众号提供后台服务，用户发消息后公众号显示“该公众号提供的服务出现故障”</summary>
    
    
    
    <category term="NestJS" scheme="https://blog.rustfisher.com/categories/NestJS/"/>
    
    
    <category term="NestJS" scheme="https://blog.rustfisher.com/tags/NestJS/"/>
    
    <category term="后端" scheme="https://blog.rustfisher.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="公众号" scheme="https://blog.rustfisher.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>NestJS WebSocket 开始使用</title>
    <link href="https://blog.rustfisher.com/2021/07/22/NestJS/nestjs-websocket-start/"/>
    <id>https://blog.rustfisher.com/2021/07/22/NestJS/nestjs-websocket-start/</id>
    <published>2021-07-22T14:11:10.000Z</published>
    <updated>2023-04-15T07:26:52.296Z</updated>
    
    <content type="html"><![CDATA[<p>使用NestJs提供WebSocket服务。<br>本文会在新建项目的基础上增加2个类</p><ul><li>Gateway 实现业务逻辑的地方</li><li>WebSocketAdapter WebSocket适配器</li></ul><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>新建一个项目来演示，用npm来管理项目。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nest new websocket-start<br></code></pre></td></tr></table></figure></p><p>得到一个有基础功能的工程。</p><p>进入项目目录，安装2个库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i --save @nestjs/websockets @nestjs/platform-socket.io<br></code></pre></td></tr></table></figure></p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>使用端口3001<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3001</span>);<br></code></pre></td></tr></table></figure><br><code>npm run start</code>启动我们的工程。用postman测一下，功能ok。</p><h3 id="gateway介绍"><a href="#gateway介绍" class="headerlink" title="gateway介绍"></a><strong>gateway</strong>介绍</h3><p>Nest里的gateway(网关)只是一个用 <code>@WebSocketGateway()</code> 装饰器注释的类。从技术上讲，网关与平台无关，在创建适配器后它们与任何 WebSockets 库都兼容。</p><h4 id="新建Gateway"><a href="#新建Gateway" class="headerlink" title="新建Gateway"></a>新建Gateway</h4><p>新建<strong>ws.gateway.ts</strong>文件。在装饰器<code>@WebSocketGateway()</code>里端口指定为3002。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ConnectedSocket</span>, <span class="hljs-title class_">MessageBody</span>, <span class="hljs-title class_">SubscribeMessage</span>, <span class="hljs-title class_">WebSocketGateway</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@nestjs/websockets&quot;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">WebSocket</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ws&#x27;</span>;<br><br><span class="hljs-meta">@WebSocketGateway</span>(<span class="hljs-number">3002</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WsStartGateway</span> &#123;<br><br>  <span class="hljs-meta">@SubscribeMessage</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>  <span class="hljs-title function_">hello</span>(<span class="hljs-meta">@MessageBody</span>() <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-string">&quot;event&quot;</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>      <span class="hljs-string">&quot;data&quot;</span>: data,<br>      <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&#x27;rustfisher.com&#x27;</span><br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>里面有一个<code>hello</code>方法，订阅的消息是<code>&#39;hello&#39;</code>。</p><p>把它放进<code>AppModule</code>的<code>providers</code>里。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">providers</span>: [<span class="hljs-title class_">WsStartGateway</span>],<br></code></pre></td></tr></table></figure></p><p>如果websockt和http用了同一个接口(本例是3001)，启动时会报错<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>listen EADDRINUSE: address already in use :::3001<br></code></pre></td></tr></table></figure><br>因此我们这里给ws分配另一个端口号。</p><h4 id="获取WebSocket对象"><a href="#获取WebSocket对象" class="headerlink" title="获取WebSocket对象"></a>获取WebSocket对象</h4><p>在<code>WsStartGateway</code>里新增加一个消息订阅方法。<br>方法里接受<code>@ConnectedSocket() client: WebSocket</code>，这个client就是与客户端的连接对象。<br>我们可以用它来给客户端发送消息。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-meta">@SubscribeMessage</span>(<span class="hljs-string">&#x27;hello2&#x27;</span>)<br><span class="hljs-title function_">hello2</span>(<span class="hljs-meta">@MessageBody</span>() <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>, <span class="hljs-meta">@ConnectedSocket</span>() <span class="hljs-attr">client</span>: <span class="hljs-title class_">WebSocket</span>): <span class="hljs-built_in">any</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息 client:&#x27;</span>, client);<br>  client.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;tmp&#x27;</span>, <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;这里是个临时信息&#x27;</span> &#125;));<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;hello2&#x27;</span>, <span class="hljs-attr">data</span>: data &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="自定义WebSocketAdapter"><a href="#自定义WebSocketAdapter" class="headerlink" title="自定义WebSocketAdapter"></a>自定义WebSocketAdapter</h3><p>前面我们建立好了Gateway，还需要一个适配器。<br>新建文件<strong>ws.adapter.ts</strong>，继承<code>WebSocketAdapter</code><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">WebSocket</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ws&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WebSocketAdapter</span>, <span class="hljs-title class_">INestApplicationContext</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">MessageMappingProperties</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/websockets&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Observable</span>, fromEvent, <span class="hljs-variable constant_">EMPTY</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; mergeMap, filter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WsAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebSocketAdapter</span> &#123;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> app: INestApplicationContext</span>) &#123; &#125;<br><br>    <span class="hljs-title function_">create</span>(<span class="hljs-attr">port</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">options</span>: <span class="hljs-built_in">any</span> = &#123;&#125;): <span class="hljs-built_in">any</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ws create&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>(&#123; port, ...options &#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">bindClientConnect</span>(<span class="hljs-params">server, callback: <span class="hljs-built_in">Function</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ws bindClientConnect, server:\n&#x27;</span>, server);<br>        server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, callback);<br>    &#125;<br><br>    <span class="hljs-title function_">bindMessageHandlers</span>(<span class="hljs-params"></span><br><span class="hljs-params">        client: WebSocket,</span><br><span class="hljs-params">        handlers: MessageMappingProperties[],</span><br><span class="hljs-params">        process: (data: <span class="hljs-built_in">any</span>) =&gt; Observable&lt;<span class="hljs-built_in">any</span>&gt;,</span><br><span class="hljs-params">    </span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[waAdapter]有新的连接进来&#x27;</span>)<br>        <span class="hljs-title function_">fromEvent</span>(client, <span class="hljs-string">&#x27;message&#x27;</span>)<br>            .<span class="hljs-title function_">pipe</span>(<br>                <span class="hljs-title function_">mergeMap</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindMessageHandler</span>(client, data, handlers, process)),<br>                <span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result),<br>            )<br>            .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> client.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(response)));<br>    &#125;<br><br>    <span class="hljs-title function_">bindMessageHandler</span>(<br>        <span class="hljs-attr">client</span>: <span class="hljs-title class_">WebSocket</span>,<br>        buffer,<br>        <span class="hljs-attr">handlers</span>: <span class="hljs-title class_">MessageMappingProperties</span>[],<br>        <span class="hljs-attr">process</span>: <span class="hljs-function">(<span class="hljs-params">data: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt;,<br>    ): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">any</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> message = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            message = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(buffer.<span class="hljs-property">data</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ws解析json出错&#x27;</span>, error);<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">EMPTY</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">const</span> messageHandler = handlers.<span class="hljs-title function_">find</span>(<br>            <span class="hljs-function"><span class="hljs-params">handler</span> =&gt;</span> handler.<span class="hljs-property">message</span> === message.<span class="hljs-property">event</span>,<br>        );<br>        <span class="hljs-keyword">if</span> (!messageHandler) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">EMPTY</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">process</span>(messageHandler.<span class="hljs-title function_">callback</span>(message.<span class="hljs-property">data</span>));<br>    &#125;<br><br>    <span class="hljs-title function_">close</span>(<span class="hljs-params">server</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ws server close&#x27;</span>);<br>        server.<span class="hljs-title function_">close</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>在<code>bindMessageHandler</code>方法中，会将传来的json消息解析，然后发送到对应的处理器中。<br>这里就是发给gateway进行处理。<br>判断依据是<code>message.event</code>，就是<code>event</code>字段。</p><p>在<strong>main.ts</strong>里使用这个适配器。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">NestFactory</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AppModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">WsAdapter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ws/ws.adapter&#x27;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">AppModule</span>);<br>  app.<span class="hljs-title function_">useWebSocketAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WsAdapter</span>(app)); <span class="hljs-comment">// 使用我们的适配器</span><br>  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3001</span>);<br>&#125;<br><span class="hljs-title function_">bootstrap</span>();<br></code></pre></td></tr></table></figure></p><p><code>npm run start</code>运行项目，准备进一步测试。</p><h2 id="用Postman来测试WebSocket"><a href="#用Postman来测试WebSocket" class="headerlink" title="用Postman来测试WebSocket"></a>用Postman来测试WebSocket</h2><p>Postman8.8.0提供了beta版的WebSocket测试功能。<br><code>New -&gt; WebSocket Request beta</code>新建一个WebSocket测试。当前版本还不支持保存ws的测试例子。<br>输入目标url <code>ws://localhost:3002</code>，点击连接 Connect 按钮。</p><p><img src="p1.png" alt=""></p><p>发送测试消息。在消息框里填入以下json数据。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;event&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试数据&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p><img src="p2.png" alt=""></p><p>发送的数据经过<code>WsAdapter</code>分发给<code>WsStartGateway</code>，处理后返回数据。</p><p>发送hello2测试数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;event&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hello2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试数据&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p><img src="p3.png" alt=""></p><p>可以看到服务返回了2条数据。</p><p>发送一个错误格式的数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;event&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hello2</span><br></code></pre></td></tr></table></figure></p><p>服务端接收到了数据，但是解析失败<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ws解析json出错 SyntaxError: Unexpected end of JSON input<br></code></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>要使用WebSocket功能，需要增加</p><ul><li>Gateway 实现业务逻辑的地方</li><li>WebSocketAdapter WebSocket适配器</li></ul><p>ws的端口建议是和http的端口分开。</p><p>参考</p><ul><li>NestJS WebSockets <a href="https://docs.nestjs.com/websockets/gateways">https://docs.nestjs.com/websockets/gateways</a></li><li>NestJS 合集 <a href="https://rustfisher.com/categories/NestJS/">https://rustfisher.com/categories/NestJS/</a></li><li>示例工程 <a href="https://gitee.com/rustfisher/nest-sample">https://gitee.com/rustfisher/nest-sample</a></li></ul>]]></content>
    
    
    <summary type="html">使用NestJs提供WebSocket服务。新建一个项目来演示功能。实用性指南。</summary>
    
    
    
    <category term="NestJS" scheme="https://blog.rustfisher.com/categories/NestJS/"/>
    
    
    <category term="NestJS" scheme="https://blog.rustfisher.com/tags/NestJS/"/>
    
    <category term="后端" scheme="https://blog.rustfisher.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="WebSocket" scheme="https://blog.rustfisher.com/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Python图表库Matplotlib 组成部分介绍</title>
    <link href="https://blog.rustfisher.com/2021/07/20/Python/operation/matplotlib-intro-parts/"/>
    <id>https://blog.rustfisher.com/2021/07/20/Python/operation/matplotlib-intro-parts/</id>
    <published>2021-07-20T15:33:13.000Z</published>
    <updated>2023-04-15T07:26:52.299Z</updated>
    
    <content type="html"><![CDATA[<p>图表有很多个组成部分，例如标题、x/y轴名称、大刻度小刻度、线条、数据点、注释说明等等。</p><p>我们来看官方给的图，图中标出了各个部分的英文名称</p><p><img src="anatomy.webp" alt=""></p><p>Matplotlib提供了很多api，开发者可根据需求定制图表的样式。<br><a href="https://rustfisher.com/2021/07/16/Python/operation/matplotlib-intro1/">前面</a>我们设置了标题和x/y轴的名称，本文介绍更多设置其他部分的方法。</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>先绘制一个事例图。然后以此为基础进行定制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo2</span>():<br>    x_list = []<br>    y_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">365</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i * <span class="hljs-number">0.1</span>))<br>    ax = plt.gca()<br>    ax.set_title(<span class="hljs-string">&#x27;rustfisher.com mapplotlib example&#x27;</span>)<br>    ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)<br>    ax.grid()<br>    plt.plot(x_list, y_list)<br>    plt.show()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rustfisher 图表讲解&#x27;</span>)<br>    demo2()<br></code></pre></td></tr></table></figure><br>运行得到<br><img src="figure-ax.png" alt=""></p><p>红色框框里的是figure；绿色框框里的叫做ax。<br>代码中<code>ax = plt.gca()</code>获取到的就是绿色框框里的部分（对象）。</p><h2 id="Figure-大图"><a href="#Figure-大图" class="headerlink" title="Figure 大图"></a>Figure 大图</h2><p>Figure代表整张图，暂时称为“全图”或者“大图”。一张图里可以有多个子图表。最少必须要有一个图表。像上面那样。</p><h2 id="Axes-数据图"><a href="#Axes-数据图" class="headerlink" title="Axes 数据图"></a>Axes 数据图</h2><p>一张张的图，图里显示着数据，暂称为“数据图”。一个大图里可以有多个数据图。但单个数据图对象只能在1个大图里。</p><h3 id="多张数据图-subplots"><a href="#多张数据图-subplots" class="headerlink" title="多张数据图 subplots"></a>多张数据图 subplots</h3><p>例如同时存在2个数据图</p><p><img src="subplot1-2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_subplot</span>():<br>    x_list = []<br>    y_list = []<br>    y2_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">365</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i * <span class="hljs-number">0.1</span>))<br>        y2_list.append(math.cos(i * <span class="hljs-number">0.1</span>))<br>    fig, (ax1, ax2) = plt.subplots(<span class="hljs-number">2</span>)<br>    ax1.set_title(<span class="hljs-string">&#x27;rustfisher.com 1&#x27;</span>)<br>    ax2.set_title(<span class="hljs-string">&#x27;rustfisher.com 2&#x27;</span>)<br>    ax1.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax1.set_ylabel(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)<br>    ax2.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax2.set_ylabel(<span class="hljs-string">&#x27;y = cos(x)&#x27;</span>)<br>    ax1.plot(x_list, y_list)<br>    ax2.plot(x_list, y2_list)<br>    plt.show()<br></code></pre></td></tr></table></figure><p>调用<code>subplots()</code>接口，传入数字指定要多少张数据图。<br>返回的多张图要用括号括起来。每个数据图可以绘制(<code>plot</code>)不同的数据。<br>标题用<code>set_title()</code>来设置。</p><p>可以看到上下两张图太挤了，有重叠部分。可以在<code>plt.show()</code>之前加一个<code>fig.tight_layout()</code>让它们拉开一点距离。</p><p><img src="subplot1-2-tight.png" alt=""></p><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><p>对于2维数据图，它有2个坐标，横坐标和纵坐标。有一些接口可以设置参数。<br>例如控制坐标轴的名字<code>set_xlabel()</code> <code>set_ylabel</code>；</p><h4 id="显示数据范围"><a href="#显示数据范围" class="headerlink" title="显示数据范围"></a>显示数据范围</h4><p><code>set_xlim</code>方法可以控制x轴数据显示范围。同理y轴用<code>set_ylim</code>来控制。<br>对于显示范围，<code>set_xlim</code>方法主要参数为<code>left</code>和<code>right</code>；或者用<code>xmin</code> <code>xmax</code>。这两套不能同时使用。<br><code>set_ylim</code>主要参数是<code>top</code> <code>bottom</code>；或者<code>ymin</code> <code>ymax</code>。这两套不能同时使用。</p><p>增加显示范围控制的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo3</span>():<br>    x_list = []<br>    y_list = []<br>    y2_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">365</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i * <span class="hljs-number">0.1</span>))<br>        y2_list.append(math.cos(i * <span class="hljs-number">0.1</span>))<br>    fig, (ax1, ax2) = plt.subplots(<span class="hljs-number">2</span>)<br>    ax1.set_title(<span class="hljs-string">&#x27;rustfisher.com 1&#x27;</span>)<br>    ax1.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax1.set_ylabel(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)<br>    ax2.set_title(<span class="hljs-string">&#x27;rustfisher.com 2&#x27;</span>)<br>    ax2.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax2.set_ylabel(<span class="hljs-string">&#x27;y = cos(x)&#x27;</span>)<br><br>    ax1.set_xlim(left=<span class="hljs-number">50</span>, right=<span class="hljs-number">200.6</span>)  <span class="hljs-comment"># 控制x轴显示范围</span><br>    ax1.set_ylim(top=<span class="hljs-number">1</span>, bottom=<span class="hljs-number">0.3</span>)  <span class="hljs-comment"># 控制y轴显示范围</span><br><br>    ax2.set_xlim(xmin=<span class="hljs-number">1</span>, xmax=<span class="hljs-number">156.6</span>)  <span class="hljs-comment"># 控制x轴显示范围</span><br>    ax2.set_ylim(ymin=-<span class="hljs-number">0.3</span>, ymax=<span class="hljs-number">0.3</span>)  <span class="hljs-comment"># 控制y轴显示范围</span><br><br>    ax1.plot(x_list, y_list)<br>    ax2.plot(x_list, y2_list)<br>    fig.tight_layout()<br>    plt.show()<br></code></pre></td></tr></table></figure></p><p>运行结果</p><p><img src="xylim.png" alt=""></p><h4 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h4><p>tick意思是标记。在坐标轴上的是刻度。Major tick暂称为大刻度，minor tick暂称为小刻度。<br>使用<code>set_xticks</code>方法控制刻度显示。传入的列表是我们希望显示的刻度。<br><code>minor</code>参数默认为False，不显示小刻度。</p><p>关键代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ax1.set_xticks([<span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">150</span>])<br>ax1.set_yticks([<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.9</span>])<br>ax1.grid()  <span class="hljs-comment"># 显示格子</span><br><br>ax2.set_xticks([<span class="hljs-number">1</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">150</span>], minor=<span class="hljs-literal">True</span>)<br>ax2.set_yticks([-<span class="hljs-number">0.1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>], minor=<span class="hljs-literal">True</span>)<br>ax2.grid()<br></code></pre></td></tr></table></figure></p><p><img src="xy-ticks.png" alt=""></p><p>可见当<code>minor=True</code>，传入的刻度列表有可能不显示。</p><p>也可以控制大刻度上的文字旋转<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.setp(ax1.xaxis.get_majorticklabels(), rotation=-<span class="hljs-number">45</span>)<br>plt.setp(ax2.xaxis.get_majorticklabels(), rotation=-<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure></p><p><img src="majortick-rotate.png" alt=""></p><h4 id="边线-spine"><a href="#边线-spine" class="headerlink" title="边线 spine"></a>边线 spine</h4><p>spine是脊柱的意思，这里我们先称为边线。有上下左右4条边线。名称是<code>top</code> <code>bottom</code> <code>left</code> <code>right</code><br>可以直接从图表对象获取它的边线，比如右边线<code>ax1.spines.right</code>。</p><p>一些简单的操作，例如</p><ul><li><code>set_visible</code> 显示和隐藏</li><li><code>set_ticks_position</code> 刻度显示的位置</li><li><code>set_bounds</code> 边线显示范围</li><li><code>set_linewidth</code> 线的宽度</li></ul><p>隐藏右边线和上边线<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax1.spines.right.set_visible(<span class="hljs-literal">False</span>)<br>ax1.spines.top.set_visible(<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure></p><p>让刻度显示在右边和上方<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax2.yaxis.set_ticks_position(<span class="hljs-string">&#x27;right&#x27;</span>)<br>ax2.xaxis.set_ticks_position(<span class="hljs-string">&#x27;top&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>设置边线显示范围<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax3.spines.left.set_bounds(-<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)<br>ax3.spines.top.set_bounds(<span class="hljs-number">340</span>, <span class="hljs-number">400</span>)<br></code></pre></td></tr></table></figure></p><p>设置线的宽度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ax3.spines.bottom.set_linewidth(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure></p><p>完整代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_spine</span>():<br>    x_list = []<br>    y_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">365</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i * <span class="hljs-number">0.1</span>))<br><br>    fig, (ax1, ax2, ax3) = plt.subplots(<span class="hljs-number">3</span>)<br>    ax_list = [ax1, ax2, ax3]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>):<br>        cur_ax = ax_list[i]<br>        cur_ax.set_title(<span class="hljs-string">&#x27;rustfisher.com &#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        cur_ax.plot(x_list, y_list)<br>        cur_ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>        cur_ax.set_ylabel(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)<br><br>    ax1.spines.right.set_visible(<span class="hljs-literal">False</span>)<br>    ax1.spines.top.set_visible(<span class="hljs-literal">False</span>)<br><br>    ax2.spines.bottom.set_visible(<span class="hljs-literal">False</span>)<br>    ax2.spines.left.set_visible(<span class="hljs-literal">False</span>)<br>    ax2.yaxis.set_ticks_position(<span class="hljs-string">&#x27;right&#x27;</span>)<br>    ax2.xaxis.set_ticks_position(<span class="hljs-string">&#x27;top&#x27;</span>)<br><br>    ax3.spines.left.set_bounds(-<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)<br>    ax3.spines.top.set_bounds(<span class="hljs-number">340</span>, <span class="hljs-number">400</span>)<br>    ax3.spines.bottom.set_linewidth(<span class="hljs-number">2</span>)<br><br>    fig.tight_layout()<br>    plt.show()<br></code></pre></td></tr></table></figure></p><p>运行截图</p><p><img src="spines.png" alt=""></p><h3 id="数据点"><a href="#数据点" class="headerlink" title="数据点"></a>数据点</h3><p>控制数据点的样式。下面我们在一张图表里绘制多条数据线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_line</span>():<br>    x_list = []<br>    y_list = []<br>    y2_list = []<br>    y3_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i) * <span class="hljs-number">2</span> - <span class="hljs-number">4</span>)<br>        y2_list.append(math.sin(i) * <span class="hljs-number">2</span>)<br>        y3_list.append(math.cos(i) * <span class="hljs-number">1.3</span> + <span class="hljs-number">3</span>)<br><br>    plt.plot(x_list, y_list, color=<span class="hljs-string">&#x27;blue&#x27;</span>, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>, linewidth=<span class="hljs-number">2</span>, markersize=<span class="hljs-number">4</span>)<br>    plt.plot(x_list, y2_list, <span class="hljs-string">&#x27;go&#x27;</span>, linewidth=<span class="hljs-number">1</span>)<br>    plt.plot(x_list, y3_list, <span class="hljs-string">&#x27;r+&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p><code>plot()</code>方法中，支持多种选项。</p><p><code>linestyle</code>支持的选项<br>‘-‘, ‘–’, ‘-.’, ‘:’, ‘None’, ‘ ‘, ‘’, ‘solid’, ‘dashed’, ‘dashdot’, ‘dotted’</p><p><img src="line.png" alt=""></p><h3 id="注释-legend"><a href="#注释-legend" class="headerlink" title="注释 legend"></a>注释 legend</h3><p>添加注释，调用<code>lengend()</code>方法。</p><p>在前面代码基础上添加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x_list, y_list, color=<span class="hljs-string">&#x27;blue&#x27;</span>, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>, linewidth=<span class="hljs-number">2</span>, markersize=<span class="hljs-number">4</span>)<br>plt.plot(x_list, y2_list, <span class="hljs-string">&#x27;go&#x27;</span>, linewidth=<span class="hljs-number">1</span>)<br>plt.plot(x_list, y3_list, <span class="hljs-string">&#x27;r+&#x27;</span>)<br>plt.legend([<span class="hljs-string">&#x27;math.sin(i) * 2 - 4&#x27;</span>, <span class="hljs-string">&#x27;math.sin(i) * 2&#x27;</span>, <span class="hljs-string">&#x27;math.cos(i) * 1.3 + 3&#x27;</span>])<br></code></pre></td></tr></table></figure></p><p><img src="legend1.png" alt=""></p><p>控制注释显示的地方，添加<code>bbox_to_anchor</code>和<code>bbox_transform</code>属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.legend([<span class="hljs-string">&#x27;math.sin(i) * 2 - 4&#x27;</span>, <span class="hljs-string">&#x27;math.sin(i) * 2&#x27;</span>, <span class="hljs-string">&#x27;math.cos(i) * 1.3 + 3&#x27;</span>], bbox_to_anchor=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>               bbox_transform=plt.gcf().transFigure)<br></code></pre></td></tr></table></figure></p><p><img src="legend2.png" alt=""></p><h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><p>在设置标题用到中文的时候，可能会出现乱码。<br>可以设置<code>rcParams</code>的字体，解决乱码问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Arial Unicode MS&#x27;</span>]<br></code></pre></td></tr></table></figure></p><p>至此，我们把图表中各个部分都简要介绍了一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本例环境</p><ul><li>macOS</li><li>PyCharm CE</li><li>Python3</li></ul><p>参考资料</p><ul><li>【运营的Python指南】绘制图表Matplotlib快速入门<ul><li><a href="https://rustfisher.com/2021/07/16/Python/operation/matplotlib-intro1">https://rustfisher.com/2021/07/16/Python/operation/matplotlib-intro1</a></li></ul></li><li>Python笔记 <a href="https://rustfisher.com/categories/Python/">https://rustfisher.com/categories/Python/</a></li><li>matplotlib <a href="https://matplotlib.org/">https://matplotlib.org/</a></li></ul>]]></content>
    
    
    <summary type="html">Python的Matplotlib库，介绍图表里的各个组成部分。</summary>
    
    
    
    <category term="Python" scheme="https://blog.rustfisher.com/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.rustfisher.com/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://blog.rustfisher.com/tags/Matplotlib/"/>
    
    <category term="plt" scheme="https://blog.rustfisher.com/tags/plt/"/>
    
  </entry>
  
  <entry>
    <title>【运营的Python指南】绘制图表Matplotlib快速入门</title>
    <link href="https://blog.rustfisher.com/2021/07/16/Python/operation/matplotlib-intro1/"/>
    <id>https://blog.rustfisher.com/2021/07/16/Python/operation/matplotlib-intro1/</id>
    <published>2021-07-16T15:08:11.000Z</published>
    <updated>2023-04-15T07:26:52.299Z</updated>
    
    <content type="html"><![CDATA[<p>绘制图表是运营工作中常见的需求。前面我们试着用<a href="https://rustfisher.com/2019/11/19/Python/Python-op-excel_openpyxl_bar_column_chart/">Python操作Excel来绘制图表</a>，其实调用的是Excel里的图表功能。<br>接下来我们利用<code>Matplotlib</code>来绘制图表。</p><blockquote><p>Matplotlib 是一个综合性的库。它是 Python 的可视化工具，可创建静态、带动画和可交互的图表<br>Matplotlib 官网 <a href="https://matplotlib.org/">https://matplotlib.org/</a><br>官方使用手册 <a href="https://matplotlib.org/stable/users/index.html">https://matplotlib.org/stable/users/index.html</a></p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方给出的安装方法是使用pip<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m pip install -U pip<br>python -m pip install -U matplotlib<br></code></pre></td></tr></table></figure></p><p>我们使用PyCharm，也可以先打<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><br>其中<code>matplotlib</code>下面有红线，跟着PyCharm的提示，把缺失的包装上就好。</p><h2 id="简单例子-绘制折线图"><a href="#简单例子-绘制折线图" class="headerlink" title="简单例子-绘制折线图"></a>简单例子-绘制折线图</h2><p>接下来使用<code>matplotlib</code>绘制一个简单的折线图，先把这个库用起来。</p><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>我们用<code>math.sin</code>来模拟。x从0到100，y=sin(x)。一个简单的sin函数。</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>准备数据，然后绘制出图表。完整代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo1</span>():<br>    x_list = []<br>    y_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i * <span class="hljs-number">0.1</span>))<br>    plt.plot(x_list, y_list)<br>    plt.show()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;rustfisher 绘制折线图事例1&#x27;</span>)<br>    demo1()<br></code></pre></td></tr></table></figure></p><p>Mac的PyCharm运行下能得到这样的图<br><img src="intro1.png" alt=""></p><p>代码中</p><ul><li><code>plt.plot(x_list, y_list)</code>指定x，y值，都是列表。这2个列表的长度要相等。</li><li><code>plt.show()</code>是直接绘制图表。</li></ul><p>可以看到图中缺少很多元素。图的标题没有指定，x轴和y轴都没有说明。</p><h3 id="增加一些细节"><a href="#增加一些细节" class="headerlink" title="增加一些细节"></a>增加一些细节</h3><p>为操作图表，我们需拿到图表对象<code>ax = plt.gca()</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ax = plt.gca()<br>ax.set_title(<span class="hljs-string">&#x27;rustfisher.com mapplotlib example&#x27;</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)<br>ax.grid()<br></code></pre></td></tr></table></figure></p><ul><li><code>set_title</code> 设置图表标题</li><li><code>set_xlabel</code> 设置x轴名称</li><li><code>set_ylabel</code> 设置y轴名称</li><li><code>grid()</code> 显示格子</li></ul><p>修改后的代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo1</span>():<br>    x_list = []<br>    y_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>):<br>        x_list.append(i)<br>        y_list.append(math.sin(i * <span class="hljs-number">0.1</span>))<br>    ax = plt.gca()<br>    ax.set_title(<span class="hljs-string">&#x27;rustfisher.com mapplotlib example&#x27;</span>)<br>    ax.set_xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    ax.set_ylabel(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>)<br>    ax.grid()<br>    plt.plot(x_list, y_list)<br>    plt.show()<br></code></pre></td></tr></table></figure></p><p>运行结果<br><img src="2.png" alt=""></p><h3 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h3><p>从前面图中我们可以看到下面有一排按钮。这些按钮提供了一些操作图表的功能。<br>从左到右我们排个序1，2，3，4..</p><p><img src="btns.png" alt=""></p><ol><li>让图表恢复到初始状态</li><li>上一个图表状态</li><li>下一个图表状态</li><li>移动图表</li><li>缩放图表</li><li>调整图表显示的位置<ol><li>点击缩放按钮后，鼠标按住左键去框选一个区域，松开左键后就是放大那个区域。</li><li>按住右键再框选，则是缩小显示区域。</li></ol></li><li>保存图片</li></ol><h3 id="直接保存"><a href="#直接保存" class="headerlink" title="直接保存"></a>直接保存</h3><p>如果我们想直接保存得到的图片，可以不调用<code>show</code>方法。而是调用<code>savefig()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># plt.show()</span><br>plt.savefig(<span class="hljs-string">&#x27;out.png&#x27;</span>)<br></code></pre></td></tr></table></figure><p>参考</p><ul><li>Python操作Excel来绘制图表 <a href="https://rustfisher.com/2019/11/19/Python/Python-op-excel_openpyxl_bar_column_chart/">https://rustfisher.com/2019/11/19/Python/Python-op-excel_openpyxl_bar_column_chart/</a></li><li>Python绘制漏斗图 <a href="https://rustfisher.com/2021/06/28/Python/Python-op-draw-funnel-1/">https://rustfisher.com/2021/06/28/Python/Python-op-draw-funnel-1/</a></li><li>Python合集 <a href="https://rustfisher.com/categories/Python/">https://rustfisher.com/categories/Python/</a></li></ul>]]></content>
    
    
    <summary type="html">写给运营人员的Python指南。使用Python的Matplotlib库绘图。绘制折线图。</summary>
    
    
    
    <category term="Python" scheme="https://blog.rustfisher.com/categories/Python/"/>
    
    
    <category term="运营的Python指南" scheme="https://blog.rustfisher.com/tags/%E8%BF%90%E8%90%A5%E7%9A%84Python%E6%8C%87%E5%8D%97/"/>
    
    <category term="Matplotlib" scheme="https://blog.rustfisher.com/tags/Matplotlib/"/>
    
    <category term="plot" scheme="https://blog.rustfisher.com/tags/plot/"/>
    
  </entry>
  
  <entry>
    <title>NestJS 静态文件</title>
    <link href="https://blog.rustfisher.com/2021/07/10/NestJS/nestjs-static-file/"/>
    <id>https://blog.rustfisher.com/2021/07/10/NestJS/nestjs-static-file/</id>
    <published>2021-07-10T10:09:18.000Z</published>
    <updated>2023-04-15T07:26:52.248Z</updated>
    
    <content type="html"><![CDATA[<p>为了提供静态资源，我们可以用<code>@nestjs/serve-static</code>包里的<code>ServeStaticModule</code>。<br>服务器上的静态资源，一般指的是文件，比如图片、音频、视频、文本文件或者二进制文件等等。</p><p>或者是一些单页面应用程序(Single Page Application, SPA)。从服务器上请求得到网页，然后网页再执行自己的业务。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先我们需要安装<code>@nestjs/serve-static</code>包。<br>在工程路径下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save @nestjs/serve-static<br></code></pre></td></tr></table></figure></p><p>安装完成后，工程的<strong>package.json</strong>里会多出<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;@nestjs/serve-static&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.1.4&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在root <code>AppModule</code>中，引入<code>ServeStaticModule</code>模块。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ServeStaticModule</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/serve-static&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  <span class="hljs-attr">imports</span>: [<br>  <span class="hljs-title class_">ServeStaticModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>    <span class="hljs-attr">rootPath</span>: <span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;rustfisherData&#x27;</span>),<br>    <span class="hljs-attr">exclude</span>: [<span class="hljs-string">&#x27;/api*&#x27;</span>],<br>  &#125;),],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p><code>imports</code>里添加了<code>ServeStaticModule</code>模块。需要用到<code>ServeStaticModule.forRoot</code>方法。</p><ul><li><code>rootPath</code> 指定了静态文件的根目录</li><li><code>exclude</code> 表明排除在外的文件和目录</li></ul><h3 id="路径说明"><a href="#路径说明" class="headerlink" title="路径说明"></a>路径说明</h3><p>我们关心的是，服务器上哪个目录可以让客户端访问，哪个目录是不开放的。</p><p><code>__dirname</code> 获取到的是当前目录的路径。<br>使用<code>join()</code>方法，拼接出一个新的路径。</p><p>工程编译出来的文件放在<code>dist</code>目录中。<code>app.module.js</code>文件也在里面。<br>此时<code>__dirname</code>表示的是<code>dist</code>目录的路径。<br>那么<code>join(__dirname, &#39;..&#39;, &#39;rustfisherData&#39;)</code>得到的路径就是与<code>dist</code>目录同级的<code>rustfisherData</code>。</p><p>假设我们服务器上运行目录是<code>/home/rustfisher/server/rf-server-nest/dist</code><br>那么静态文件存放的目录就是<code>/home/rustfisher/server/rf-server-nest/rustfisherData</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>ServeStaticModule</code>提供了丰富的自定义控制。开发者可以自定义它的行为。<br>比如像前面那样设置静态文件根目录<code>rootPath</code>；设置排除的路径<code>exclude</code>。</p><p>GitHub上有<a href="https://github.com/nestjs/serve-static/blob/master/lib/interfaces/serve-static-options.interface.ts">详细配置</a></p><blockquote><p><strong>注意</strong><br>访问目录时，默认会找<code>index.html</code>文件发送回去。后文会有更多说明。</p></blockquote><h2 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h2><p>假设服务部署好了（并不是真实项目），网址是 <a href="https://rustfisher.com">https://rustfisher.com</a> 。部署好服务后，我们测试一下。</p><p>打开浏览器，访问url： <a href="https://rustfisher.com/some/path/to/img/11.jpg">https://rustfisher.com/some/path/to/img/11.jpg</a><br>可以在网页上看到图片（并不是真实项目）。</p><p>如果访问一个不存在的路径（文件），它会返回一个默认的<code>index.html</code>。如果没有这个文件，则会报一个ENOENT错误信息<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Nest] <span class="hljs-number">32378</span>   - <span class="hljs-number">07</span><span class="hljs-regexp">/10/</span><span class="hljs-number">2021</span>, <span class="hljs-number">8</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span> PM   [ExceptionsHandler] ENOENT: no such <span class="hljs-keyword">file</span> or directory, <br>stat <span class="hljs-string">&#x27;/home/rustfisher/server/rf-server-nest/rustfisherData/index.html&#x27;</span> +<span class="hljs-number">234539</span>ms<br></code></pre></td></tr></table></figure></p><p>不想让它报这个错，我们可以自己弄一个<code>index.html</code>文件放到对应路径上。<br>这样做的话，访问目录或者不存在的文件会默认返回<code>index.html</code>文件。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>提供访问静态文件的功能比较常见。客户端使用一个url，就能访问服务器上的文件。<br>现在很常见的做法是把文件放在CDN上，减轻服务器的io压力和网络压力。<br>在Linux服务器上，nginx和同类的服务也能轻松实现类似的提供静态文件的功能。</p>]]></content>
    
    
    <summary type="html">使用NestJs，允许访问服务器上的静态文件。</summary>
    
    
    
    <category term="NestJS" scheme="https://blog.rustfisher.com/categories/NestJS/"/>
    
    
    <category term="NestJS" scheme="https://blog.rustfisher.com/tags/NestJS/"/>
    
    <category term="后端" scheme="https://blog.rustfisher.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB安装和部署</title>
    <link href="https://blog.rustfisher.com/2021/07/09/MongoDB/mongodb-install-deploy/"/>
    <id>https://blog.rustfisher.com/2021/07/09/MongoDB/mongodb-install-deploy/</id>
    <published>2021-07-09T14:59:01.000Z</published>
    <updated>2023-04-15T07:26:52.298Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的版本可以在官网 <a href="https://docs.mongodb.com/manual/installation/">https://docs.mongodb.com/manual/installation/</a> 上查询。</p><p>我们使用的是社区版。</p><h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><p>目前用mac来开发，需要在本地安装运行一个mongdb，便于测试调试。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>mac上安装mongodb。在终端中用brew来安装速度有点太慢了。</p><p>我们去 <a href="https://www.mongodb.com/try/download/enterprise">https://www.mongodb.com/try/download/enterprise</a> 下载一个mac使用的版本。<br>在网页右侧选择mongodb版本（这里选的是4.4.4），Platform选择macOS，压缩格式选tgz即可。<br>点击Download需要填一些资料。填好后确认Submit即可。下载后解压文件，得到一个文件夹。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mongodb-macos-x86_64-enterprise-<span class="hljs-number">4.4</span>.<span class="hljs-number">6</span><br>├── LICENSE-Enterprise<span class="hljs-selector-class">.txt</span><br>├── MPL-<span class="hljs-number">2</span><br>├── README<br>├── THIRD-PARTY-NOTICES<br>├── bin<br>│   ├── install_compass<br>│   ├── mongo<br>│   ├── mongocryptd<br>│   ├── mongod<br>│   ├── mongodecrypt<br>│   ├── mongokerberos<br>│   ├── mongoldap<br>│   └── mongos<br>└── snmp<br>    ├── MONGOD-MIB<span class="hljs-selector-class">.txt</span><br>    ├── MONGODBINC-MIB<span class="hljs-selector-class">.txt</span><br>    ├── README-snmp<span class="hljs-selector-class">.txt</span><br>    ├── mongod<span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.master</span><br>    └── mongod<span class="hljs-selector-class">.conf</span>.subagent<br></code></pre></td></tr></table></figure><p>我们将这个目录复制到<code>/usr/local/mongo</code>中，需要用到管理员权限。</p><p>修改<code>~/.bash_profile</code>，添加如下命令。即mongo的目录添加到环境变量中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># mongo db</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/mongo/bin<br></code></pre></td></tr></table></figure></p><p>此时可以重启命令行（终端）。</p><p>检查版本<code>mongod --version</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">~ $ mongod --version<br>db version v4.4.4<br>Build Info: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.4.4&quot;</span>,<br>    <span class="hljs-string">&quot;gitVersion&quot;</span>: <span class="hljs-string">&quot;8db30a63db1a9d84bdcad0c83369623f708e0397&quot;</span>,<br>    <span class="hljs-string">&quot;modules&quot;</span>: [],<br>    <span class="hljs-string">&quot;allocator&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>,<br>    <span class="hljs-string">&quot;environment&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;distarch&quot;</span>: <span class="hljs-string">&quot;x86_64&quot;</span>,<br>        <span class="hljs-string">&quot;target_arch&quot;</span>: <span class="hljs-string">&quot;x86_64&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>能看到版本说明mongodb安装完成。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Mac上启动。我们可以指定数据库路径<code>--dbpath</code>和log位置<code>--logpath</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mongod --dbpath /Users/rustfisher/.mongodb/data --logpath /Users/rustfisher/.mongodb/log/mongodb1.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure></p><p>如果不用<code>sudo</code>，可能会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ERROR: child process failed, exited with 14<br></code></pre></td></tr></table></figure></p><p>后台启动，需要加上<code>--fork</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo mongod --dbpath /Users/rustfisher/.mongodb/data --logpath /Users/rustfisher/.mongodb/log/mongodb1.<span class="hljs-built_in">log</span> --port 1993 --fork<br>about to fork child process, waiting until server is ready <span class="hljs-keyword">for</span> connections.<br>forked process: 7580<br>child process started successfully, parent exiting<br></code></pre></td></tr></table></figure></p><p>查询mongo进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps aux | grep mong<br>rustfisher        7608   0.0  0.0  4268424    732 s003  S+    7:45下午   0:00.00 grep mong<br>root              7580   0.0  0.2  5548488  27868   ??  S     7:44下午   0:01.02 mongod --dbpath /Users/rustfisher/.mongodb/data --logpath /Users/rustfisher/.mongodb/log/mongodb1.<span class="hljs-built_in">log</span> --fork<br></code></pre></td></tr></table></figure></p><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>我们的服务器一般是Linux。接下来在Ubuntu上安装运行mongodb。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Ubuntu上安装mongodb比较简单，用<code>apt-get</code>命令。</p><p>先upadate一次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br></code></pre></td></tr></table></figure></p><p>然后装上4.4.4版本的mongodb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install -y mongodb-org=4.4.4 mongodb-org-server=4.4.4 mongodb-org-shell=4.4.4 mongodb-org-mongos=4.4.4 mongodb-org-tools=4.4.4<br></code></pre></td></tr></table></figure></p><p>等它装完后，看一下版本号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">~$ mongod --version<br>db version v4.4.4<br>Build Info: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;4.4.4&quot;</span>,<br>    <span class="hljs-string">&quot;gitVersion&quot;</span>: <span class="hljs-string">&quot;8db30a63db1a9d84bdcad0c83369623f708e0397&quot;</span>,<br>    <span class="hljs-string">&quot;openSSLVersion&quot;</span>: <span class="hljs-string">&quot;OpenSSL 1.0.2g  1 Mar 2016&quot;</span>,<br>    <span class="hljs-string">&quot;modules&quot;</span>: [],<br>    <span class="hljs-string">&quot;allocator&quot;</span>: <span class="hljs-string">&quot;tcmalloc&quot;</span>,<br>    <span class="hljs-string">&quot;environment&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;distmod&quot;</span>: <span class="hljs-string">&quot;ubuntu1604&quot;</span>,<br>        <span class="hljs-string">&quot;distarch&quot;</span>: <span class="hljs-string">&quot;x86_64&quot;</span>,<br>        <span class="hljs-string">&quot;target_arch&quot;</span>: <span class="hljs-string">&quot;x86_64&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>可以发现，这里的gitVersion和前面用mac装的是一样的。<br>一些关于Linux的操作笔记，可以访问 <a href="https://rustfisher.com/tags/Linux/">https://rustfisher.com/tags/Linux/</a></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Ubuntu操作mongodb的<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/">官方文档</a></p><p>默认的配置文件为 <code>/etc/mongod.conf</code></p><p>把端口改为1993，服务器如果启用了防火墙，记得允许1993端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw allow 1993<br></code></pre></td></tr></table></figure><br>或者在云服务器控制台那里检查一些，是否开放了端口</p><p>服务器使用的是<code>systemctl</code></p><p>启动mongodb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start mongod<br></code></pre></td></tr></table></figure></p><p>查看状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status mongod<br></code></pre></td></tr></table></figure></p><p>重启<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart mongod<br></code></pre></td></tr></table></figure></p><h2 id="MongoDB-Compasss"><a href="#MongoDB-Compasss" class="headerlink" title="MongoDB Compasss"></a>MongoDB Compasss</h2><p>前面我们已经安装好了mongodb，并且运行起来了。接下来我们找一个有图形化界面的软件来访问数据库。</p><p>MongoDB Compass能让用户清晰地看到文档结构，执行查询，修改等等操作。</p><p>在这里可以下载MongoDB Compasss <a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a><br>这里我们使用mac下的1.25.0版本。</p><p>连接到本地的数据库，在Compass中选择新建连接<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">mongodb://127.0.0.1:1993/rustfisher-db?readPreference=<span class="hljs-keyword">primary</span><span class="hljs-variable">&amp;appname</span>=MongoDB%20Compass<span class="hljs-variable">&amp;ssl</span>=false<br></code></pre></td></tr></table></figure><br>前面我们启动mongodb是在1993端口，连接的时候要注意端口号。</p><p><code>127.0.0.1</code>是我们本地的ip，如果要连接到服务器的mongodb，一般可以直接用服务器ip来连接。</p><p>例如服务器公网ip是<code>1.2.3.4</code>，端口是<code>1993</code><br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">mongodb://1.2.3.4:1993/rustfisher-db?readPreference=<span class="hljs-keyword">primary</span><span class="hljs-variable">&amp;appname</span>=MongoDB%20Compass<span class="hljs-variable">&amp;ssl</span>=false<br></code></pre></td></tr></table></figure></p><p>连上mongodb后，就可以自由地进行操作了。</p>]]></content>
    
    
    <summary type="html">本文介绍mongoDb的安装和部署。在mac上，Ubuntu上安装运行mongodb。</summary>
    
    
    
    <category term="MongoDB" scheme="https://blog.rustfisher.com/categories/MongoDB/"/>
    
    
    <category term="MongoDB" scheme="https://blog.rustfisher.com/tags/MongoDB/"/>
    
    <category term="数据库" scheme="https://blog.rustfisher.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
